

# 四、数据操作

本章涵盖以下主题:

*   用一个`data.table`增强一个`data.frame`
*   使用`data.table`管理数据
*   使用`data.table`执行快速聚合
*   使用`data.table`合并大型数据集
*   用`dplyr`对数据进行子集化和切片
*   用`dplyr`采样数据
*   用`dplyr`选择列
*   `dplyr`中的链接操作
*   用`dplyr`排列行
*   用`dplyr`消除重复行
*   使用`dplyr`添加新列
*   用`dplyr`汇总数据
*   使用`dplyr`合并数据

# 简介

大多数 R 用户都会同意，数据框为表格数据提供了一个灵活且富有表现力的结构。虽然数据框对于小数据集很有效，但在处理大于 1gb 的数据时，它们并不理想。此外，在数据框本身内汇总数据并不容易；我们需要加载一个额外的包，比如`plyr`或者`reshape2`，来执行高级聚合。因此，我们将介绍如何使用`data.table`和`dplyr`进行描述性统计。

我们首先说明这两个包是做什么的:

*   `data.table`:这是`data.frame`的延伸；它提供了快速聚合和处理大型数据集的能力。此外，与数据帧相比，它提供了可读性更强、更清晰的语法。
*   `dplyr`:这为用户提供了类似 SQL 的功能，这样我们就可以快速地聚集和汇总来自各种来源的数据。

这两个软件包可以帮助用户从任何给定的表格数据集中快速、轻松地生成描述性统计数据。

在本章中，我们首先介绍如何创建一个`data.table`。然后我们介绍操作、连接和处理数据的操作。接下来，我们将展示如何使用`dplyr`来执行快速数据聚合。事先，在`%>%`链接操作符的帮助下，我们可以使用类似 SQL 的函数对给定的表格数据集快速执行描述性统计。



# 用数据表增强数据框

当你处理一个十亿字节或大的数据集时，你可能会发现`data.frame`是相当低效的。要解决这个问题，您可以使用增强的扩展`data.frame` — `data.table`。在这个菜谱中，我们将展示如何在 r 中创建一个`data.table`。

## 准备就绪

分别从以下 GitHub 链接下载`purchase_view.tab`和`purchase_order.tab`数据集:

*   [https://github . com/yw chiu/rcookbook/blob/master/chapter 6/purchase _ view . tab](https://github.com/ywchiu/rcookbook/blob/master/chapter6/purchase_view.tab)
*   [https://github . com/yw chiu/rcookbook/blob/master/chapter 6/purchase _ order . tab](https://github.com/ywchiu/rcookbook/blob/master/chapter6/purchase_order.tab)

## 怎么做……

执行以下步骤创建一个`data.table`:

1.  首先，使用以下命令安装并加载`data.table`包:

    ```

    > install.packages("data.table")

    > library(data.table)

    ```

2.  接下来，我们可以使用`read.table` :

    ```

    > purchase <- read.table("purchase_view.tab", header=TRUE, sep='\t')

     [1] "data.frame"

    > dim(purchase)

    [1] 1191486       4

    > order <- read.table("purchase_order.tab", header=TRUE, sep='\t')

    > dim(order)

    [1] 54772     6

    ```

    创建一个 R 数据帧
3.  将中的`data.frame`转换成 R `data.table` :

    ```

    > purchase.transform = as.data.table(purchase) 

    > class(purchase.transform)

    [1] "data.table" "data.frame"

    ```

4.  或者，我们可以创建一个新的`data.table` :

    ```

    > dt <- data.table(product=c("p1", "p2", "p3"), price=c(100,200,300), category="beverage" )

    > dt

     product price category

    1:      p1   100 beverage

    2:      p2   200 beverage

    3:      p3   300 beverage

    ```

5.  不使用`colnames`来改变列名，我们可以使用`setnames`函数:

    ```

    > setnames(dt, c("Product", "Price", "Drink"))

    > head(dt)

     Product Price    Drink

    1:      p1   100 beverage

    2:      p2   200 beverage

    3:      p3   300 beverage

    ```

6.  另外，我们可以使用`data.table`包中的`fread`函数来读取数据:

    ```

    > purchase.dt <- fread("purchase_view.tab", header=TRUE, sep='\t')

    > order.dt <- fread("purchase_order.tab", header=TRUE, sep='\t')

    ```

7.  继续，让我们检查数据帧的数据加载速度:

    ```

    > system.time(purchase <- read.table("purchase_view.tab", header=TRUE, sep='\t'))

     user  system elapsed 

     31.74    0.19   32.34 

    ```

8.  现在，让我们比较一下使用`fread`函数时的读取性能:

    ```

    > system.time(purchase.dt <- fread("purchase_view.tab", header=TRUE, sep='\t'))

     user  system elapsed 

     0.84    0.00    0.86 

    ```

9.  类似于我们如何检查来自`data.frame`的数据，我们也可以使用`dim`和`str`函数来检查`data.table` :

    ```

    > dim(purchase.dt)

    [1] 1191486       4

    > str(purchase.dt)

    Classes 'data.table' and 'data.frame': 1191486 obs. of  4 variables:

     $ Time   : chr  "2015-07-01 00:00:01" "2015-07-01 00:00:03" "2015-07-01 00:00:05" "2015-07-01 00:00:05" ...

     $ Action : chr  "view" "view" "view" "view" ...

     $ User   : chr  "U129297265" "U321001337" "U10070718237" "U393805241" ...

     $ Product: chr  "P0023468384" "P0018926456" "P0000063593" "P0005541535" ...

     - attr(*, ".internal.selfref")=<externalptr> 

    ```

    的结构

## 它是如何工作的……

在这个配方的开始，我们演示了如何通过使用`read.table`函数读取`purchase_view.tab`和`purchase_order.tab`文件来创建数据框。我们使用`as.data.table`函数将数据类型从`data.frame`转换成`data.table`。这允许我们用`class`函数列出保存数据的对象类型，输出返回`data.frame`和`data.table`。输出显示`data.table`也是一个数据帧；我们也可以在`data.table`上执行任何`data.frame`兼容的功能。

继续，我们说明了我们可以初始化一个新的`data.table`或者用`fread`函数从一个文件创建一个`data.table`。在`data.frame`中，我们需要使用`colnames`函数来设置列名，但是`colnames`语法本身会复制整个表，这在处理大型数据集时会导致性能问题。但是，`data.table`提供了`setnames`函数，通过引用改变输入，避免复制表。

此时，我们可以比较`read.table`函数和`fread`函数之间的读取性能。这里，我们用`system.time`函数来测量阅读时间。令人惊讶的是，当读取超过百万行(11，91，486 ob)的`purchase_view.tab`文件时。四个变量中)，完成读取任务需要`read.table`函数`31.74`秒。然而`fread`只需要`0.84`秒。这主要是因为`fread`函数是纯 c 实现的，除了性能更好之外，`fread`还可以自动猜测输入文件的分隔符，使得读取数据更加高效简单。

如前所述，`data.table`也是`data.frame`。因此，我们仍然可以用`dim`和`str`函数来检查数据概况和结构。此外，我们还可以对一个`data.table`对象进行数据可视化和模型拟合。

## 还有更多……

除了使用`data.table`中的`fread`函数读取包含数百万行的数据集，我们还可以考虑使用另一个`readr`包将平面文件读入 r 中。`readr`函数在 C++和 Rcpp 中实现。结果性能比`fread`略慢；但是，在从平面文件中读取大量数据时，它仍然是比`read.csv`或`read.table`更好的选择。您可以使用以下命令将`purchase_order.tab`读入 R 会话:

```

> install.packages("readr")

> library("readr")

> order.readr = read_tsv("purchase_order.tab")

> head(order.readr)

Source: local data frame [6 x 6]

 Time Action         User        Product Quantity Price

 (time)  (chr)        (chr)          (chr)    (int) (int)

1 2015-07-01 00:00:01  order   U312622727    P0006944501        1  1069

2 2015-07-01 00:00:03  order   U239012343    P0006018073        1  1680

3 2015-07-01 00:00:19  order U10007697373    P0002267974        1   285

4 2015-07-01 00:01:10  order   U296328517    P0016144236        1   550

5 2015-07-01 00:01:36  order   U300884570 P0014516980122        1   249

6 2015-07-01 00:01:48  order   U451050374    P0004134266        1  1780

> class(order.readr)

[1] "tbl_df"     "tbl"        "data.frame"

```



# 用数据表管理数据

与相比，`data.table`的两个主要优势是前者的速度和更清晰的语法。类似于`data.frame`，我们可以执行切片和子集 a `data.table`的操作。这里，我们介绍一些可以在`data.table`上进行的操作。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤对`data.table`进行数据操作:

1.  首先，使用`head`函数查看前三行:

    ```

    > head(purchase.dt[1:3])

     Time Action         User     Product

    1: 2015-07-01 00:00:01   view   U129297265 P0023468384

    2: 2015-07-01 00:00:03   view   U321001337 P0018926456

    3: 2015-07-01 00:00:05   view U10070718237 P0000063593

    > head(purchase[1:3])

     Time Action         User

    1 2015-07-01 00:00:01   view   U129297265

    2 2015-07-01 00:00:03   view   U321001337

    3 2015-07-01 00:00:05   view U10070718237

    4 2015-07-01 00:00:05   view   U393805241

    5 2015-07-01 00:00:10   view U10004621134

    6 2015-07-01 00:00:11   view   U370110321

    ```

2.  接下来，通过行号和列名选择数据:

    ```

    > purchase.dt[1:3, User]

    [1] "U129297265"   "U321001337"   "U10070718237"

    > purchase[1:3,"User"]

    [1] U129297265   U321001337   U10070718237

    ```

3.  我们可以用`list`函数

    ```

    > user.price <- order[1:3, c("User", "Price") ]

    > head(user.price)

     User Price

    1   U312622727  1069

    2   U239012343  1680

    3 U10007697373   285

    > dt.user.price <- order.dt[1:3, list(User, Price) ]

    > dt.user.price

     User Price

    1:   U312622727  1069

    2:   U239012343  1680

    3: U10007697373   285

    ```

    从`order.dt`中选择多列
4.  或者，我们可以使用。操作:

    ```

    > dt.user.price2 <- order.dt[1:3, .(User, Price) ]

    > head(dt.user.price2)

     User Price

    1:   U312622727  1069

    2:   U239012343  1680

    3: U10007697373   285

    ```

5.  接下来，我们可以按数量过滤订单数据，并从数据集中选择`Price`列:

    ```

    > dt.price <- order.dt[Quantity > 3, Price]

    > head(dt.price)

    [1]  19 159 529  49 536 550

    > price <- order[order$Quantity > 3, "Price"]

    > head(price)

    [1]  19 159 529  49 536 550

    ```

6.  我们可以从`Price`属性中去掉 NA 价格:

    ```

    > dt.omit.price <- order.dt[, na.omit(Price)]

    > head(dt.omit.price)

    [1] 1069 1680  285  550  249 1780

    > omit.price <- order[!is.na(order$Price), "Price"]

    > head(omit.price)

    [1] 1069 1680  285  550  249 1780

    ```

7.  接下来，我们可以从数据集中删除一些包含 NA 价格的行:

    ```

    > dt.omit.price2 <- order.dt[na.omit(Price)]

    > head(dt.omit.price2, 3)

     Time Action       User        Product Quantity Price

    1: 2015-07-01 16:57:15  order U442229329    P0005772981        1   699

    2: 2015-07-01 22:02:12  order U424420542    P0004281340        1  1399

    3: 2015-07-01 08:36:34  order  U37738470    P0005756026        1   719

    ```

8.  此时，我们可以使用`:=`通过引用来更新数据:

    ```

    > dt.omit.price2[,Avg_Price := Price/Quantity]

    > head(dt.omit.price2[Quantity >=2], 3)

     Time           Action            User     Product Quantity Price Avg_Price

    1: 2015-07-02 11:30:03  order U447614356 P0007510112     2   105  52.50000

    2: 2015-07-01 18:12:51  order U367988353 P0005486876     3   179  59.66667

    3: 2015-07-01 11:01:28  order U152432028 P0006173230     4   159  39.75000

    ```

9.  我们也可以使用`:=`通过引用删除属性:

    ```

    > dt.omit.price2[,avg_price:=NULL]

    > head(dt.omit.price2[Quantity >=2], 3)

     Time Action       User     Product Quantity Price

    1: 2015-07-02 11:30:03  order U447614356 P0007510112        2   105

    2: 2015-07-01 18:12:51  order U367988353 P0005486876        3   179

    3: 2015-07-01 11:01:28  order U152432028 P0006173230        4   159

    ```

10.  要复制整个表格，我们可以使用`copy`函数:

    ```

    > dt.omit.price3 <- copy(dt.omit.price2)

    ```

11.  这里，我们用来说明如何从数据集中提取最后一个用户 ID:

    ```

    > purchase.dt[.N, User]

    [1] "U151479349"

    > purchase[nrow(purchase), "User"]

    [1] U151479349

    ```

## 它是如何工作的……

在这个菜谱中，我们演示了如何以`data.frame`和`data.table`的形式对数据进行切片和子集化。首先，让我们了解一下`data.table`命令的基本知识。`data.table`命令由以下形式组成:

```

DT[i, j, by]

```

参数的简要描述如下:

*   `i`部分类似于 SQL 中的`WHERE`子句
*   `j`部分类似于 SQL 中的`SELECT`
*   `by`部分对应于 SQL 中的`GROUP BY`子句

在这一节中，我们关注如何使用`data.table`的`i`和`j`部分对数据进行切片和子集化。

首先，我们可以用给定的索引序列对数据进行切片。我们发现应该在"`,`"逗号前放一个序列来告诉`data.frame`获得前三行。另一方面，`data.table`知道给定的序列用于从数据集中切片前三行，并且在从数据集中切片行时不需要逗号。

除了用给定的行索引对数据进行切片，我们还可以从数据中选择单独的列。类似于 a `data.frame`如何从原始数据帧中选择一列，我们只需要将列名放在逗号后面。我们可以从原始数据集中选择单个列。然而，当我们对多个列进行子集化时，我们需要将列名包装到一个列表中，或者您可以只使用“`.`”来包装选定的列名。

接下来，我们可以通过在行的位置设置过滤条件来执行数据过滤。在这里，我们可以过滤数量超过三个的记录，或者忽略不包含 NA 值的记录。删除包含 NA 值的行时，过滤标准的位置很重要。如果将过滤器应用于`j`部分，我们只能获得没有 NA 值的价格。或者，如果在`i`部分使用过滤器，我们可以检索没有 NA 价格的行。

我们还引入了一些操作来在一个`data.table`内有效地更新数据。一般来说，当变量被修改时，R 复制对象。因此，如果我们仅仅需要添加一个列或者改变一个`data.frame`的数据，我们将调用一个完整的对象复制操作。当处理 1gb 或更大的表时，完整对象复制会带来很大的性能问题。然而，由于`data.table`提供了允许用户通过引用更新数据的函数，我们可以避免处理大型数据集时的性能影响。这里，我们首先说明了如何使用`:=`符号通过引用来更新和删除属性。然后我们演示了如何使用`copy`函数高效地复制一个大对象。

最后，我们介绍了如何使用`.N`从数据表中选择最后一行，这样更方便，因为我们不需要预先计算行数。

## 还有更多……

在本食谱中，我们向您展示了如何使用`copy`功能制作一份原件`data.table`的副本。在`data.frame`中，我们可以使用纯`<-`符号复制一个新的`data.frame`。然而，如果您使用`<-`符号来复制一个`data.table`，这只会复制位置引用。要制作一个`data.table`对象的完整副本，需要使用`copy`函数。在下面的例子中，我们解释了`<-`符号和`copy`函数在复制对象时的不同工作方式:

1.  首先，让我们创建一个新的`data.table` :

    ```

    > dt <- data.table(product=c("p1", "p2", "p3"), price=c(100,200,300), category="beverage" )

    ```

2.  我们可以参照复制原`data.table`，也可以显式复制:

    ```

    > dt2 <- dt

    > dt.copy = copy(dt)

    ```

3.  此时，如果我们更新原始`data.table` :

    ```

    > dt

     product price category

    1:      p1     1 beverage

    2:      p2     1 beverage

    3:      p3     1 beverage

    > dt2

     product price category

    1:      p1     1 beverage

    2:      p2     1 beverage

    3:      p3     1 beverage

    > dt.copy

     product price category

    1:      p1   100 beverage

    2:      p2   200 beverage

    3:      p3   300 beverage 

    ```

    的数据，我们可以看到每个`data.table`是如何受到影响的
4.  最后，我们可以使用`identical`函数来比较两个`data.table` :

    ```

    > identical(dt, dt2)

    [1] TRUE

    > identical(dt, dt.copy)

    [1] FALSE

    ```



# 用数据表进行快速聚合

一个`data.table`的另一个优势是我们可以很容易地聚集数据，而不需要额外的软件包的帮助。在这个菜谱中，我们将说明如何使用`data.table`执行数据聚合。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤对`data.table`进行数据聚合:

1.  首先，我们可以对订单的总价格进行平均:

    ```

    > order.dt[,mean(na.omit(Price))]

    [1] 2012.119

    ```

2.  接下来，我们可以平均每个用户的订单量:

    ```

    > mean.price.by.user <- order.dt[,mean(na.omit(Price)), User]

    > head(mean.price.by.user)

     User      V1

    1:   U312622727  934.00

    2:   U239012343 1298.75

    3: U10007697373  247.00

    4:   U296328517  745.00

    5:   U300884570  249.00

    6:   U451050374 1780.00

    ```

3.  为了用命名聚合的数据，我们可以用`.()` :

    ```

    > mean.price.by.user2 <- order.dt[,.(Price=mean(na.omit(Price))), User]

    > head(mean.price.by.user2)

     User   Price

    1:   U312622727  934.00

    2:   U239012343 1298.75

    3: U10007697373  247.00

    4:   U296328517  745.00

    5:   U300884570  249.00

    6:   U451050374 1780.00

    ```

    包围`mean`函数
4.  然后我们可以按日期计算平均购买金额:

    ```

    > mean.price.by.date <- order.dt[,.(Price=mean(na.omit(Price))), by=as.Date(Time)]

    > head(mean.price.by.date)

     as.Date    Price

    1: 2015-07-01 2380.242

    2: 2015-07-02 2124.970

    3: 2015-07-03 2316.778

    4: 2015-07-04 1933.913

    5: 2015-07-05 1792.385

    6: 2015-07-06 1828.492

    ```

5.  我们还可以通过日期

    ```

    > price_sum_n_users.by.date <- order.dt[,.(Price_Sum = sum(na.omit(Price)), N_Users= length(unique(User))) , by=as.Date(order.dt$Time)]

    > head(price_sum_n_users.by.date)

     as.Date Price_Sum N_Users

    1: 2015-07-01   5524541    1773

    2: 2015-07-02   4349813    1812

    3: 2015-07-03   4114597    1524

    4: 2015-07-04   4184987    1818

    5: 2015-07-05   2530847    1191

    6: 2015-07-06   3475964    1545

    > price_sum_n_users.by.date2 <- order.dt[,.(Price_Sum = sum(na.omit(Price)), N_Users=uniqueN(User)) , by=as.Date(order.dt$Time)]

    > head(price_sum_n_users.by.date2)

     as.Date Price_Sum N_Users

    1: 2015-07-01   5524541    1773

    2: 2015-07-02   4349813    1812

    3: 2015-07-03   4114597    1524

    4: 2015-07-04   4184987    1818

    5: 2015-07-05   2530847    1191

    6: 2015-07-06   3475964    1545

    ```

    来计算总量和用户数量
6.  另外，我们可以计算到目前为止的人均成本:

    ```

    > price_avg.by.date <- order.dt[,.(Price_Avg = sum(na.omit(Price)) / uniqueN(User)) , by=.(Date=as.Date(order.dt$Time))]

    > head(price_avg.by.date)

     Date Price_Avg

    1: 2015-07-01  3115.928

    2: 2015-07-02  2400.559

    3: 2015-07-03  2699.867

    4: 2015-07-04  2301.973

    5: 2015-07-05  2124.976

    6: 2015-07-06  2249.815

    ```

7.  接下来，我们可以按日期:

    ```

    > Price_Sum.by.Date_N_Product <- order.dt[,.(Price_Sum = na.omit(sum(Price* Quantity))) , by=.(Date = as.Date(Time), Product)]

    ```

    检索每个产品的总购买金额
8.  此外，我们可以按照价格的总和按升序对数据进行排序:

    ```

    > sorted.price.asc <- Price_Sum.by.Date_N_Product[order(Price_Sum)]

    > head(sorted.price.asc)

     Date        Product Price_Sum

    1: 2015-07-03    P0009305785        15

    2: 2015-07-07    P0023454992        15

    3: 2015-07-27 P0024828260122        15

    4: 2015-07-30    P0002976595        15

    5: 2015-07-04    P0022533744        19

    6: 2015-07-01    P0015225991        25

    ```

9.  或者，我们可以按照价格的总和降序排列数据:

    ```

    > sorted.price.desc <- Price_Sum.by.Date_N_Product[order(-Price_Sum)]

    > head(sorted.price.desc)

     Date     Product Price_Sum

    1: 2015-07-23 P0006584093   3520000

    2: 2015-07-09 P0006993663    449400

    3: 2015-07-10 P0007082051    446400

    4: 2015-07-03 P0000143500    438888

    5: 2015-07-16 P0000143511    438888

    6: 2015-07-17 P0000143511    438888

    ```

## 它是如何工作的……

在这个菜谱中，我们向您展示了如何用`data.table`聚集数据。使用`data.frame`时，我们只能按行、按列切片、子集数据。如果我们想要对单个列的数据进行平均，我们需要首先从`data.frame`中获得该列，然后我们需要对该单个列应用汇总统计函数。而在`data.table`中，我们只需将该列的汇总统计功能放在`j`部分，就可以对该列进行汇总统计。这样做，我们就可以很容易地从`order.dt`计算出均价。

现在，我们来举例说明如何使用`data.table`中的`by`部分。`by`部分类似于 SQL 表达式中的`GROUP BY`函数。换句话说，我们可以通过在`by`部分指定的变量对值进行分组来计算`j`部分。在这里，我们可以计算每个用户的平均消费金额。此外，如果我们想要指定聚合列的名称，我们可以把要聚合的列放在`.()`符号中。我们也可以将转换函数应用到`by`部分的一个变量上。此时，我们可以通过将时间变量转换为日期来计算每天的平均购物量。

类似于 SQL 操作，我们可以通过将多个变量按同一个变量分组，或者进一步按多个变量分组，来获得多个变量的汇总统计数据。在下一步中，我们向您展示了如何检索购物金额的总和以及按购物日期分组的唯一用户的数量。此时，我们可以使用`length`和`unique`函数来获得唯一用户的数量。另一方面，您可以使用一个更高级的函数`uniqueN`，来获得独立用户的数量。我们就可以得到每个人每天的总膨胀量。我们唯一需要做的事情是根据日期和产品变量对列进行分组。

最后，我们可以按顺序排列`data.table`。为了实现这一点，我们用`order`函数包装排序键列，并检索按升序排列的价格总和排序的结果。但是，为了按价格的总和降序排列数据，我们可以在列名前面加一个减号。

## 还有更多……

通过在`j`部分使用`:=`符号，我们可以使用聚合结果创建一个新列:

```

> order.dt[,':='(Avg_P_By_U= mean(na.omit(Price)) ), User]

> head(order.dt,3)

 Time Action         User     Product Quantity Price Avg_P_By_U

1: 2015-07-01 00:00:01 order   U312622727 P0006944501   1  1069    934.00

2: 2015-07-01 00:00:03 order   U239012343 P0006018073   1  1680  1298.75

3: 2015-07-01 00:00:19 order U10007697373 P0002267974 1    285    247.00

```



# 用数据表合并大型数据集

在之前的菜谱中，我们演示了如何用`data.table`操作和聚集数据。除了在单个表上执行数据操作之外，我们经常需要导入额外的特性或者关联来自其他数据源的数据。因此，我们可以将两个或多个表合并成一个表。在这个菜谱中，我们介绍一些可以用来合并两个`data.table`的方法。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤来合并两个`data.table`:

1.  首先我们通过计算购买物品的数量生成一个`product.dt`数据表:

    ```

    > product.dt <- order.dt[,.(Buy = length(Action)),by=Product]

    > head(product.dt[order(-Buy)])

     Product Buy

    1:    P0005772981 821

    2:    P0024239865 729

    3:    P0004607050 584

    4:    P0003425855 552

    5:    P0014252066 438

    6: P0006587250014 357

    ```

2.  接下来，我们可以按产品计算浏览量，并将计算结果放入`view.dt` :

    ```

    > view.dt <- purchase.dt[, .(n_views = length(User)), by=Product]

    > head(view.dt[order(-n_views)])

     Product n_views

    1: P0004880654    8336

    2: P0004405251    7506

    3: P0006437900    6298

    4: P0006437863    5917

    5: P0024239865    4799

    6: P0004906226    4742

    ```

3.  现在，我们可以使用`merge`函数将`product.dt` 和`view.dt`连接到`Product`列:

    ```

    > merged.dt <- merge(view.dt, product.dt, by="Product")

    > head(merged.dt)

     Product n_views Buy

    1: P0000005913      14   3

    2: P0000006020      13   1

    3: P0000006591       3   1

    4: P0000007744      13   2

    5: P0000008352       4   1

    6: P0000010194       2   1

    ```

4.  或者，我们可以先使用`setkey`在`data.table`上创建一个键，然后执行`view.dt`和`product.dt` :

    ```

    > setkey(view.dt,Product)

    > setkey(product.dt,Product)

    > inner_join.dt <- view.dt[product.dt, nomatch=0]

    > head(inner_join.dt)

     Product n_views Buy

    1: P0000005913      14   3

    2: P0000006020      13   1

    3: P0000006591       3   1

    4: P0000007744      13   2

    5: P0000008352       4   1

    6: P0000010194       2   1

    ```

    的内部连接
5.  至于左连接，我们也可以用`merge`函数或者用`data.table`样式:

    ```

    > left_join <- merge(view.dt, product.dt, by="Product", all.x=TRUE)

    > left_join.dt <- product.dt[view.dt]

    > head(left_join.dt)

     Product Buy n_views

    1: P0000005681  NA       1

    2: P0000005740  NA       1

    3: P0000005751  NA       1

    4: P0000005762  NA       1

    5: P0000005854  NA       1

    6: P0000005865  NA       2

    ```

    来执行左连接
6.  同样，我们可以用`merge`函数或者在`data.table`风格:

    ```

    > right_join <- merge(view.dt, product.dt, by="Product", all.y=TRUE)

    > right_join.dt <- view.dt[product.dt]

    > head(right_join.dt)

     Product n_views Buy

    1:    P0000005913      14   3

    2:    P0000006020      13   1

    3:    P0000006591       3   1

    4:    P0000007744      13   2

    5: P0000008190011      NA   1

    6:    P0000008352       4   1

    ```

    中执行右连接
7.  最后，我们演示了完全外连接如何与`merge`函数一起工作:

    ```

    > full_outer_join <- merge(view.dt, product.dt, by="Product", all=TRUE)

    > head(full_outer_join)

     Product n_views Buy

    1: P0000005681       1  NA

    2: P0000005740       1  NA

    3: P0000005751       1  NA

    4: P0000005762       1  NA

    5: P0000005854       1  NA

    6: P0000005865       2  NA

    ```

## 它是如何工作的……

在关系数据库中，使用 join 操作来组合来自不同来源的信息是很常见的。在这个菜谱中，我们在`data.table`中演示了 join 是如何工作的。这里，我们首先创建两个`data.table`对象。第一个`product.dt`数据表保存了每个产品购买了多少件商品的信息。第二个`view.dt`数据表保存每个产品被查看的次数信息。此时，我们可以执行一个`merge`操作，将这两个`data.table`连接成一个包含购买和查看数量信息的单一关系。

这里，我们首先使用一个`merge`函数来执行`product.dt` 和`view.dt`的内部连接。在`data.frame`中，我们也可以用`merge`函数来组合两个`data.frames`，但这里的`merge`函数属于`data.table`。我们可以使用`merge`函数在两个`data.table`中的任何一个上执行内连接、左连接、右连接或完全外连接。连接类型的不同之处在于，在左连接中，我们必须设置`all.x=TRUE`，在右连接中，我们必须设置`all.y=TRUE`，对于外连接，我们必须设置`all=TRUE`。

除了使用`merge`函数，我们可以考虑不同类型的 join 类似于取两个`data.table`的交互。因此，如果首先使用相同的列名作为键对两个`data.table`进行排序，那么`join`操作将采用二分搜索法的做法来合并两个源的`data.table`。否则，默认操作采用矢量搜索来合并两个`data.table`。这里可以先用`setkey`对两个`data.table`进行排序，然后用`data.table`语法合并两个不同的`data.table`。

## 还有更多……

一旦我们使用`setkey`函数按键列顺序排列数据，我们就可以提取和搜索一个值组的数据:

1.  首先，我们可以创建一个`data.table`，命名为`dt` :

    ```

    > dt <- data.table(product=c("A", "B", "B", "A", "A"), price=c(100,200,300,100,200), quantity=c(2,2,1,3,2) )

    > dt

     product price quantity

    1:       A   100        2

    2:       B   200        2

    3:       B   300        1

    4:       A   100        3

    5:       A   200        2

    ```

2.  接下来，我们用`setkey`按`product`和`price` :

    ```

    > setkey(dt, product, price)

    > dt

     product price quantity

    1:       A   100        2

    2:       A   100        3

    3:       A   200        2

    4:       B   200        2

    5:       B   300        1

    ```

    对`data.table`进行排序
3.  我们使用`mult`参数提取产品`A`和`B` :

    ```

    > dt[c("A","B"),mult="first"]

     product price quantity

    1:       A   100        2

    2:       B   200        2

    ```

    价格最低的记录
4.  或者，我们可以使用`mult`参数提取产品`A`和`B` :

    ```

    > dt[c("A","B"),mult="last"]

     product price quantity

    1:       A   200        2

    2:       B   300        1

    ```

    价格最高的记录
5.  或者，我们可以用`sum`函数来汇总产品`B`的价格:

    ```

    > dt["B",.(sum(price), sum(quantity))]

     V1 V2

    1: 500  3

    ```



# 用 dplyr 对数据进行子集化和切片

在这个配方中，我们将介绍如何使用`dplyr`来操作数据。我们首先讨论如何使用`filter`和`slice`函数对数据进行子集化和切片。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

您还需要确保您的操作系统上安装了高于 3.1.2 的 R 版本。

## 怎么做……

执行步骤后的对带有`dplyr`的数据进行子集化和切片:

1.  让我们先安装并加载的`dplyr`包:

    ```

    > install.packages("dplyr")

    > library(dplyr)

    ```

2.  接下来，我们可以用`filter`函数按数量筛选数据:

    ```

    > quantity.over.3 <- filter(order.dt, Quantity >= 3)

    > head(quantity.over.3, 3)

     Time Action       User     Product Quantity Price

    1: 2015-07-01 00:39:22  order U465146448 P0006173160        3  1076

    2: 2015-07-01 00:59:16  order U465150411 P0007371652        3   119

    3: 2015-07-01 02:26:31  order U333330653 P0010814576        3   289

    ```

3.  此外，我们可以使用多个条件过滤数据:

    ```

    > quantity.price.filter <-  filter(order.dt, Quantity >= 3, Price > 1000)

    > head(quantity.price.filter, 3)

     Time Action       User     Product Quantity Price

    1: 2015-07-01 00:39:22  order U465146448 P0006173160        3  1076

    2: 2015-07-01 13:29:58  order U148075646 P0023947464        3  2980

    3: 2015-07-01 13:41:43  order U373160329 P0006663650        3  3791

    ```

4.  另一方面，我们可以用`|`或运算符过滤数据:

    ```

    > quantity.price.or.filter <-  filter(order.dt, Quantity >= 3 | Price > 1000)

    > head(quantity.price.or.filter, 3)

     Time Action       User     Product Quantity Price

    1: 2015-07-01 00:00:01  order U312622727 P0006944501        1  1069

    2: 2015-07-01 00:00:03  order U239012343 P0006018073        1  1680

    3: 2015-07-01 00:01:48  order U451050374 P0004134266        1  1780

    ```

5.  我们还可以使用`%in%`操作符:

    ```

    > quantity.price.in.filter <-  filter(order.dt, Product %in% c('P0006944501', 'P0006018073'))

    > head(quantity.price.in.filter, 3)

     Time Action       User     Product Quantity Price

    1: 2015-07-01 00:00:01  order U312622727 P0006944501        1  1069

    2: 2015-07-01 00:00:03  order U239012343 P0006018073        1  1680

    3: 2015-07-01 00:03:45  order U311808547 P0006944501        1  1069

    ```

    从数据集中过滤多个类别
6.  除了使用`head`函数，我们还可以使用`slice`函数从`data.table` :

    ```

    > slice(order.dt,1:3)

     Time Action         User     Product Quantity Price

    1: 2015-07-01 00:00:01  order   U312622727 P0006944501        1  1069

    2: 2015-07-01 00:00:03  order   U239012343 P0006018073        1  1680

    3: 2015-07-01 00:00:19  order U10007697373 P0002267974        1   285

    ```

    中获取前三行
7.  最后，我们演示如何使用`slice`函数和`n()`符号来获得最后两行`order.dt` :

    ```

    > slice(order.dt,(n()-1):n())

     Time Action      User        Product Quantity Price

    1: 2015-07-30 23:59:37  order U14085643 P0009890670031        1   245

    2: 2015-07-30 23:59:56  order U33015290    P0014252055        1  1493

    ```

## 它是如何工作的……

为了执行更多的高级描述性分析，我们必须知道如何使用`plyr`包来重塑数据并获得汇总统计数据。但是性能不足和`plyr`语法不明确有很多的缺点。在这里，我们介绍了如何使用一个更快更简单的包，`dplyr`，使描述性分析更容易和更容易理解。在这个菜谱中，我们介绍了如何在`data.table`上应用`filter`和`slice`功能。然而，除了`data.table`之外，我们还可以在`data.frame`上应用`dplyr`中包含的功能。

我们首先介绍如何使用`filter`函数对数据进行子集化。像所有的`data.frame`和`data.table`操作一样，我们可以用单个条件过滤数据。或者，我们可以用多个条件过滤数据。也可以使用`%in%`操作符按多个类别过滤数据。

最后，我们介绍了`slice`函数，它可以按行索引对数据进行切片。为了获得最后几条记录，我们可以在`slice`函数中使用`n()`符号。

## 还有更多……

除了对`data.frame`和`data.table`进行数据分析，我们还可以将`dplyr`连接到 SQLite，并执行 SQL 操作:

1.  首先安装并加载`RSQLite`包:

    ```

    > install.packages("RSQLite")

    > library(RSQLite)

    ```

2.  接下来，将`orderdt`数据表复制到`order.sqlite` :

    ```

    > orderdt <- fread("purchase_order.tab", header=TRUE, sep='\t')

    > my_db <- src_sqlite("order.sqlite", create = T)

    > order_sqlite <-copy_to(my_db, orderdt, temporary = FALSE)

    ```

3.  此时，我们可以对`order.sqlite` :

    ```

    > tbl(my_db, sql("SELECT Product FROM orderdt"))

    ```

    中的`orderdt`执行 SQL 操作



# 用 dplyr 采样数据

由于单台机器无法有效处理大数据问题，一种实用的方法是采集我们可以有效用来得出结论的样本。在这里，我们将向您展示如何使用`dplyr`从数据中采样。

## 准备就绪

确保您在 R 会话中安装并加载了`data.table`。您还需要完成用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

使用`dplyr`执行以下步骤采集数据:

1.  首先，我们可以从数据中抽取六行:

    ```

    > set.seed(123)

    > sample_n(order.dt, 6, replace = TRUE)

     Time Action       User     Product Quantity Price

    1: 2015-07-10 09:22:37  order  U46651253 P0004306934        1   750

    2: 2015-07-25 21:42:34  order U232322558 P0014273055        1  3688

    3: 2015-07-13 22:55:33  order  U14804834 P0013147260        1 32900

    4: 2015-07-29 08:48:18  order U364096419 P0003425855        1   999

    5: 2015-07-30 12:53:09  order U480262356 P0024027371        1   149

    6: 2015-07-02 06:28:22  order U465433065 P0006173543        1   830

    ```

2.  那么，我们用`sample_frac`函数只能获得 10%的数据:

    ```

    > sample.dt <- sample_frac(order.dt, 0.1, replace = TRUE)

    > nrow(sample.dt)

    [1] 5477

    ```

## 它是如何工作的……

数据采样可以从原始数据中随机抽取行，我们可以使用采样的数据进行统计推断。用`dplyr`进行数据采样有两种方法:我们可以用`sample_n`从`order.dt`中随机选择 n 行。如果我们想用替换来采样数据，我们可以在`replace`参数中指定`TRUE`；我们可以使用`sample_frac`从原始数据集中抽取特定百分比的数据。在这个例例中，我们从原始数据集中抽取 10%的数据进行替换。然后，我们使用`nrow`获得样本的行数。该示例包含 5，477 行，约为原始数据集的 10%。

## 还有更多……

我们还可以在`sample_n`或`sampel_frac`函数的`sample`参数中指定样本权重。但是，权重参数输入的长度应与输入数据集的行号匹配:

```

> df <- data.frame(a=seq(1,10,1), b = c(rep(1,8),rep(2,2)))

> set.seed(123)

> sample_n(df, 5, weight=df$b)

 a b

9 9 2

4 4 1

5 5 1

1 1 1

2 2 1

```



# 使用 dplyr 选择色谱柱

在上一个配方中，我们介绍了如何使用`filter`和`slice`函数按行对数据进行子集化和切片。在这个菜谱中，我们将展示如何使用`select`函数从数据集中选择特定的列。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

您还需要确保您的操作系统上安装了高于 3.1.2 的 R 版本。

## 怎么做……

执行以下步骤从数据集中选择列:

1.  首先，让我们从数据集中选择`Quantity`和`Price`列:

    ```

    > select.quantity.price <-  select(order.dt, Quantity, Price)

    > head(select.quantity.price, 3)

     Quantity Price

    1:        1  1069

    2:        1  1680

    3:        1   285

    ```

2.  或者，我们可以通过在前面加一个减号来排除`Price`列:

    ```

    > select.not.price <-  select(order.dt, -Price)

    > head(select.not.price, 3)

     Time Action         User

    1: 2015-07-01 00:00:01  order   U312622727

    2: 2015-07-01 00:00:03  order   U239012343

    3: 2015-07-01 00:00:19  order U10007697373

     Product Quantity

    1: P0006944501        1

    2: P0006018073        1

    3: P0002267974        1

    ```

3.  但是，如果我们想要选择所有的列，我们可以将`everything()`放在`select`函数中:

    ```

    > select.everything <- select(order.dt, everything())

    > head(select.everything,3)

     Time Action         User     Product Quantity Price

    1: 2015-07-01 00:00:01  order   U312622727 P0006944501        1  1069

    2: 2015-07-01 00:00:03  order   U239012343 P0006018073        1  1680

    3: 2015-07-01 00:00:19  order U10007697373 P0002267974        1   285

    ```

4.  我们也可以依次选择多列:

    ```

    > select.from.user.to.quantity <-  select(order.dt, User:Quantity)

    > head(select.from.user.to.quantity, 3)

     User     Product Quantity

    1:   U312622727 P0006944501        1

    2:   U239012343 P0006018073        1

    3: U10007697373 P0002267974        1

    ```

5.  继续，我们可以选择包含某些单词或短语的列:

    ```

    > select.contains.p <- select(order.dt, contains('P') )

    > head(select.contains.p,3)

     Product Price

    1: P0006944501  1069

    2: P0006018073  1680

    3: P0002267974   285

    ```

6.  最后，我们演示如何一起使用`select`和`filter`函数:

    ```

    > select.p.price.over.1000 <- select(filter(order.dt, Price >= 1000 ), contains('P') )

    > head(select.p.price.over.1000, 3)

     Product Price

    1: P0006944501  1069

    2: P0006018073  1680

    3: P0004134266  1780

    ```

## 它是如何工作的……

除了从数据集中选择单独的行，我们还可以使用`dplyr`中的`select`函数从数据集中选择一列或多列。在这个菜谱中，我们首先从`order.dt`中选择`Quantity`和`Price`列。或者，我们可以在没有特定列的情况下获得数据，方法是在该列前面放置一个减号。要从数据集中选择每一列，只需将`everything()`放在`select`函数中。

接下来，为了选择从`User`到`Quantity`的列，我们可以将`User`和`Quantity`放在一个序列表中。因此，我们可以获得一个带有`User`、`Product`和`Quantity`的子集作为回报。

也可以使用`contains`功能选择包含特定单词的列。在这里，我们可以获得一个列名包含`P`的子集。

除了单独使用`select`或`filter`之外，我们可以将它们包装在一个函数调用中。因此，我们可以先通过`quantity`过滤`order.dt`，然后选择列名包含`P`字符的列。

## 还有更多……

要选择列名以`a`开头并且在范围序列中的多个列，我们可以在`select`函数中使用`num_range`:

这里，让我们使用`num_range`函数来选择名称等于`a1`和`a2`的列:

```

> set.seed(123)

> df <- data.frame(a1=rnorm(3), a2=rnorm(3), b1=1, b2=NA, b3="str")

> select(df, num_range("a", 1:2))

 a1         a2

1 -0.5604756 0.07050839

2 -0.2301775 0.12928774

3  1.5587083 1.71506499

```



# dplyr 中的链接操作

为了使用`dplyr`对数据执行多个操作，我们可以将函数调用包装成一个更大的函数调用。或者，我们可以使用`%>%`链接操作符来链接操作。在本菜谱中，我们介绍了如何在使用`dplyr`时进行连锁操作。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

使用`dplyr`执行以下步骤对数据进行子集化和切片:

1.  在 R 中，总结出一个从`1`到`10`的序列，我们可以用`sum`函数:

    ```

    > sum(1:10)

    [1] 55

    ```

    将`1`到`10`的序列包装起来
2.  或者，我们可以使用一个链接操作符来链接操作:

    ```

    > 1:10 %>% sum()

    [1] 55

    ```

3.  用`dplyr`选择和过滤数据，我们可以将过滤后的数据包装在一个`select`函数中:

    ```

    > select.p.price.over.1000 <- select(filter(order.dt, Price >= 1000 ), contains('P') )

    > head(select.p.price.over.1000, 3)

     Product Price

    1: P0006944501  1069

    2: P0006018073  1680

    3: P0004134266  1780

    ```

4.  或者，我们可以使用`%>%`操作符来连锁操作:

    ```

    > chain.operations <- select(order.dt, contains('P') ) %>% filter(Price >= 1000 )

    > head(chain.operations,3)

     Product Price

    1: P0006944501  1069

    2: P0006018073  1680

    3: P0004134266  1780

    ```

5.  此外，可以使用%>%运算符继续链接操作:

    ```

    > select(order.dt, contains('P') ) %>% filter(Price >= 1000 ) %>% select(Price) %>% sum()

    [1] 89959970

    ```

## 它是如何工作的……

在前面方法的最后一步，我们演示了如何在函数调用中选择并过滤数据集。然而，当我们需要执行多个操作时，错综复杂的函数调用就变得复杂了。为了创建一个可读性更好的语法，我们可以使用来自`magrittr`的`%>%`链接操作符来链接所有的`dplyr`操作。

首先，我们展示了如何将`sum`函数应用到从`1`到`10`的序列中。与所有其他函数调用类似，我们只需要用`sum`函数包围这个系列。除了包装序列，我们可以用`%>%`链接操作符链接操作。此时，我们现在可以使用 chaining 操作符来链接由`dplyr`发出的多个函数调用。最后，我们演示了如何用链接操作符链接数据过滤和列选择操作。如果需要，可以继续链接操作。

## 还有更多……

我们可以使用`%.%`作为链接操作符，而不是使用`%>%`操作符。然而，由于`%.%`操作符被标记为不推荐使用，为了将来的包兼容性，我们应该将`%.%`切换为`%>%`。以下命令可用于查看链运算符文档:

```

> ?"%.%"

```



# 用 dplyr 排列行

将行按顺序排列可能有助于我们按值对数据进行排序，或者获得同一类别中数据的更加结构化的视图。在这个食谱中，我们将介绍如何用`dplyr`排列行。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤，用`dplyr`排列数据:

1.  要按价格排列数据，将`Price`传递给`arrange`函数:

    ```

    > order.dt %>% arrange(Price) %>% head(3)

     Time Action        User     Product Quantity Price

    1: 2015-07-30 23:54:01  order  U166076125 P0003659246        3    10

    2: 2015-07-03 09:19:24  order U1012162712 P0009305785        1    15

    3: 2015-07-07 23:45:09  order  U423898356 P0023454992        1    15

    ```

2.  我们也可以按`price`降序排列行:

    ```

    > order.dt %>% arrange(desc(Price)) %>% head(3)

     Time Action         User     Product Quantity  Price

    1: 2015-07-03 16:01:57  order U10120098943 P0000143500        1 438888

    2: 2015-07-16 17:05:30  order U10062834851 P0000143511        1 438888

    3: 2015-07-17 17:57:13  order U10120098943 P0000143511        1 438888

    ```

3.  可以通过两个列变量对数据进行排序:

    ```

    > order.dt %>% arrange(Price, desc(Quantity)) %>% head(3)

     Time Action       User     Product Quantity Price

    1: 2015-07-30 23:54:01  order U166076125 P0003659246        3    10

    2: 2015-07-12 01:32:29  order U465000350 P0002976595       24    15

    3: 2015-07-12 01:50:35  order U464992246 P0002976595       24    15

    ```

## 它是如何工作的……

要按`dplyr`中的列对数据进行排序，我们只需要将排序后的键名传递给`arrange`函数中的。在这里，我们演示了可以按价格升序对数据进行排序。通过对价格应用`desc`函数，我们可以按价格降序排列数据。此外，我们可以在一个`arrange`函数中通过多个键对数据进行排序。

## 还有更多……

在的`arrange`函数中，我们可以使用`desc`函数对数据进行降序排序。然而，我们可以使用`desc`函数，通过在前面加一个减号，将一个向量转换成逆序:

```

> s <- c(1,3,2,4,6)

> desc(s)

[1] -1 -3 -2 -4 -6

```



# 使用 dplyr 消除重复行

为了避免计算重复行，我们可以在 SQL 中使用`distinct` 操作。在`dplyr`中，我们还可以从给定的数据集中消除重复的行。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤，用`dplyr`区分重复行:

1.  首先，我们说明如何从数据集中获得独特的产品:

    ```

    > order.dt %>% select(Product) %>% distinct() %>% head(3)

     Product

    1: P0006944501

    2: P0006018073

    3: P0002267974

    ```

2.  我们还可以`distinct`重复包含多列的行:

    ```

    > distinct.product.user.dt <- order.dt %>% select(Product, User) %>% distinct()

    > head(distinct.product.user.dt, 3)

     Product         User

    1: P0006944501   U312622727

    2: P0006018073   U239012343

    3: P0002267974 U10007697373

    ```

3.  此时，我们来比较一下执行数据区分前后的行数:

    ```

    > nrow(order.dt)

    [1] 54772

    > nrow(distinct.product.user.dt)

    [1] 50381

    ```

## 它是如何工作的……

为了从我们的数据中统计出唯一的项目或用户，我们需要删除重复的行。在`dplyr`中，我们可以使用`distinct`函数来消除重复的行。首先，我们从数据集中选择`product`列，然后排除重复的产品。这将返回一组独特的产品。然后，我们演示我们删除了多个列的重复行。我们首先从数据集中选择`Product`和`User`列，然后对返回的集合执行`distinct`。

最后，我们可以用`nrows`统计数据区分前后的数据行数。这里，我们发现产品和用户的唯一组合的行数少于数据集的原始行数。

## 还有更多……

我们还可以使用基础包中的`unique`函数从数据集中获得不同的值:

```

> data.frame(a=c(1,2,1,1,2)) %>% select(a) %>% unique()

 a

1 1

2 2

```



# 使用 dplyr 添加新列

除了在现有列上执行数据操作，还有一些情况，用户可能需要创建一个新列来进行更高级的分析。在这个菜谱中，我们将介绍如何使用`dplyr`添加一个新列。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤向现有数据集中添加新列:

1.  首先，我们计算每次购买的平均价格，并将创建的结果作为一列添加回原始数据集:

    ```

    > order.dt %>%  select(Quantity, Price) %>% mutate(avg_price= Price/Quantity) %>% head()

     Quantity Price avg_price

    1:        1  1069      1069

    2:        1  1680      1680

    3:        1   285       285

    4:        1   550       550

    5:        1   249       249

    6:        1  1780      1780

    ```

2.  或者，我们可以使用`transmute`函数在`order.dt`上创建一个新列，并删除其余的变量:

    ```

    > transmute(order.dt, Avg_Price= Price/Quantity) %>% head()

     Avg_Price

    1:      1069

    2:      1680

    3:       285

    4:       550

    5:       249

    6:      1780

    ```

## 它是如何工作的……

这个菜谱向您展示了如何向现有的数据集中添加一个新列。首先，我们演示了可以通过将价格除以每次购物交易的数量来创建一个名为`avg_price`的新列。这里，我们使用`dplyr`中的`mutate`函数根据计算创建新列。除了保留原始变量，我们可以使用`transmute`函数选择删除现有变量。

## 还有更多……

我们还可以利用基础包中的`transform`函数从数据集中添加一个新列:

```

> order.dt %>% select(Quantity, Price) %>% transform(Avg_Price= Price/Quantity) %>% head()

 Quantity Price Avg_Price

1:        1  1069      1069

2:        1  1680      1680

3:        1   285       285

4:        1   550       550

5:        1   249       249

6:        1  1780      1780

```



# 用 dplyr 汇总数据

除了操作数据集，`dplyr`最重要的部分是我们可以轻松地从数据中获得汇总统计数据。在 SQL 操作中，我们可以使用`GROUP BY`函数来实现这个目的，也可以在`dplyr`中执行类似的操作。在本食谱中，我们将向您展示如何使用`dplyr`汇总数据。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，并将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤，用`dplyr`汇总数据:

1.  首先使用`summarize`和`group_by`函数获取每种产品的总购买金额:

    ```

    > order.dt %>% 

    +   select(User, Price) %>%

    +   group_by(User) %>%

    +   summarise(sum(Price)) %>%

    +   head()

     User sum(Price)

    1   U312622727       1868

    2   U239012343       5195

    3 U10007697373        494

    4   U296328517       1490

    5   U300884570        249

    6   U451050374       1780

    ```

2.  要获得多个列的汇总统计，可以使用`summarize_each`函数:

    ```

    > order.dt %>% 

    +   select(User, Price, Quantity) %>%

    +   filter(! is.na(Price)) %>%

    +   group_by(User) %>%

    +   summarise_each(funs(sum), Price, Quantity) %>%

    +   head()

     User Price Quantity

    1   U312622727  1868        2

    2   U239012343  5195        4

    3 U10007697373   494        3

    4   U296328517  1490        2

    5   U300884570   249        1

    6   U451050374  1780        1

    ```

3.  此外，我们可以使用`summarize_each`获得每个用户花费的最低和最高价格:

    ```

    > order.dt %>% 

    +   select(User, Price) %>%

    +   filter(! is.na(Price)) %>%

    +   group_by(User) %>%

    +   summarise_each(funs(max(., na.rm=TRUE), min(., na.rm=TRUE)), Price) %>%

    +   head()

     User  max  min

    1   U312622727 1069  799

    2   U239012343 2999  200

    3 U10007697373  285  209

    4   U296328517  940  550

    5   U300884570  249  249

    6   U451050374 1780 1780

    ```

4.  此外，我们可以使用 `n()`符号:

    ```

    > purchase.dt %>% 

    +   select(User, Product) %>%

    +   group_by(Product) %>%

    +   summarise_each(funs(n())) %>%

    +   head()

     Product User

    1 P0023468384    1

    2 P0018926456  198

    3 P0000063593   84

    4 P0005541535    5

    5 P0022135540    9

    6 P0001249080  173

    ```

    获得购买的每个产品的数量
5.  我们可以使用`n_distinct`函数统计唯一用户购买产品的数量:

    ```

    > purchase.dt %>% 

    +   select(User, Product) %>%

    +   group_by(Product) %>%

    +   summarise_each(funs(n_distinct(User))) %>%

    +   head()

     Product User

    1 P0023468384    1

    2 P0018926456  104

    3 P0000063593   51

    4 P0005541535    1

    5 P0022135540    7

    6 P0001249080  155

    ```

## 它是如何工作的……

`dplyr`的一个很大的优势就是提供了常用的数据操作函数，比如`select`和`filter`。使用链接操作符，我们可以执行类似 SQL 的操作来汇总数据。在这个菜谱中，我们介绍了如何使用一些`dplyr`函数获得汇总统计数据。

在这个配方的第一步中，我们介绍了如何使用`summarize`和`group_by`函数获得每个用户的购买总额。此外，为了获得多列的汇总统计数据，我们可以使用`summarize_each`作为汇总函数，方法是将`funs(sum)`作为第一个参数传递给`summarize_each`函数。我们可以使用`summarize_each`来计算每个用户的总购买价格和购买数量。要对同一列执行不同的汇总操作，我们只需要将所有不同的汇总函数传递给`funs`函数。在这个菜谱的第 3 步中，我们用`summarize_each`函数检索了每个用户的最低和最高支付价格。

最后，我们可以使用`n()`函数来统计每个产品的购买量。如果我们想获得唯一用户数量购买的产品，我们可以通过`n_distinct`来代替。

## 还有更多……

如果我们使用`group_by`函数按特定变量对数据进行分组，由于现有的分组，我们可能无法按任何给定的列自由地对数据进行排序。因此，我们可以使用`ungroup`函数来删除现有的分组，然后我们可以按任何变量对汇总数据进行排序:

1.  首先，生成一个包含用户、产品和价格信息的样本`data.frame`:

    ```

    > sample.df <-data.frame(user   =c("U1", "U1", "U1", "U3"),

    +                        product=c("A" , "B" , "A" , "B" ),

    +                        price  =c(200 ,  100,  300 , 300 ))

    ```

2.  接下来，获取用户和产品的购买金额之和，然后按照购买金额之和对数据进行排序:

    ```

    > sample.df %>% 

    +   group_by(user,product) %>% 

    +   summarise(price_sum = sum(price)) %>% 

    +   arrange(price_sum)

    Source: local data frame [3 x 3]

    Groups: user [2]

     user product price_sum

     (fctr)  (fctr)     (dbl)

    1     U1       B       100

    2     U1       A       500

    3     U3       B       300

    ```

3.  我们可以检查如果使用`ungroup`函数删除现有的分组会发生什么:

    ```

    > sample.df %>% 

    +   group_by(user,product) %>% 

    +   summarise(price_sum = sum(price)) %>%

    +   ungroup() %>% 

    +   arrange(price_sum)

    Source: local data frame [3 x 3]

     user product price_sum

     (fctr)  (fctr)     (dbl)

    1     U1       B       100

    2     U3       B       300

    3     U1       A       500

    ```



# 用 dplyr 合并数据

在 SQL 操作中，我们可以执行一个连接操作来组合两个不同的数据集。在`dplyr`中，我们有相同的连接操作，使我们能够轻松地合并数据。在这个菜谱中，我们解释 join 在`dplyr`中是如何工作的。

## 准备就绪

确保您已经完成了用数据表增强数据帧的*，将`purchase_view.tab`和`purchase_order.tab`作为`data.frame`和`data.table`加载到您的 R 环境中。*

## 怎么做……

执行以下步骤将数据与`dplyr`合并:

1.  首先我们通过计算购买物品的金额生成一个`product.dt`数据表:

    ```

    > product.dt <- order.dt[,.(Buy = length(Action)),by=Product]

    > head(product.dt[order(-Buy)])

     Product Buy

    1:    P0005772981 821

    2:    P0024239865 729

    3:    P0004607050 584

    4:    P0003425855 552

    5:    P0014252066 438

    6: P0006587250014 357

    ```

2.  接下来，我们可以按产品计算浏览量，并将计算结果放入`view.dt` :

    ```

    > view.dt <- purchase.dt[, .(n_views = length(User)), by=Product]

    > head(view.dt[order(-n_views)])

     Product n_views

    1: P0004880654    8336

    2: P0004405251    7506

    3: P0006437900    6298

    4: P0006437863    5917

    5: P0024239865    4799

    6: P0004906226    4742

    ```

3.  我们可以使用`inner_join`函数通过`Product`列:

    ```

    > merged.dt <- inner_join(view.dt, product.dt, by="Product")

    > head(merged.dt)

     Product n_views Buy

    1 P0000005913      14   3

    2 P0000006020      13   1

    3 P0000006591       3   1

    4 P0000007744      13   2

    5 P0000008352       4   1

    6 P0000010194       2   1

    ```

    连接`product.dt`和`view.dt`
4.  或者，我们也可以用`left_join`函数执行左连接:

    ```

    > left_join.dt <- left_join(view.dt, product.dt, by="Product")

    > head(left_join.dt)

     Product n_views Buy

    1 P0000005681       1  NA

    2 P0000005740       1  NA

    3 P0000005751       1  NA

    4 P0000005762       1  NA

    5 P0000005854       1  NA

    6 P0000005865       2  NA

    ```

5.  同样，我们可以通过`right_join` 函数:

    ```

    > right_join.dt <- right_join(view.dt, product.dt, by="Product")

    > head(right_join.dt)

     Product n_views Buy

    1    P0006944501      19   8

    2    P0006018073     101   4

    3    P0002267974      65  10

    4    P0016144236      NA   1

    5 P0014516980122      NA   1

    6    P0004134266    1605 313

    ```

    执行右连接
6.  最后，我们使用`full_join`函数来演示完全连接是如何工作的:

    ```

    > full_join.dt <- full_join(view.dt, product.dt, by="Product")

    > head(full_join.dt)

     Product n_views Buy

    1 P0023468384       1  NA

    2 P0018926456     198  NA

    3 P0000063593      84  NA

    4 P0005541535       5  NA

    5 P0022135540       9  NA

    6 P0001249080     173   1

    ```

## 它是如何工作的……

在这个菜谱中，我们在`dplyr`中演示了 join 是如何工作的。在这里，我们首先创建了两个`data.table`对象。第一个`product.dt`数据表保存了每个产品购买了多少件商品的信息。第二个`view.dt`数据表包含每个产品被查看了多少次的信息。此时，我们可以执行一个合并操作，将这两个`data.tables`合并成一个具有购买金额和查看次数的关系。

我们现在可以使用和`inner_join`函数来执行`product.dt`和`view.dt`的内部连接。接下来，我们可以对两个`data.table`或`data.frame`中的任何一个执行左连接、右连接或完全连接。

## 还有更多……

除了根据匹配值连接表之外，我们还可以执行一个`anti_join`来从第一个表中检索在第二个表中没有任何匹配值的所有行:

```

> first.df  <- data.frame(a=c("A","B"), b=c(10,20))

> second.df <- data.frame(a=c("B","C"), c=c("P","A"))

> anti_join(second.df,first.df, by="a")

 a c

1 C A

> anti_join(first.df,second.df, by="a")

 a  b

1 A 10

```