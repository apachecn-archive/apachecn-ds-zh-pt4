<title>Chapter 5. Impossible or Improbable – A Gentle Introduction to Probability</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 第五章。不可能或不可能——概率的温和介绍

在接下来的几章中，我们将探索概率和统计作为检验数据驱动的情况和真实世界场景的方法。概率规则支配着预测的基础。我们用概率来定义一个事件发生的几率。

在本章中，我们将探讨以下主题:

*   概率是什么？
*   频率主义方法和贝叶斯方法的区别
*   如何可视化概率
*   如何利用概率规则
*   使用混淆矩阵查看基本指标

概率将帮助我们模拟现实生活中的事件，包括随机性和偶然性。在接下来的两章中，我们将看看概率定理背后的术语，以及如何将它们应用于可能意外出现的模型情况。

# 基本定义

概率最基本的概念之一是过程的概念。一个 **程序**是一个导致结果的行为。比如掷骰子或者访问网站。

一个**事件** 是一个过程结果的集合，比如掷硬币得到一个正面或者仅仅 4 秒后离开一个网站。简单事件是不能进一步分解的程序的结果/事件。例如，滚动两个骰子可以分解为两个简单的事件:滚动骰子 1 和滚动骰子 2。

程序的**样本空间** 是所有可能的简单事件的集合。比如做一个实验，一枚硬币连续抛三次。这个实验的样本空间有多大？

答案是八，因为结果可能是以下样本空间中的任何一种可能性—{HHH、HHT、HTT、泰国、TTT、泰国、THH 或 THT}。

<title>Probability</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 概率

事件的**概率** 代表事件发生的频率，或者说几率。

对于**符号**，如果 *A* 是一个事件， *P(A)* 是该事件发生的概率。

我们可以将事件的实际概率 *A* 定义如下:

![Probability](graphics/B05260_05_f1.jpg)

这里， *A* 是正在讨论的事件。想象一个所有事情都有可能发生的宇宙，让我们把它描绘成一个圆圈。我们可以把一个单独的事件 **A** 看作是更大宇宙中的一个更小的圆，如下图所示:

![Probability](graphics/B05260_05_02.jpg)

现在让我们假设我们的宇宙涉及一项对人类的研究，而 **A** 事件是研究中患有癌症的人。

如果我们的研究有 100 人， *A* 有 25 人，那么 *A* 或者 *P(A)* 的概率是 25/100。

任何事件的最大概率是 1。这可以理解为红圈长得很大，是宇宙的大小(较大的圈)。

最基本的例子(我保证它们会变得更有趣)是抛硬币。假设我们有两个硬币，我们需要掷出两个头像的概率。我们可以很容易地计算出两枚硬币最终成为两个头像的方式。只有一个！两枚硬币都必须是正面。但是有多少选择呢？它可以是两个头，两条尾巴，或者是头/尾巴的组合。

先来定义一下 a，是两个头发生的事件。可能发生的方式数为 1。

实验的样本空间为{HH，HT，TH，TT}，其中每两个字母的单词*同时表示第一个和第二个硬币的结果。样本空间的大小是 4。所以， *P(得到两个头)= 1/4* 。*

我们参考一个快速直观的表格来证明一下。下表将硬币 1 的选项表示为列，硬币 2 的选项表示为行。在每个单元格中，要么是真，要么是假。真值表示它满足条件(两个头)，假值表示不满足条件。

|   | 

硬币 1 是正面

 | 

硬币 1 是反面

 |
| --- | --- | --- |
| **硬币 2 是正面的** | 真实的 | 错误的 |
| **硬币 2 是反面** | 错误的 | 错误的 |

所以，我们有四种可能结果中的一种。

<title>Bayesian versus Frequentist</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 贝叶斯对频率主义者

前面的例子几乎太简单了。实际上，我们很难真正计算出事情发生的方式。例如，假设我们想知道一个随机的人每天至少抽一次烟的概率。如果我们想用经典的方法(之前的公式)来解决这个问题，我们需要弄清楚一个人有多少种不同的吸烟方式——一个每天至少吸烟一次的人——这是不可能的！

当面临这样的问题时，在计算实践中的概率时会考虑两个主要的思想流派:频率主义方法和 T2 贝叶斯方法。这一章将着重于频率主义方法，而下一章将深入贝叶斯分析。

## 频率主义方法

在频率主义方法中，事件的概率是通过实验来计算的。它利用过去来预测一个事件未来的可能性。基本公式如下:

![Frequentist approach](graphics/B05260_05_f2.jpg)

基本上，我们观察事件的几个实例，并计算满足的次数*。这些数字的除法是概率的近似值。*

贝叶斯方法的不同之处在于，它规定必须使用理论手段来辨别概率。使用贝叶斯方法，我们将不得不更加批判性地思考事件及其发生的原因。这两种方法都不是永远 100%正确的答案。通常，这归结于使用任一方法的问题和困难。

频率主义方法的关键是相对频率。

一个事件的**相对频率**是一个事件发生的频率除以观测的总数。

**示例——营销统计数据**

假设你对确定一个访问你网站的人以后有多长时间会回来感兴趣。这有时被称为回头客率。在前面的定义中，我们将把我们的 *A* 事件定义为一个访问者回到站点。然后，我们将不得不计算一个人可以回来的方式的数量，这实际上一点意义也没有！在这种情况下，许多人会转向贝叶斯方法；然而，我们可以计算出所谓的相对频率。

因此，在这种情况下，我们可以获取访问者日志，并计算事件 *A* (重复访问者)的相对频率。比如说，在过去一周内*1458*个独立访客中， *452* 个是回头客。我们可以这样计算:

*P(A)RF(A)=*

所以，大约 31%的访问者是回头客。

### 大数定律

甚至频率主义者方法也能做到这一点的原因是因为大数定律，即如果我们一遍又一遍地重复一个过程，相对频率概率将接近实际概率。让我们尝试使用 Python 来演示这一点。

如果我问你数字 1 和 10 的平均值，你会很快回答 5 左右。这个问题等同于让你在 1 到 10 之间选择平均数字。让我们将实验设计如下:

Python 会在 1 到 10 之间选择 *n* 个随机数，求它们的平均值。

我们将使用一个更大的 *n* 重复这个实验几次，然后我们将绘制结果图。步骤如下:

1.  从 1 到 10 之间选一个随机数，求平均值。
2.  从 1 到 10 之间随机选择两个数字，并求出它们的平均值。
3.  从 1 到 10 中选三个随机数，求它们的平均值。
4.  从 1 到 10 之间随机抽取 10，000 个数字，求它们的平均值。
5.  用图表表示结果。

让我们看一下代码:

```
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
%matplotlib inline
results = []
for n in range(1,10000):
    nums = np.random.randint(low=1,high=10, size=n) # choose n numbers between 1 and 10
    mean = nums.mean()                              # find the average of these numbers
    results.append(mean)                            # add the average to a running list

# POP QUIZ: How large is the list results?
len(results) # 9999
# This was tricky because I took the range from 1 to 10000 and usually we do from 0 to 10000
df = pd.DataFrame({ 'means' : results})
print df.head() # the averages in the beginning are all over the place!
# means
# 9.0
# 5.0
# 6.0
# 4.5
# 4.0
print df.tail() # as n, our size of the sample size, increases, the averages get closer to 5!
# means
# 4.998799
# 5.060924
# 4.990597
# 5.008802
# 4.979198
df.plot(title='Law of Large Numbers')
plt.xlabel("Number of throws in sample")
plt.ylabel("Average Of Sample")
```

![The law of large numbers](graphics/B05260_05_04.jpg)

很酷，对吧？这本质上向我们展示的是，随着我们相对频率样本量的增加，频率接近实际平均值(概率)5。

在我们的统计学章节中，我们将更严格地定义这个定律，但是现在，只要知道它被用于将事件的相对频率与其实际概率联系起来。

<title>Compound events</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 复合事件

有时候，我们需要处理两个或者更多的事件。这些被称为**复合事件**。复合事件是由两个或多个简单事件组合而成的任何事件。当这种情况发生时，我们需要一些特殊的符号。

给定事件 *A* 和 *B* :

*   *A* 和 *B* 发生的概率为 *P(A ∩ B) = P(A 和 B)*
*   *A* 或 *B* 发生的概率为 *P(A* ![Compound events](graphics/chp5.jpg) * B) = P(A 或 B)*

理解我们为什么对这些复合事件使用集合符号是非常重要的。还记得我们之前如何用圆圈来表示宇宙中的事件吗？假设我们的**宇宙**是 100 个参加实验的人，在这个实验中，一种新的癌症测试正在开发中:

![Compound events](graphics/B05260_05_05.jpg)

在上图中，红色圆圈 **A** 代表 25 名实际患有癌症的人。使用相对频率法，我们可以说 *P(A) =患癌人数/研究人数*，即 *25/100 = = .25* 。这意味着某人有 25%的机会患癌症。

让我们介绍第二个事件，称为 **B** ，如图所示，其中包含测试呈阳性的人(据称他们患有癌症)。假设这是给 30 个人的。所以， *P(B) = 30/100 = 3/10 = .3* 。这意味着对于任何给定的人，测试结果为阳性的概率为 30%:

![Compound events](graphics/B05260_05_06.jpg)

这是两个独立的事件，但它们相互影响。也就是说，他们可能*与*相交或者有共同的人，如下所示:

![Compound events](graphics/B05260_05_07.jpg)

在 **A** 和 **B** 占据的空间中的任何人，或者被称为 *A 相交 B* 或 *A ∩ B* 的人，是测试声称他们癌症呈阳性( **A** )并且他们实际上患有癌症的人。假设有 20 个人。测试显示有 20 人呈阳性，即他们患有癌症，如下图所示:

![Compound events](graphics/B05260_05_08.jpg)

这意味着 *P(A 和 B) = 20/100 = 1/5 = .2 = 20%* 。

如果我们想说某人得了癌症，测试结果呈阳性。这将是两个事件的总和(或并集)，即 5、20 和 10 的总和，即 35。因此，35/100 的人要么患有癌症，要么测试结果呈阳性。也就是说， *P(A 或 B) = 35/100 = .35 = 35%* 。

总而言之，我们有以下四个不同阶层的人:

*   **粉色**:这是指患有癌症且测试结果为阴性的人
*   **紫色(A 与 B 相交)**:这些人患有癌症，检测结果呈阳性
*   **蓝色**:这是指没有癌症且检测结果呈阳性的人
*   **白色**:指未患癌症且检测结果为阴性的人

因此，实际上，测试唯一准确的时间是在白色和紫色区域。在蓝色和粉色区域，测试是不正确的。

<title>Conditional probability</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 条件概率

让我们从这项对 100 人的研究中任意挑选一个人。让我们假设你被告知他们的测试结果是阳性的。他们真得癌症的概率有多大？所以，我们被告知事件 *B* 已经发生，他们的测试结果是阳性。现在的问题是:他们得癌症的概率是多少，也就是 *P(A)* ？这叫做给定 B 或 **P(A|B)** 的一个**条件概率。实际上，它是要求你在一个事件已经发生的情况下，计算另一个事件发生的概率。**

你可以把条件概率想象成改变相关的宇宙。 *P(A|B)* (称为概率 *A* 给定 *B* )是一种说法，给定我的整个宇宙现在是 *B* ，那么 *A* 的概率是多少？这也称为转换样本空间。

![Conditional probability](graphics/B05260_05_09.jpg)

放大我们之前的图，我们的宇宙现在是 B，我们关心的是 B 里面的 AB (A 和 B)

该公式可以给出如下:

*P(A|B) = P(A 和 B)/P(B)=(20/100)/(30/100)= 20/30 = . 66 = 66%*

如果检测结果呈阳性，这个人有 66%的几率患癌症。现实中，这是实验者想要的主要概率。他们想知道这项测试在预测癌症方面有多好。

<title>The rules of probability</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 概率的规则

在概率上，当可视化变得过于繁琐时，我们有一些非常有用的规则。这些规则帮助我们轻松计算复合概率。

## 加法法则

加法规则用于计算*非此即彼*事件的概率。为了计算 *P(A* ![The addition rule](graphics/chp5.jpg) *B) = P(A 或 B)* ，我们使用以下公式:

*P(A*![The addition rule](graphics/chp5.jpg)*B)= P(A)+P(B)—P(A∩B)*

公式的第一部分 *(P(A) + P(B))* 完全说得通。为了得到这两个事件的结合，我们必须把宇宙中圆的面积加在一起。但是为什么要减去 *P(A 和 B)* ？这是因为当我们添加两个圆时，我们添加了两次相交区域，如下图所示:

![The addition rule](graphics/B05260_05_10.jpg)

看到两个红圈是如何包含 **A** 和 **B** 的交集了吗？所以，当我们把它们相加时，我们只需要减去其中的一个，就可以得到我们的公式。

还记得我们想要癌症患者或检测结果呈阳性的人数吗？如果 *A* 是某人患了癌症，而 *B* 是检测结果呈阳性，我们就有:

*P(A 或 B)= P(A)+P(B)-P(A 和 B) = .25 + .30 - .2 = .35*

这是之前在图表中直观计算出来的。

## 互斥性

如果两个事件不能同时发生，我们说它们是互斥的。这意味着 *A∩B=* ![Mutual exclusivity](graphics/chp4.jpg)或者只是说事件的交集是空集。当这种情况发生时， *P(A∩B) = P(A 和 B) = 0* 。

如果两个事件互斥，则:

*P(A* ![Mutual exclusivity](graphics/chp5.jpg) * B) = P(A 或 B)= P(A)+P(B)—P(A∩B)= P(A)+P(B)*

这使得加法规则变得简单多了。互斥事件的一些示例包括:

*   一个顾客第一次在 Twitter 和脸书上看到你的网站
*   今天是星期六，今天是星期三
*   我经济 101 不及格，但我通过了经济 101

这些事件不可能同时发生。

## 乘法法则

乘法法则用于计算 *和*事件的概率。为了计算 *P(A ∩ B) = P(A 和 B)* ，我们使用以下公式:

*P(A ∩ B) = P(A 和 B) = P(A) P(B|A)*

为什么我们用 *B|A* 而不用 *B* ？这是因为有可能 *B* 依赖于 *A* 。如果是这样的话，那么仅仅将 *P(A)* 和 *P(B)* 相乘并不能给出全貌。

在我们的癌症试验例子中，让我们找到 *P(A 和 B)* 。为此，让我们将 *A* 重新定义为试验呈阳性的事件，将 *B* 重新定义为患有癌症的人(因为我们如何称呼这些事件并不重要)。该等式将如下所示:

*P(A ∩ B) = P(A 和 B)= P(A)P(B | A)= . 3 * . 6666 = . 2 = 20%*

这是之前目测的。

很难看出使用条件概率的真正必要性，所以，让我们试试另一个更难的问题。

例如，在随机选择的 10 个人中，6 个人有 iPhones，4 个人有机器人。如果我随机选择两个人，他们都有 iPhones 的概率是多少？这个例子可以使用事件空间来复述，如下所示:

我有以下两个事件:

*   *A* :这个事件显示了我首先选择一个有 iPhone 的人的概率
*   *B* :这个事件显示了我选择一个有 iPhone 秒的人的概率

所以，基本上，我想要以下的:

*   *P(A 和 B)* : *P(我选一个有 iPhone 的人和一个有 iPhone 的人)*

所以，我可以用我的 *P(A 和 B) = P(A) P(B|A)* 公式。

*P(A)* 简单吧？有 iPhones 的人 10 个里面有 6 个，所以，我有一个*6/10 = 3/5 = 0.6*A 的几率，这意味着 *P(A) = 0.6* 。

所以，如果我有 0.6 的几率选择一个有 iPhone 的人，那么选择两个的概率应该就是 *0.6 * 0.6* 了吧？

但是等等！我们只剩下 9 个人可以选择第二个人了，因为有一个人被带走了。因此，在我们新转换的样本空间中，我们总共有 9 个人，5 个有 iPhones，4 个有机器人，使得 *P(B) = 5/9 = .555* 。

所以，用 iPhones 选择两个人的概率是 *0.6 * 0.555 = 0.333 = 33%* 。

我有 1/3 的机会在 10 个人中选择 2 个有 iPhones 的人。条件概率在乘法法则中非常重要，因为它可以彻底改变你的答案。

## 独立

如果一个事件不影响另一个事件的结果，则两个事件是独立的，即 *P(B|A) = P(B)* 和 *P(A|B) = P(A)* 。

如果两个事件是独立的，那么:

*P(A∩B)= P(A)P(B | A)= P(A)P(B)*

独立事件的一些例子如下:

*   旧金山下雨了，一只小狗在印度出生了
*   抛一枚硬币，正面朝上；再抛一枚硬币，反面朝上

这些事件对之间没有一个是相互影响的。

## 互补事件

*A* 的补语是 *A* 的的反义词或否定。如果*A*是事件，![Complementary events](graphics/B05260_05_f5.jpg)代表 *A* 的补码。例如，如果 *A* 是某人患有癌症的事件，![Complementary events](graphics/B05260_05_f5.jpg)是某人未患癌症的事件。

要计算![Complementary events](graphics/B05260_05_f5.jpg)的概率，请使用以下公式:

*P(*![Complementary events](graphics/B05260_05_f5.jpg)*)= 1p(A)*

举个例子，当你掷出两个骰子，你掷出比一个 *3* 高的概率是多少？

设 *A* 代表滚动高于 a *3* 。

![Complementary events](graphics/B05260_05_f5.jpg)代表轧制一个 *3 个*或更少。

*P(A)= 1p(*![Complementary events](graphics/B05260_05_f5.jpg)*)*

*P(A)= l-(P(2)+P(3))*

*= 1-(2/36+2/36)*

*= 1-(4/36)*

*= 32/36 = 8 / 9*

*= .89*

例如，一个初创团队有三个投资者会议即将召开。我们将有以下概率:

*   第一次见面就有 60%的机会拿到钱
*   15%的机会从第二个
*   有 45%的机会从第三个人那里得到钱

他们至少从一次会议中拿到钱的概率有多大？

设 *A* 是从至少一个投资者那里获得资金的团队，![Complementary events](graphics/B05260_05_f5.jpg)是没有获得任何资金的团队。 *P(A)* 可计算如下:

*P(A)= 1p(*![Complementary events](graphics/B05260_05_f5.jpg)*)*

为了计算 *P(* ![Complementary events](graphics/B05260_05_f5.jpg) *)* ，我们需要计算如下:

*P(* ![Complementary events](graphics/B05260_05_f5.jpg) * ) * = * P(投资人 1 没钱，投资人 2 没钱，投资人 3 没钱)*

如果我们假设这些事件是独立的(它们彼此不对话)，那么:

*P(* ![Complementary events](graphics/B05260_05_f5.jpg) * ) = P(投资人 1 没钱)* P(投资人 2 没钱)* P(投资人 3 没钱)=*

*0.4 * 0.85 * 0.55 = 0.187*

*P(A) = 1 - 0.187 = 0.813 = 81%*

因此，创业公司有 81% 的机会从至少次会议中获得资金！

<title>A bit deeper</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 再深入一点

在不深入了解机器学习术语的情况下，这项测试是所谓的 **二元分类器**，这意味着它试图从仅有的两个选项中进行预测:患有癌症或没有癌症。当我们处理二进制分类器时，我们可以画出所谓的混淆矩阵，这是包含我们实验的所有四种可能结果的 2×2 矩阵。

让我们尝试一些不同的数字。假设有 165 个人走进了这项研究。所以，我们的 *n* (样本量)是 165 人。所有 165 人都接受了测试，并被问及是否患有癌症(通过各种其他方式提供)。下面的**混淆矩阵** 向我们展示了这个实验的结果:

![A bit deeper](graphics/B05260_05_f6.jpg)

矩阵显示 50 个人被预测没有癌症并且没有得，100 个人被预测有癌症并且实际上得了，等等。我们有以下四个类，同样，都有不同的名称:

*   **真阳性** 是正确预测*阳性(癌症)== 100* 的测试
*   **真阴性** 是正确预测*阴性(无癌症)== 50* 的测试
*   **假阳性** 是错误预测*阳性(癌症)== 10* 的测试
*   **假阴性** 是错误预测*阴性(无癌症)== 5* 的测试

前两个类表示测试是正确的还是正确的。最后两个类指出测试不正确或错误的地方。

假阳性有时被称为**I 型错误**，而假阴性被称为**II 型错误**。

![A bit deeper](graphics/B05260_05_11.jpg)

鸣谢:[http://marginal revolution . com/marginal revolution/2014/05/type-I-and-type-ii-errors-simplified . html](http://marginalrevolution.com/marginalrevolution/2014/05/type-i-and-type-ii-errors-simplified.html)

我们将在后面的章节中讨论这个问题。现在，我们只需要理解为什么我们使用集合符号来表示复合事件的概率。这是因为他们就是这样。当事件 A 和 B 存在于同一个宇宙中时，我们可以使用交集和并集来表示它们同时发生，或者表示一个事件相对于另一个事件发生。

我们将在后面的章节中更深入地探讨这一点，但最好现在就介绍一下。

<title>Summary</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 总结

在这一章，我们看了概率的基础知识，并将在下一章继续深入这个领域。我们以一个频繁主义者的身份对待我们的大部分思考，并表达了实验的基础和使用概率来预测结果。

下一章将着眼于概率的贝叶斯方法，也将探索使用概率来解决更复杂的问题。我们将在更困难的情况下结合这些基本的概率原理。