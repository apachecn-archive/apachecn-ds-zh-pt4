<title>Chapter 4. Basic Mathematics</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 第四章。基础数学

是时候开始研究一些在处理数据科学时很方便的基本数学原理了。数学这个词往往会让许多人感到恐惧，但我的目标是让它变得尽可能有趣。在本章中，我们将复习以下主题的基础知识:

*   基本符号/术语
*   对数/指数
*   集合论
*   结石
*   矩阵(线性)代数

我们也将涵盖数学的其他领域。此外，我们将看到如何将这些应用到数据科学的各个方面以及其他科学工作中。

回想一下，在上一章中，我们将数学确定为数据科学的三个关键组成部分之一。在这一章中，我将介绍在本书后面变得重要的概念——当看概率和统计模型时——我也将看在这一章中有用的概念。尽管如此，本章中的所有概念都应该被视为成为数据科学家的基础。

# 作为一门学科的数学

作为一门科学，数学是人类已知的最古老的逻辑思维形式之一。自古代美索不达米亚以来，很可能在此之前(公元前 3000 年)，人类一直依靠算术和更具挑战性的数学形式来回答生活中最大的问题。

今天，我们日常生活的大多数方面都依赖数学；是的，我知道这听起来很老套，但我是认真的。无论你是给植物浇水还是喂狗，你的内部数学引擎都在不停地旋转——计算植物在过去一周每天有多少水，并预测你的狗下一次饥饿的时间，因为它们现在正在进食。无论你是否有意识地运用数学原理，这些概念都深藏在每个人的大脑中。作为数学老师，我的工作就是让你意识到这一点。

<title>Basic symbols and terminology</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 基本符号和术语

首先，让我们看看数学过程中使用的最基本的符号，以及数据科学家使用的一些更微妙的符号。

## 向量和矩阵

一个**矢量**被定义为一个既有大小又有方向的物体。然而，这个定义对于我们的使用来说有点复杂。就我们的目的而言，向量只是一个表示一系列数字的一维数组。换句话说，向量是一列数字。

它通常用箭头或粗体表示，如下所示:

![Vectors and matrices](graphics/B05260_04_f1.jpg)

向量被分解成分量，分量是向量的单个成员。我们使用索引符号来表示我们引用的元素，如下所示:

如果![Vectors and matrices](graphics/B05260_04_f2.jpg)则![Vectors and matrices](graphics/B05260_04_f3.jpg)

### 注意

在数学中，我们通常将第一个元素称为索引`1`，而在计算机科学中，我们通常将第一个元素称为索引`0`。重要的是要记住你用的是什么指标体系。

在 Python 中，我们可以用多种方式表示数组。我们可以简单地使用 Python 列表来表示前面的数组:

```
x = [3, 6, 8]
```

然而，最好使用`numpy`数组类型来表示数组，如图所示，因为在执行向量运算时，它给了我们更多的实用工具:

```
import numpy as np
x = np.array([3, 6, 8])
```

不管 Python 的表示如何，向量为我们提供了一种简单的方法来存储单个数据点/观察的多维度*。*

假设我们对一家公司的三个部门的员工平均满意度评分(0-100)为:人力资源 *57* 、工程 *89* 和管理 *94* 。我们可以用下面的公式将其表示为一个矢量:

![Vectors and matrices](graphics/B05260_04_f4.jpg)

这个向量包含了我们数据的三个不同的信息。这是向量在数据科学中的完美应用。

你也可以认为向量是熊猫系列物体的理论概括。因此，自然地，我们需要一些东西来表示数据帧。

我们可以将数组的概念扩展到一维之外，用多维来表示数据。

矩阵是数字阵列的二维表示。矩阵(复数)有两个我们需要了解的主要特征。矩阵的维数，表示为 *n* x *m* ( *n 乘 m* ，告诉我们矩阵有 *n* 行和 *m* 列。矩阵通常用大写粗体字母表示，如 *X* 。考虑下面的例子:

![Vectors and matrices](graphics/B05260_04_f5.jpg)

这是一个 *3* x *2* ( *3 乘 2* )矩阵，因为它有三行两列。

### 注意

如果一个矩阵有相同数量的行和列，它被称为方阵**T2。**

这个矩阵是我们对熊猫数据框架的概括。它可以说是我们工具箱中最重要的数学对象之一。它用于保存有组织的信息，在我们的例子中，就是数据。

回到我们之前的例子，假设我们在不同的地方有三个办公室，每个办公室都有相同的三个部门:人力资源、工程和管理。我们可以创建三个不同的向量，每个向量包含不同的办公室满意度得分，如下所示:

![Vectors and matrices](graphics/B05260_04_f6.jpg)

然而，这不仅麻烦，而且不可扩展。如果你有 100 个不同的办公室呢？那么我们需要 100 个不同的一维数组来保存这些信息。

这就是矩阵缓解这个问题的地方。让我们制作一个矩阵，其中每行代表一个不同的部门，每列代表一个不同的办公室，如下所示:

![Vectors and matrices](graphics/B05260_04_f7.jpg)

这就自然多了。现在，让我们剥去标签，我们只剩下一个矩阵！

X = ![Vectors and matrices](graphics/B05260_04_f8.jpg)

### 快速练习

1.  如果我们增加第四个办公室，我们需要新的行或列吗？
2.  添加第四个办公室后，矩阵的维数会是多少？
3.  如果我们从原来的 *X* 矩阵中去掉管理部门，新矩阵的维数会是多少？
4.  知道矩阵中元素个数的一般公式是什么？

### 答案

1.  专栏。
2.  *3* x *4。*
3.  *2* x *3。*
4.  ![Answers](graphics/B05260_04_f9.jpg) ( *n* 为行数， *m* 为列数)。

## 算术符号

在这一节中，我们将回顾一些与基本算术相关的符号，这些符号出现在大多数(如果不是全部)数据科学教程和书籍中。

### 求和

大写 sigma ![Summation](graphics/B05260_04_f10.jpg)符号是加法的通用符号。无论 sigma 符号右边的是什么，通常都是可迭代的，这意味着我们可以一个接一个地查看它(例如，一个向量)。

例如，让我们创建一个矢量的表示:

```
X = [1, 2, 3, 4, 5]
```

要求这些内容的总和，我们可以用下面的公式:

![Summation](graphics/B05260_04_f11.jpg)

在 Python 中，我们可以使用以下公式:

```
sum(x) # == 15
```

比如计算一系列数的均值的公式就相当常见。如果我们有一个长度为 *n* 的向量( *x* ，向量的平均值可以计算如下:

![Summation](graphics/B05260_04_f12.jpg)

这意味着我们将将 *x* 的每个元素加起来，用![Summation](graphics/B05260_04_f13.jpg)表示，然后将总和乘以 *1/n* ，也称为除以 *n* ，即向量的长度。

### 成比例

小写字母符号表示彼此成比例的。这意味着当一个值改变时，另一个值也会改变。数值移动的方向取决于数值的比例。值可以直接或间接变化。如果值直接变化，它们都向同一个方向移动(一个值上升，另一个值也上升)。如果它们间接变化，它们向相反的方向运动(如果一个下降，另一个上升)。

考虑下面的例子:

*   一家公司的销售额与顾客数量成正比。这个可以写成![Proportional](graphics/B05260_04_f15.jpg)。
*   天然气价格(通常)间接随着石油的可获得性而变化，这意味着随着石油可获得性的下降(它更加稀缺)，天然气价格将会上涨。这可以表示为![Proportional](graphics/B05260_04_f16.jpg)。

稍后，我们将看到一个非常重要的公式叫做 **贝叶斯公式**，其中包含一个变异符号。

### 点积

点积是加法和乘法一样的运算符。用于合并两个向量，如图所示:

![Dot product](graphics/B05260_04_f18.jpg)

那么，这意味着什么呢？假设我们有一个向量，代表客户对三种电影类型的情感——喜剧、浪漫和动作。

### 注意

当使用点积时，注意答案是一个单一的数字，称为 **标量**。

考虑一下，在 1-5 的范围内，客户喜欢喜剧，讨厌浪漫电影，喜欢动作片。我们可以这样表示:

![Dot product](graphics/B05260_04_f19.jpg)

这里:

*   代表对喜剧的热爱，
*   *1* 是对浪漫的憎恨
*   *3* 是行动的冷漠

现在，假设我们有两部新电影，一部是爱情喜剧，另一部是搞笑动作片。电影会有自己的质量向量，如下所示:

![Dot product](graphics/B05260_04_f20.jpg)和![Dot product](graphics/B05260_04_f21.jpg)

在这里，![Dot product](graphics/B05260_04_f22.jpg)是我们的浪漫喜剧，![Dot product](graphics/B05260_04_f23.jpg)是我们的搞笑动作片。

为了做出推荐，我们将*应用*客户对每部电影的偏好之间的点积。较高的值将胜出，因此将被推荐给用户。

让我们计算每部电影的推荐分数。对于电影 *1* ，我们想要计算:

![Dot product](graphics/B05260_04_f24.jpg)

我们可以这样想这个问题:

![Dot product](graphics/B05260_04_f25.jpg)

我们得到的答案是 *28* ，但是这个数字意味着什么呢？规模有多大？嗯，任何人能得到的最好的分数是当所有的值都是 *5* 时，结果如下:

![Dot product](graphics/B05260_04_f26.jpg)

当所有值都是 *1* 时，可能的最低分是，如图所示:

![Dot product](graphics/B05260_04_f27.jpg)

所以，我们必须从 *3* - *75* 的尺度上来思考 *28* 。为此，想象一条从 *3* 到 *75* 的数字线，以及 *28* 将位于其上的位置。这一点说明如下:

![Dot product](graphics/B05260_04_f28.jpg)

没那么远。让我们试试电影 *2* :

![Dot product](graphics/B05260_04_f29.jpg)

这个比 *28* 高！将这个数字放在与之前相同的时间线上，我们也可以直观地观察到这是一个好得多的分数，如下所示:

![Dot product](graphics/B05260_04_f30.jpg)

所以，在电影 *1* 和电影 *2* 之间，我们一定会向我们的用户推荐电影 *2* 。本质上，这就是大多数电影预测引擎的工作方式。他们建立了一个客户档案，用向量表示。然后，他们用向量表示他们必须提供的每部电影，将它们与客户资料(可能是点产品)结合起来，并从那里提出建议。当然，大多数公司必须在更大的范围内这样做，这是一个被称为**线性代数** 的特定数学领域非常有用的地方；我们将在本章的后面讨论它。

## 图表

毫无疑问，到目前为止，在你的生活中，你已经遇到了几十张，如果不是几百张的话。我想主要谈谈关于图形和符号的约定。

![Graphs](graphics/B05260_04_f31.jpg)

这是一个基本的 **笛卡尔图** ( *x* 和 *y* 坐标)。 *x* 和 *y* 符号非常标准，但有时并不能完全解释全局。我们有时称 *x* 变量为自变量，称 *y* 为因变量。这是因为当我们写函数时，我们倾向于把它们说成是 *y 是 x 的函数，*意味着 *y* 的值依赖于 *x* 的值。这就是图表试图展示的内容。

假设我们在图上有两个点，如下所示:

![Graphs](graphics/B05260_04_f32.jpg)

我们将这些点称为![Graphs](graphics/B05260_04_f33.jpg)和![Graphs](graphics/B05260_04_f34.jpg)。

这两点之间的**斜率** 定义如下:

![Graphs](graphics/B05260_04_f35.jpg)

你可能以前见过这个公式，但如果不是因为它的重要性，它还是值得一提的。斜率定义了两点之间的变化率。变化率在数据科学中非常重要，特别是在涉及微分方程和微积分的领域。

变化率是表示变量如何一起移动以及移动到什么程度的一种方式。考虑一下，我们是在模拟你的咖啡的温度与它静置的时间的关系。也许我们有如下的变化率:

![Graphs](graphics/B05260_04_f36.jpg)

这种变化率告诉我们，每一分钟，我们的咖啡温度下降 2 华氏度。

在本书的后面，我们将参观一种机器学习算法，叫做线性回归。在线性回归中，我们关注变量之间的变化率，因为它们允许我们利用这种关系进行预测。

### 注意

把笛卡尔平面想象成一个有两个元素的向量的无限平面。当人们提到更高维度时，比如 3D 或 4D，他们仅仅是指拥有更多元素的向量的无限空间。3D 空间保存长度为 3 的向量，而 7D 空间保存其中有 7 个元素的向量。

## 对数/指数

一个**指数** 告诉你一个数要乘以多少次，如图所示:

![Logarithms/exponents](graphics/B05260_04_f37.jpg)

一个**对数** 是回答这个问题的数字:“什么指数让我从底到另一个数字？”这可以表示如下:

![Logarithms/exponents](graphics/B05260_04_f38.jpg)

如果这两个概念看起来差不多，那你就对了！指数和对数密切相关。其实指数和对数这两个词其实是一个意思！对数是指数。前面两个方程其实是同一个东西的两个版本。基本思想是 2 乘 2 乘 2 乘 2 等于 16。

以下是我们如何使用两个版本来表达同一件事情的描述。请注意我是如何使用箭头从对数公式转移到指数公式的:

![Logarithms/exponents](graphics/B05260_04_f39.jpg)

考虑下面的例子:

*   ![Logarithms/exponents](graphics/B05260_04_f40.jpg)因为![Logarithms/exponents](graphics/B05260_04_f41.jpg)
*   ![Logarithms/exponents](graphics/B05260_04_f42.jpg)因为![Logarithms/exponents](graphics/B05260_04_f43.jpg)

请注意，如果我们将第一个等式改写为:

![Logarithms/exponents](graphics/B05260_04_f44.jpg)

然后我们用等价的语句 34 代替 81，如下所示:

![Logarithms/exponents](graphics/B05260_04_f45.jpg)

我们可以注意到一些有趣的事情:3 似乎抵消了 T1。这在处理比 3 和 4 更难处理的数字时非常重要。

在处理增长时，指数和对数是最重要的。通常，如果某个数量在增长(或在增长中下降)，指数/对数可以帮助建模这种行为。

比如数 *e* 在 2.718 左右，有很多实际应用。一个非常常见的应用是货币的增长计算。假设您有 5000 美元存在银行，复利持续为 3%，那么我们可以使用以下公式来模拟我们的存款增长:

![Logarithms/exponents](graphics/B05260_04_f46.jpg)

其中:

*   *A* 表示最终金额
*   *P* 表示本金投资( *5000*
*   *e* 表示常数( *2.718* )
*   *r* 表示增长率( *.03*
*   表示时间(以年为单位)

我们很好奇，我们的投资什么时候能翻倍？我需要在这项投资中投入多长时间才能实现 100%的增长？基本上:

![Logarithms/exponents](graphics/B05260_04_f47.jpg)

是我们想要求解的公式:

![Logarithms/exponents](graphics/B05260_04_f47.jpg)![Logarithms/exponents](graphics/B05260_04_f48.jpg)

此时，我们需要求解指数中的一个变量。当这种情况发生时，我们可以使用对数符号来计算！

![Logarithms/exponents](graphics/B05260_04_f49.jpg)

这给我们留下了![Logarithms/exponents](graphics/B05260_04_f50.jpg)。

当我们对一个以 *e* 为底的数取对数时，我们称之为*自然对数*。我们将对数改写如下:

![Logarithms/exponents](graphics/B05260_04_f51.jpg)

使用计算器(或者 Python)，我们发现 *ln(2) = 0.69* 。

![Logarithms/exponents](graphics/B05260_04_f52.jpg)![Logarithms/exponents](graphics/B05260_04_f53.jpg)

这意味着我们的钱翻一番需要 2.31 年。

## 集合论

集合论涉及集合层次上的数学运算。有时它被认为是支配数学其余部分的一组基本定理。为了我们的目的，我们使用集合论来操纵元素组。

一个**集合** 是不同对象的集合。

就是这样！在 Python 中，集合可以被认为是一个列表，但是没有重复的对象。事实上，Python 中甚至存在一组对象:

```
s = set()

s = set([1, 2, 2, 3, 2, 1, 2, 2, 3, 2])
# will remove duplicates from a list

s == {1, 2, 3}

```

### 注意

注意，在 Python 中，花括号— `{`、`}`—可以表示集合或字典。

请记住，Python 中的字典是一组键值对，例如:

```
dict = {"dog": "human's best friend", "cat": "destroyer of world"}
dict["dog"]# == "human's best friend"
len(dict["cat"]) # == 18

# but if we try to create a pair with the same key as an existing key
dict["dog"] = "Arf"

dict
{"dog": "Arf", "cat": "destroyer of world"}
# It will override the previous value
# dictionaries cannot have two values for one key.
```

它们共享这种符号，因为它们共享一个特性，即集合不能有重复的元素，就像字典不能有重复的键一样。

集合的**量级** 是集合中元素的个数，表示如下:

![Set theory](graphics/B05260_04_f54.jpg)

```
s  # == {1,2,3}
len(s) == 3 # magnitude of s
```

### 注意

空集的概念是存在的，并用字符![Set theory](graphics/chp4.jpg)表示。据说这个空集的大小为 0。

如果我们希望表示一个元素在一个集合中，我们使用ε符号，如下所示:

![Set theory](graphics/B05260_04_f56..jpg)

这意味着元素 *2* 存在于 *1* 、 *2* 和 *3* 的集合中。如果一个集合完全在另一个集合内，我们说它是其更大的对应集合的子集。

![Set theory](graphics/B05260_04_f57.jpg)![Set theory](graphics/B05260_04_f58.jpg)

所以， *A* 是 *B* 的子集， *B* 被称为 *A* 的超集。如果 *A* 是 *B* 的子集，但是 *A* 不等于 *B* (意味着 *B* 中至少有一个元素不在 *A* 中)，那么 *A* 称为 *B* 的真子集。

考虑下面的例子:

*   一组偶数是所有整数的子集
*   每个集合都是其自身的子集，但不是真子集
*   所有推文的集合是英语推文的超集

在数据科学中，我们使用集合(和列表)来表示对象的列表，并且通常来概括消费者的行为。将客户简化为一组特征是很常见的。

假设我们是一家营销公司，试图预测一个人想去哪里买衣服。我们得到一组用户以前访问过的服装品牌，我们的目标是预测他们也会喜欢的新店。假设特定用户以前在以下商店购物:

```
user1 = {"Target","Banana Republic","Old Navy"} 
# note that we use {} notation to create a set
# compare that to using [] to make a list
```

因此，`user1`之前曾在`Target`、`Banana Republic`和`Old Navy`购物。让我们来看看另一个用户，叫做`user2`，如图所示:

```
user2 = {"Banana Republic","Gap","Kohl's"}
```

假设我们想知道这些用户有多相似。根据我们掌握的有限信息，定义相似性的一种方法是查看他们都在多少家商店购物。这叫交集。

两个集合的**交** 是其元素同时出现在两个集合中的集合。用符号![Set theory](graphics/B05260_04_f59.jpg)表示，如图所示:

![Set theory](graphics/B05260_04_f60.jpg)![Set theory](graphics/B05260_04_f61.jpg)

两个用户的交集只是一家店。所以，现在这看起来不太好。然而，每个用户在他们的集合中只有三个元素，所以拥有 1/3 似乎并不坏。假设我们很好奇他们两个之间代表了多少家店；这就是所谓的联盟。

两个集合的**并** 是其元素出现在任一集合中的集合。用符号![Set theory](graphics/B05260_04_f62.jpg)表示，如图所示:

![Set theory](graphics/B05260_04_f63.jpg)![Set theory](graphics/B05260_04_f64.jpg)

在查看*用户 1* 和*用户 2* 之间的相似性时，我们应该使用它们集合的并集和交集的组合。*用户 1* 和*用户 2* 在他们之间总共五个不同的元素中有一个元素是相同的。因此，我们可以将两个用户之间的相似性定义如下:

![Set theory](graphics/B05260_04_f65.jpg)

事实上，这在集合论中是有名字的。它被称为 **jaccard 测量**。通常，对于集合 *A* 和 *B* ，两个集合之间的 jaccard 度量(jaccard 相似性)定义如下:

![Set theory](graphics/B05260_04_f66.jpg)

它也可以定义为两个集合的交集的大小除以两个集合的并集的大小。

这给了我们一种方法来量化用集合表示的元素之间的相似性。

直观地，jaccard 度量是 0 和 1 之间的数，使得当该数越接近 0 时，人们越不相似，而当该度量越接近 1 时，人们被认为彼此相似。

如果我们思考一下定义，那么它实际上是有意义的。再看一下测量结果:

![Set theory](graphics/B05260_04_f67.jpg)

这里，分子表示用户共有的商店的数量(在某种意义上，他们喜欢在那里购物)，而分母表示他们喜欢放在一起的商店的唯一数量。

我们可以使用一些简单的代码在 Python 中表示这一点，如下所示:

```
user1 = {"Target","Banana Republic","Old Navy"} 
user2 = {"Banana Republic","Gap","Kohl's"}

def jaccard(user1, user2):
  stores_in_common = len(user1 & user2)
  stores_all_together = len(user1 | user2)
  return stores / float(stores_all_together)

# I cast stores_all_together as a float to return a decimal answer instead of python's default integer division

# so
jaccard(user1, user2) == # 0.2 or 1/5
```

当我们进入概率世界以及处理高维数据时，集合论变得非常普遍。我们将使用集合来表示现实世界中正在发生的事件，概率成为集合理论，词汇在其上。

<title>Linear algebra</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 线性代数

还记得我们之前看的电影推荐引擎吗？如果我们有 10，000 部电影可以推荐，而我们只能选择 10 部给用户，那会怎么样？我们必须在用户档案和 10，000 部电影之间做点积。线性代数提供了使这些计算更有效的工具。

它是数学的一个领域，研究矩阵和向量的数学。它的目的是分解这些对象并重新构建它们，以便提供实际应用。在继续之前，让我们看一些线性代数规则。

## 矩阵乘法

像数字一样，我们可以将多个矩阵在一起。从本质上讲，矩阵相乘是一种一次获得多个点积的大规模生产方式。例如，让我们尝试将下列矩阵相乘:

![Matrix multiplication](graphics/B05260_04_f68.jpg)

有几件事:

*   与数字不同，乘法不是*可交换的*，这意味着矩阵相乘的顺序非常重要。
*   为了乘矩阵，它们的维数必须匹配。这意味着第一个矩阵的列数必须与第二个矩阵的行数相同。

为了记住这一点，写出矩阵的维数。在这种情况下，我们有一个 *3* x *2* 乘以一个 *2* x *2* 的矩阵。如果第一个维度对中的第二个数字与第二个维度对中的第一个数字相同，则可以将多个矩阵放在一起。

![Matrix multiplication](graphics/B05260_04_f69.jpg)

生成的矩阵的尺寸将始终等于尺寸对(第二点中未圈出的尺寸)中的外部数字。在这种情况下，得到的矩阵将具有尺寸 *3* x *2* 。

### 如何乘矩阵

要乘矩阵，这里的实际上是一个相当简单的程序。本质上，我们正在执行一堆点积。

回想一下我们之前的示例问题，如下所示:

![How to multiply matrices](graphics/B05260_04_f68.jpg)

我们知道我们得到的矩阵将有一个维度 *3* x *2* 。因此，我们知道它看起来会像下面这样:

![How to multiply matrices](graphics/B05260_04_f70.jpg)

### 注意

请注意，矩阵的每个元素都使用双重索引进行索引。第一个数字表示行，第二个数字表示列。因此，元素![How to multiply matrices](graphics/B05260_04_f71.jpg)是第三行第二列的元素。每个元素都是原始矩阵的行和列之间的点积的结果。

![How to multiply matrices](graphics/B05260_04_f72.jpg)元素是第一个矩阵的第 x ^行和第二个矩阵的第 y ^列的点积结果。先解决几个:

![How to multiply matrices](graphics/B05260_04_f73.jpg)![How to multiply matrices](graphics/B05260_04_f74.jpg)

继续，我们最终将得到如下结果矩阵:

![How to multiply matrices](graphics/B05260_04_f75.jpg)

好样的。让我们回到电影推荐的例子。回想一下用户对喜剧、爱情和动作的电影类型偏好，如下所示:

![How to multiply matrices](graphics/B05260_04_f76.jpg)

现在假设我们有 10，000 部电影，都有这三个类别的分级。为了进行推荐，我们需要对 10，000 部电影中的每一部进行偏好向量的点积。我们可以用矩阵乘法来表示这个。

让我们用矩阵符号来表达它，而不是把它们都写出来。我们已经有了 *U* ，这里定义为用户的偏好向量(也可以认为是一个 *3* x *1* 矩阵)，我们还需要一个电影矩阵:

![How to multiply matrices](graphics/B05260_04_f77.jpg)维度矩阵。

所以，现在我们有两个矩阵，一个是 *3* x *1* 一个是*3*x*10000*。我们不能把这些矩阵相乘，因为维数计算不出来。我们将不得不稍微改变一下。我们可以取矩阵的*转置*(把所有行变成列，列变成行)。这将改变尺寸:

![How to multiply matrices](graphics/B05260_04_f78.jpg)

现在我们有两个可以相乘的矩阵。想象一下这是什么样子:

![How to multiply matrices](graphics/B05260_04_f79.jpg)

得到的矩阵将是一个 *1* x *1，000* 矩阵(一个向量),包含每部电影的 10，000 个预测。让我们用 Python 来试试吧！

```
import numpy as np

# create user preferences
user_pref = np.array([5, 1, 3])

# create a random movie matrix of 10,000 movies
movies = np.random.randint(5,size=(3,1000))+1

# Note that the randint will make random integers from 0-4
# so I added a 1 at the end to increase the scale from 1-5
```

我们使用`numpy`数组函数来创建矩阵。我们将有一个`user_pref`和一个`movies`矩阵来表示我们的数据。

为了检查我们的尺寸，我们可以使用`numpy` `shape`变量，如图所示:

```
print user_pref.shape # (1, 3)

print movies.shape    # (3, 1000)
```

这证实了。最后，让我们使用`numpy`(称为点)的矩阵乘法方法来执行运算，如图所示:

```
# np.dot does both dot products and matrix multiplication
np.dot(user_pref, movies) 
```

结果是一个整数数组，表示每部电影的推荐。

为了快速扩展，让我们运行一些代码来预测超过 10，000 部电影，如下所示:

```
import time

for num_movies in (10000, 100000, 1000000, 10000000, 100000000):
    movies = np.random.randint(5,size=(3, movies))+1
    now = time.time()
    np.dot(user_pref, movies)
    print (time.time() - now), "seconds to run", movies, "movies"

0.000160932540894 seconds to run 10000 movies
0.00121188163757 seconds to run 100000 movies
0.0105860233307 seconds to run 1000000 movies
0.096577167511 seconds to run 10000000 movies
4.16197991371 seconds to run 100000000 movies
```

使用矩阵乘法仅用了 4 秒多一点的时间就浏览了 100，000，000 部电影。

<title>Summary</title>   <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 总结

在这一章中，我们看了一些基本的数学原理，这些原理在我们阅读这本书的过程中会变得非常重要。在对数/指数、矩阵代数和比例之间，数学显然不仅在数据分析中，而且在我们生活的许多方面都有重要作用。

接下来的章节将会深入数学的两大领域:概率和统计。定义和解释这两大数学领域中最小和最大的定理将成为我们的目标。

在接下来的几章中，一切都将开始变得明朗起来。到目前为止，在本书中，我们已经看了数学示例、数据探索指南和对数据类型的基本见解。是时候开始将所有这些概念联系在一起了。