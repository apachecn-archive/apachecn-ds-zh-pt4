

# 第九章。时间序列

演示和执行决策建模和检查的能力是一些现实世界应用的重要组成部分，从重症监护室的紧急医疗处理到军事指挥和控制框架。现有的演绎方法和技术在决策质量和计算易处理性之间的交换是必不可少的应用中还不太可行。处理时间关键元素决策建模的成功方法应该明确支持瞬态过程的演示，并用于管理时间关键的情况。

在本章中，我们将介绍:

*   什么是预测？
*   决策过程
*   什么是时间序列？
*   模型的类型
*   趋势分析
*   季节性分析
*   ARIMA
*   缓和

# 什么是预测？

让我们以一个组织为例，该组织需要找出近期对其库存的需求，以最大化投资回报。

例如，许多股票框架适用于不确定的需求。这些框架中的库存参数需要评估需求和预测误差分布。

这些框架的两个阶段，预测和库存控制，经常被自动分析。理解需求估计和库存控制之间的合作是很重要的，因为这影响到库存框架的执行。

预测要求包括:

*   每一项决策迟早都会付诸实施，因此它应该基于对未来状况的预测。
*   整个组织都需要数字，而这些数字绝对不应该是由预测者不相关的聚会创造出来的。
*   预测从来都不是“包起来”的。预测是经常需要的，随着时间的推移，预测对实际执行的影响被测量，最初的预测被修改，决策被调整，这是一个循环。

决策者利用预测模型来执行决策。他们经常被用来演示反思性地研究各种策略的效果的过程。

将决策的组成部分分成三组是有帮助的:

*   无法管束的
*   可控制的
*   资源(定义问题情况)

## 决策过程

什么是系统？框架是由以特定方式设置在一起的部分组成的，记住最终目标是满足特定的目标。各部分之间的关系决定了框架的功能及其整体能力。按照这些思路，框架中的连接通常比单个部分更重要。当所有的事情都完成了，作为不同框架的构建模块的框架被称为子系统。

### 系统的动力学

不变的框架是静态的框架。业务框架的很大一部分是快速框架，这意味着它们的状态会在一段时间后改变。我们把一个框架在一段时间后改变的方式称为框架的行为。此外，当框架的改进采用典型模式时，我们说框架具有行为模式。一个框架是静态的还是动态的取决于它如何随时间变化。

决策过程包括以下几个部分:

*   **Performance measure (or indicator)**: The development of powerful measures is seen as important in every organization. Performance measures give the desirable levels of results, that is, the target of your choice. The goal is essential in recognizing the anticipating action:

    *   **战略**:投资回报、增长和创新
    *   **战术**:成本、数量和客户满意度
    *   **运行**:目标设定和符合标准

*   **资源**:资源是在预测的时间范围内不发生变化的一致成分。资源是描述决策问题的变量。战略决策通常比战术和作战选择有更长的时间跨度。
*   **预测**:预测信息来源于决策者所处的环境。必须确定或预测不可控的输入。
*   决策:决策输入是所有可能的方法的集合。
*   **相互作用**:前面决策部分之间的关联是逻辑的、科学的功能，代表输入、资源、预测和结果之间的环境和最终结果的联系。当决策的结果依赖于策略时，我们改变风险环境的一个或多个部分，目的是在其他部分实现有吸引力的改变。如果我们知道问题各部分之间的联系，我们就成功了。
*   **行动**:决策包括决策者选择的策略。我们的策略影响选择结果的方式取决于预测和不同的输入是如何相互关联的，以及它们如何认同结果。



# 什么是时间序列？

时间序列是洞察的排列，通常以标准间隔收集。时间序列信息通常出现在许多应用中:

*   **经济**:例如，失业、住院等月度数据
*   **金融**:比如每日汇率，a 股价格等等
*   **环境**:例如，每日降雨量、空气质量读数等等
*   **医学**:比如每 2 到 8 秒钟做一次心电图脑电波活动

时间序列调查的技术早于一般随机过程和马尔可夫链的技术。时间序列分析的目标是描绘和概述时间序列数据，拟合低维模型，并做出理想的预测。

## 趋势、季节性、周期和残差

描述一个系列的一个直接的策略是经典解体。这个想法是，该安排可以分为四个组成部分:

*   **趋势(Tt)** :均值的长期变动
*   **季节效应(It)** :与日历相关的周期性波动
*   **周期(Ct)** :其他周期性波动(如商业周期)
*   **残差(Et)** :其他随机或系统波动

想法是为这四个元素创建单独的模型，然后将它们组合起来:

*   **相加** : *Xt = Tt + It + Ct + Et*
*   **乘上** : *Xt = Tt It Ct Et*

### 与标准线性回归的差异

信息不是无情地独立的，当然也不是不加区别地分布的。时间序列的一个特点是，它是一个观察的纲要，其中排序很重要。顺序是必不可少的，因为存在依赖性，改变顺序会改变信息的重要性。

### 分析的基本目标

基本目标通常是确定描述时间序列模式的模型。这种模型的用途是:

*   描述时间序列模式的重要特征
*   解释过去如何影响未来，或者两个时间序列如何“相互作用”
*   预测序列的未来值
*   在某些生产情况下，作为衡量产品质量的变量的控制标准

### 型号的种类

“时域”模型有两种基本类型:

*   Ordinary regression models that use time indices as x-variables:

    *   有助于数据的初始描述，并形成几种简单预测方法的基础

*   ARIMA models (for Autoregressive Integrated Moving Average):

    *   将序列的当前值与过去值和过去预测误差相关联的模型

### 首先要考虑的重要特征

查看时间序列时首先要考虑的一些重要问题是:

*   Is there a trend?

    *   测量值随时间增加或减少的模式。

*   The effect of seasonality?

    *   与日历时间(如季节、季度、月份、星期几等)相关的高点和低点是否有规律的重复模式？

*   Are there any outliers?

    *   在回归中，异常值与趋势线有一段距离。对于时间序列数据，异常值与其他数据有一段距离。

*   是否存在与季节性因素无关的时期？
*   在一段确定的时间内有恒定的方差吗？
*   双方是否有任何突然的变化？

下图是一段时间内随机数的示例。通过时间序列图，我们简单地意味着变量是相对于时间绘制的。对于随时间推移的心跳、市场波动、地震图等等，也可以做出类似的图。

![Important characteristics to consider first](graphics/image_09_001.jpg)

该地块的一些特征包括:

*   在整个时间跨度内没有一致的趋势(上升或下降)。该系列似乎在缓慢地上下浮动。
*   有一些明显的异常值。
*   很难判断方差是否是常数。

### 系统模式和随机噪声

正如在大多数不同的分析中一样，在时间序列分析中，人们接受信息由系统模式(作为可识别片段的集合排列)和随机噪声(误差)组成，这通常使模式难以识别。大多数情况下，系列分析系统包括某种类型的噪音过滤，牢记最终目标是使模式更容易识别。

### 时间序列模式的两个一般方面

大多数情况下，系列模式可以描述为两个基本的细分类别:

*   模式
*   规则性

一个模式通常是一个直的或(有规律的)非线性的部分，它在一段时间后发展，并且在我们的数据捕捉到的时间范围内(可能)不会重复。

规律性可能具有形式上相似的性质；无论如何，在一段时间后，它会以系统的间隔进行自我更新。这两大类时间序列成分可能在实际生活数据中共存。

例如，一个组织的报价可以在几年内快速增长，但它们仍然遵循可预测的季节性模式(例如，每年多达 30%的年度交易是在 10 月份进行的，而只有 10%是在 3 月份进行的)。

## 趋势分析

没有演示的“编程”系统来区分时间序列数据中的模式段。在任何情况下，模式的长度是重复的(以一致的方式增加或减少),并且数据分析的某些部分通常不是非常困难。在时间序列信息包含相当大的误差的情况下，那么初始阶段期间所花费的时间模式区分证明是平滑的。

### 平滑

平滑可靠地包括某种类型的数据邻域平均，使得个体感知的非系统部分相互抵消。最广泛认可的方法是移动法线平滑。这用 n 个包含分量的简单或加权法线替换了序列的每个分量，其中 n 是平滑“窗口”的宽度。

可以利用中间值，而不是手段。以下是中间值的一些优点:

*   在平滑窗口内，其结果受异常值的影响较小
*   如果数据中有异常值，考虑到相同的窗口宽度，中间平滑通常比移动法线提供更平滑或更“可靠”的曲线

中间平滑的基本缺点是，如果没有明显的异常值，它可能会比移动法线提供更多的锯齿状曲线，并且它没有考虑权重。

### 拟合函数

大量单调的时间序列信息可以用一个线性函数来满意地近似。如果存在合理的单调非线性部分，最初应该改变数据以消除非线性。通常可以使用对数、指数或(不太常见的)多项式函数。

## 季节性分析

季节相关性(季节性)是时间序列设计的另一个一般部分。例如，如果我们看到购买趋势的时间序列图，我们可以看到每年 10 月底和 12 月期间有一个巨大的峰值。这种模式每年都在重复。

### 自相关相关图

时间序列的季节性模式可以通过相关图来分析。相关图以图形和数字方式显示了**自相关函数(ACF)，**，它们是预定滞后范围内连续滞后的序列关系系数(及其标准误差)。

在相关图中，每个滞后的两个标准误差的范围通常是分开的，但通常自相关的大小比其可靠性更令人感兴趣。

以下是`mtcars`数据集的相关图:

![Autocorrelation correlogram](graphics/image_09_002.jpg)

#### 检查相关图

在研究相关图时，我们必须记住连续滞后的自相关是形式相关的。例如，如果主要成分与第二成分紧密相关，第二成分与第三成分紧密相关，那么主要成分在某种程度上也应该与第三成分相关，依此类推。

### 部分自相关

检查序列相关性的另一个有用策略是查看**部分自相关能力**(**【PACF】**)，这是自相关的一种扩展，其中消除了对中间成分(滞后内的成分)的依赖性。

### 删除串行相关性

对于 k 的特定滞后的序列相关性可以通过差分序列来消除，也就是说，将序列的每个第 *i* 分量转换为其与第 *(i-k)* 分量的差。

这种变化背后有两种解释:

*   在这一系列中可以看出隐藏的季节依赖性
*   ARIMA 和其他程序要求我们使序列平稳，这本身就要求去除季节依赖性

## ARIMA

我们讨论了时间序列分析过程的数值模拟。在现实生活中，模式不是那么清晰，观察结果通常有相当大的误差。

要求是:

*   寻找隐藏的模式
*   生成预测

现在让我们了解一下 ARIMA，以及它如何帮助我们获得这些。

### 常见流程

*   Autoregressive procedure:

    *   大多数时间序列由连续相关的部分组成，例如，您可以评估一个系数或系数的排列，这些系数从特定的、时间滞后的(过去的)部分描述序列的连续部分。
    *   静态先决条件。自回归过程仅在参数落入的某个参数范围内是稳定的。先前的效应会堆积起来并影响连续的点，并且序列可能不是静止的。

*   移动正常程序。独立于自回归过程，序列中的每个分量同样会受到不能由自回归分量表示的过去误差(或任意冲击)的影响。
*   Invertibility necessity. There is a "duality" between the moving normal procedure and the autoregressive procedure:

    *   移动正态方程可以转化为自回归结构。在任何情况下，与上面描述的静态条件没有区别，如果移动的正态参数发生在特定条件之后，也就是说，如果模型是可逆的，就必须这样做。此外，该系列不会一成不变。

### ARIMA 方法论

自回归移动平均模型。

Box 和 Jenkins (1976 年)提出的一般模型包含自回归，此外，移动正态参数和明确地包含模型细节中的差异。

特别是，模型中的三种参数是:

*   自回归参数(p)
*   差异传递的数量(d)
*   移动正常参数(q)

在由 Box 和 Jenkins 提出的文件中，模型被简化为 ARIMA (p，d，q)。

#### 识别

ARIMA 的输入序列应该是平稳的。它必须有一个稳定的平均值、差值和自相关值。随后，在大多数情况下，首先应该对序列进行差分，直到它稳定为止(同样，这通常需要对数改变数据，以使方差稳定)。

“d”参数反映了为实现平稳性而对序列进行差分的次数。为了确定差分的基本水平，我们需要查看数据和自相关图。

显著的水位变化(稳定的上升或下降变化)通常需要一阶非季节性(滞后=1)差分:

*   倾斜度的实际变化通常需要二阶非季节性差分

#### 估计和预测

下一步是估算。这里，参数被评估(利用函数最小化系统),使得残差平方和最小化。参数评估被用作最后阶段(预测)的一部分，以计算序列的新估计值(已并入输入数据集中)和这些预测值的置信区间。

在产生预测数字之前，对改变的(差异的)信息执行估计程序。要求该系列应是综合的，以便用与输入数据兼容的值来传达预测。

#### ARIMA 模型中的常数

利用标准的自回归和移动正态参数，ARIMA 模型同样可以包含一个常数。该常数的表示取决于拟合的模型:

*   如果模型中不存在自回归参数，那么序列的平均值就是常数的期望值
*   如果模型中存在自回归参数，则截距由常数表示

#### 识别阶段

在评估开始之前，我们必须确定(区分)要评估的 ARIMA 参数的具体数量和种类。作为 ID 阶段一部分的重要工具有:

*   安排的情节
*   自相关相关图
*   部分自相关(PACF)

选择不是直接的，在不太典型的情况下，需要经验以及对期权模型的合理实验安排(以及 ARIMA 的特殊参数)。

在任何情况下，大量的实验时间序列模式可以充分近似利用五个基本模型之一。这些模型基于**自相关图** ( **ACF** )和**部分自相关图** ( **PACF** )的形状:

*   One autoregressive parameter (p):

    *   ACF:指数衰减
    *   PACF:在第一阶段扣球
    *   其他滞后无相关性

*   Two autoregressive parameters (p):

    *   ACF:正弦波形模式或一组指数衰减
    *   PACF:滞后 1 和滞后 2 的峰值
    *   其他滞后无相关性

*   One moving average parameter (q):

    *   ACF:滞后 1 时的峰值
    *   其他滞后无相关性
    *   PACF:指数衰减

*   Two moving average parameters (q):

    *   ACF:滞后 1 和滞后 2 处的尖峰
    *   其他滞后无相关性
    *   PACF:正弦波形模式或一组指数衰减

*   One autoregressive (p) and one moving average (q) parameter:

    *   ACF:从滞后 1 开始指数衰减
    *   PACF:指数衰减从滞后 1 开始

#### 季节性模型

模式随时间季节性重复的序列需要特殊的模型。

这类似于季节性模型中的简单 ARIMA 参数:

*   季节性自回归
*   季节差异
*   季节性移动正态参数

例如，让我们以模型(0，1，2)(0，1，1)为例。

该图描述了一个模型，其中包含:

*   没有自回归参数
*   两个通用移动法线参数
*   一个正则移动正态参数

用于季节参数的季节滞后通常在识别证明阶段确定，并应明确指出。

关于待评估参数选择的一般建议(考虑 ACF 和 PACF)同样适用于季节性模型。主要区别在于，在季节性序列中，ACF 和 PACF 将在季节性滞后的产品上显示相当大的系数。

### 参数估计

评估参数有几种不同的技术。他们中的每一个人都应该从根本上交付相同的估计，但是对于任何给定的模型都可能非常精通。通常，在参数估计阶段，利用函数最小化计算来最大化给定参数值的被观看系列的概率(似然性)。

这需要在给定单独参数的情况下，计算残差平方(SS)的(条件)集合。

实际上，在给定相应参数的情况下，这需要计算残差的(条件)平方和(SS)。

已经提出了不同的方法来计算残差的 SS:

*   根据 McLeod 和 Sales (1983)的近似最大似然法
*   回推的近似最大似然法
*   根据 Melard (1984)的精确最大似然法

### 模型的评估

*   **Parameter estimates**:

    *   报告推测出 *t* 的值，根据参数标准误差计算得出
    *   如果没有显著性，那么在大多数情况下，可以从模型中删除单独的参数，而不会显著影响模型的整体拟合

*   **其他质量标准**:模型质量的另一个明确而正常的衡量标准是考虑部分数据后得出的预测的准确性，这样预测就可以与已知的(独特的)观察结果进行对比

### 中断的时间序列 ARIMA

我们可能希望评估一个或多个离散事件对时间序列质量的影响。麦克多沃尔、麦克利里、梅丁格和海伊(1980)在《微妙元素》中描述了时间序列分析中的这些中断。麦克多沃尔等人认识到三种值得注意的可以想象的效应:

*   永久突变
*   永久渐进
*   突然的暂时的

## 指数平滑

事实证明，指数平滑法作为一种预测各种时间序列数据的策略是非常著名的。这个策略是布朗和霍尔特自由创造的。第二次世界大战期间，布朗为美国海军工作，他的任务是设计一个火控信息跟踪系统，以计算潜艇的位置。后来，他将这一策略与备件兴趣预测(库存控制问题)联系起来。

### 简单指数平滑

时间序列 t 的一个简单模型是将每个观测值视为由一个常数( *b* )和一个误差分量(ε)组成，即: *Xt = b + t* 。

常数 b 在数列的每个片段中一般是稳定的；但是，过一段时间后可能会逐渐改变。如果符合的可能性很小，那么一种排除 b 的真实估计的方法，也就是序列的有序或不令人惊讶的部分，是计算一种移动的正态，其中当前的和快速的新观测值比特定的旧观测值给予更显著的权重。

指数平滑精确地实现了这种加权，其中指数较小的权重被分配给较老的观察值。简单指数平滑的具体公式如下:

*St = a*Xt + (1-a)*St-1*

当递归连接到序列中的每个渐进观测值时，每个新的平滑值(预测值)被表示为当前观测值和过去平滑观测值的加权正态。

从过去的观察值和在过去的感知之前的平滑质量处理过去的平滑观察，等等。随后，每个平滑值是过去感知的加权正态，其中权重根据参数(α)的估计而指数下降。

万一它等同于 1(一)，那么过去的感知就被完全忽略了；如果它等于 0(零)，则当前感知被完全忽略，并且平滑后的值完全包括过去的平滑后的质量(从它之前的平滑后的感知处理而来，等等；沿着这些线，每一个平滑的质量将等同于基本的平滑值 S0)。中间的估计将提供过渡结果:

*   如果它等于 1，那么过去的观察结果将被完全忽略
*   If it is equal to 0, then the current observation is ignored completely:

    *   平滑值完全由过去的平滑值组成(反过来，它是从它之前的平滑观察值计算的，等等；因此，所有平滑值将等于初始平滑值 S0)。中间的估计将提供过渡结果。

隐藏在观察到的时间序列中的过程的假设模型，简单的指数平滑，将经常产生精确的预测。

### 不适合指数(误差)

根据特定值评估预测准确性的最直接方法是绘制观测值和预测前一阶段的图。该图同样可以结合残差(相对于右 *Y* 轴缩放)，从而同样可以有效地区分更好或最明显不良拟合的位置。

这种对预测精度的直观检查通常是确定当前指数平滑模型是否符合数据的最强有力的技术:

*   **Mean error**: The **mean error** (**ME**) quality is essentially processed as the normal error value (normal of observed minus one-stage ahead forecast):

    *   很明显，这种方法的缺点是正负误差值可以相互抵消，所以这种方法并不是一个合适的通用标志。

*   **Mean absolute error:** The **mean absolute error** (**MAE**) value is processed as the normal absolute error value:

    *   如果该值为 0(零)，则拟合(预测)被认为是完美的。
    *   与均方误差值相比，这种拟合度量将忽略异常，因此，一种或不常见的大误差值对 MAE 的影响小于 MSE 值。

*   平方误差(SSE)和均方误差的总和**:这些值计算为平方误差值的集合(或常态)。作为统计拟合策略的一部分，这是最常用的拟合缺失指标。**
*   **Percentage error (PE)**: All the preceding measures depend on the actual error value. It might appear to be sensible to rather express the absence of fit as far as the relative deviation of the one-stage ahead forecasts from the observed values, which is with respect to the magnitude of the observed values.

    *   例如，当试图预测可能会逐月波动的逐月交易时，如果我们的预期以大约 10%的精度“达到目标”，我们可能会满足。最终，彻底的错误可能不那么令人感兴趣，但更多的是预测中的相对错误:

*PEt = 100*(Xt - Ft )/Xt*

这里 *Xt* 是时间 *t* 的观测值， *Ft* 是预测值(平滑值)。

*   **平均百分比误差(MPE)** :该值计算为 PE 值的平均值。
*   **Mean absolute percentage error (MAPE)**: As is the situation with the mean error value, a mean percentage error close to 0 (zero) can be created by substantial positive and negative rate percentage errors that offset each other. Consequently, a superior measure of relative general fit is the mean absolute percentage error. Additionally, this measure is generally more significant than the mean squared mistake:

    *   例如，意识到正常预测“偏离”5%本身就是一个有益的结果，尽管 30.8 的均方误差不是很容易解释的。

*   **自动搜索最佳参数**:利用拟牛顿函数最小化程序(与 ARIMA 相同)最小化均方误差、平均绝对误差或平均总速率误差。
*   **初始平滑值 S0** :我们需要一个 S0 值，记住最终目标是处理系列中主要观测的平滑质量(预测)。根据参数的决定(即当参数接近零时)，平滑过程的基础值会影响某些观测值的预测性质。



# 在朱莉娅中实现

TimeSeries 是一个注册包。因此，像其他软件包一样，我们可以将其添加到您的 Julia 软件包中:

```
Pkg.update() 
Pkg.add("TimeSeries")

```

## time array 时间序列类型

```
immutable TimeArray{T, N, D<:TimeType, A<:AbstractArray} <: AbstractTimeSeries

 timestamp::Vector{D}
 values::A
 colnames::Vector{UTF8String}
 meta::Any

 function TimeArray(timestamp::Vector{D},
 values::AbstractArray{T,N},
 colnames::Vector{UTF8String},
 meta::Any)
 nrow, ncol = size(values, 1), size(values, 2)
 nrow != size(timestamp, 1) ? error("values must match length of
 timestamp"):
 ncol != size(colnames,1) ? error("column names must match width of
 array"):
 timestamp != unique(timestamp) ? error("there are duplicate dates"):
 ~(flipdim(timestamp, 1) == sort(timestamp) || timestamp ==
 sort(timestamp)) ? error("dates are mangled"):
 flipdim(timestamp, 1) == sort(timestamp) ? 
 new(flipdim(timestamp, 1), flipdim(values, 1), colnames, meta):
 new(timestamp, values, colnames, meta)
 end
end
```

该类型有四个字段:

*   `timestamp`:时间戳字段由`TimeType`的子类型的值的向量组成，实际上，或者是`Date`或者是`DateTime`。`DateTime`类型类似于日期类型，只是它表示小于一天的时间范围。为了构建一个有效的 TimeArray，需要对这个向量进行排序。如果 vector 包含不连续的日期，对象的构造将出错。向量也需要从最早的日期到最新的日期排序，但是这可以由构造函数来处理，并且不会禁止创建对象。
*   `values`:values 字段保存时间序列中的数据，其行数必须与时间戳数组的长度相匹配。如果这些不匹配，构造函数将失败。values 数组中的所有值必须属于同一类型。
*   `colnames`:`colnames`字段是 UTF8 字符串类型的向量，包含值字段中每一列的列名。该向量的长度必须与值数组的列数匹配，否则构造函数将失败。
*   `meta`:**meta 字段默认为空，用类型 Void 表示。这一默认设置旨在允许程序员忽略该字段。对于那些希望使用这个字段的人来说，`meta`可以保存常见的类型，比如字符串或者更复杂的用户定义类型。人们可能希望为一个对象指定一个不可变的名称，而不是依赖于对象类型字段之外的变量绑定。**

**我们将使用`MarketData`包中提供的历史财务数据集:**

```
**Pkg.add("MarketData") 
using TimeSeries 
using MarketData** 
```

**现在让我们来看一下数据:**

```
ohlc[1] 
```

**这会产生以下输出:**

```
1x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-01-03 

             Open      High      Low       Close      
2000-01-03 | 104.88    112.5     101.69    111.94 
```

**让我们再看一些记录和统计数据:**

```
ohlc[[1:3;9]] 
```

**这会产生以下输出:**

```
4x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-01-13 

             Open      High      Low       Close      
2000-01-03 | 104.88    112.5     101.69    111.94     
2000-01-04 | 108.25    110.62    101.19    102.5      
2000-01-05 | 103.75    110.56    103.0     104.0      
2000-01-13 | 94.48     98.75     92.5      96.75 
```

**我们还可以使用列名浏览它们:**

```
500x2 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2001-12-31 

             Open      Close      
2000-01-03 | 104.88    111.94     
2000-01-04 | 108.25    102.5      
2000-01-05 | 103.75    104.0      
2000-01-06 | 106.12    95.0       

2001-12-26 | 21.35     21.49      
2001-12-27 | 21.58     22.07      
2001-12-28 | 21.97     22.43      
2001-12-31 | 22.51     21.9 
```

**要使用日期访问记录，可按如下方式进行:**

```
ohlc[[Date(2000,1,3),Date(2000,2,4)]] 
```

**它将给出以下输出:**

```
2x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-02-04 

             Open      High      Low       Close      
2000-01-03 | 104.88    112.5     101.69    111.94     
2000-02-04 | 103.94    110.0     103.62    108.0 
```

**我们还可以列出日期范围内的记录:**

```
ohlc[Date(2000,1,10):Date(2000,2,10)] 
```

**它产生以下输出:**

```
23x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-10 to 2000-02-10 

             Open      High      Low       Close      
2000-01-10 | 102.0     102.25    94.75     97.75      
2000-01-11 | 95.94     99.38     90.5      92.75      
2000-01-12 | 95.0      95.5      86.5      87.19      
2000-01-13 | 94.48     98.75     92.5      96.75      

2000-02-07 | 108.0     114.25    105.94    114.06     
2000-02-08 | 114.0     116.12    111.25    114.88     
2000-02-09 | 114.12    117.12    112.44    112.62     
2000-02-10 | 112.88    113.88    110.0     113.5 
```

**我们也可以使用两种不同的色谱柱:**

```
ohlc["Open"][Date(2000,1,10)] 
```

**它产生以下输出:**

```
1x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-10 to 2000-01-10 

             Open       
2000-01-10 | 102 
```

## **使用时间限制**

**如果满足条件，有一些特定的方法可以对时间范围进行分段。**

### **什么时候**

**when 方法允许将来自`TimeArray`的元素聚合到特定的时间段中。**

**比如:`dayofweek`或者`month`。以下是一些日期方法和示例:**

```
day   Jan 3, 2000 = 3 
dayname  Jan 3, 2000 = "Monday" 
week  Jan 3, 2000 = 1 
month Jan 3, 2000 = 1 
monthname   Jan 3, 2000 = "January" 
year  Jan 3, 2000 = 2000 
dayofweek   Monday = 1 
dayofweekofmonth  Fourth Monday in Jan = 4 
dayofyear   Dec 31, 2000 = 366 
quarterofyear  Dec 31, 2000 = 4 
dayofquarter   Dec 31, 2000 = 93 
```

### **来自**

```
from(cl, Date(2001, 10, 24)) 
```

**这将产生以下输出:**

```
47x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2001-10-24 to 2001-12-31 

             Close     
2001-10-24 | 18.95     
2001-10-25 | 19.19     
2001-10-26 | 18.67     
2001-10-29 | 17.63     

2001-12-26 | 21.49     
2001-12-27 | 22.07     
2001-12-28 | 22.43     
2001-12-31 | 21.9 
```

### **到**

```
to(cl, Date(2000, 10, 24))
```

**该代码将生成以下输出:**

```
206x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-03 to 2000-10-24 

             Close      
2000-01-03 | 111.94     
2000-01-04 | 102.5      
2000-01-05 | 104.0      
2000-01-06 | 95.0       

2000-10-19 | 18.94      
2000-10-20 | 19.5       
2000-10-23 | 20.38      
2000-10-24 | 18.88 
```

### **寻找时间**

**这可能是最常用和最有效的方法之一。它测试一个条件并返回`Date`或`DateTime`向量:**

```
red = findwhen(ohlc["Close"] .< ohlc["Open"]); 
```

**这将生成以下输出:**

```
252x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-04 to 2001-12-31 

             Open      High      Low       Close      
2000-01-04 | 108.25    110.62    101.19    102.5      
2000-01-06 | 106.12    107.0     95.0      95.0       
2000-01-10 | 102.0     102.25    94.75     97.75      
2000-01-11 | 95.94     99.38     90.5      92.75      

2001-12-14 | 20.73     20.83     20.09     20.39      
2001-12-20 | 21.4      21.47     20.62     20.67      
2001-12-21 | 21.01     21.54     20.8      21.0       
2001-12-31 | 22.51     22.66     21.83     21.9 
```

### **找到**

**`find`方法类似于`findwhen`。它测试一个条件并返回一个 Int 向量，表示数组中条件为真的行:**

```
green = find(ohlc["Close"] .> ohlc["Open"]); 
```

**这将生成以下输出:**

```
244x4 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2001-12-28 

             Open      High      Low       Close      
2000-01-03 | 104.88    112.5     101.69    111.94     
2000-01-05 | 103.75    110.56    103.0     104.0      
2000-01-07 | 96.5      101.0     95.5      99.5       
2000-01-13 | 94.48     98.75     92.5      96.75      

2001-12-24 | 20.9      21.45     20.9      21.36      
2001-12-26 | 21.35     22.3      21.14     21.49      
2001-12-27 | 21.58     22.25     21.58     22.07      
2001-12-28 | 21.97     23.0      21.96     22.43 
```

### **数学、比较和逻辑运算符**

**TimeSeries 包也支持这些方法。**

**要使用数学运算符:**

*   **+或。+:数学元素加法**
*   **或者。-:数学元素减法**
*   ***或者。*:数学元素式乘法**
*   **。/:数学元素式除法**
*   **。^:数学元素幂运算**
*   **%或者。%:数学元素式余数**

**要使用比较运算符:**

*   **。>基于元素的大于比较**
*   **。**
*   **。==基于元素的等效比较**
*   **。> =基于元素的大于或等于比较**
*   **。< =基于元素的小于或等于比较**
*   **。！=元素方面的不等价比较**

**要使用逻辑运算符:**

*   **&基于元素的逻辑 AND**
*   **基于元素的逻辑或**
*   **！，~元素式逻辑非**
*   **$基于元素的逻辑 XOR**

### **将方法应用于时间序列**

**时间序列数据的常见转换包括:**

*   **落后的**
*   **主要的**
*   **计算变化**
*   **窗口操作和聚合操作**

#### **层**

**`lag`方法将昨天的值放入今天的时间戳:**

```
cl[1:4] 

#Output 
4x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-03 to 2000-01-06 

             Close      
2000-01-03 | 111.94     
2000-01-04 | 102.5      
2000-01-05 | 104.0      
2000-01-06 | 95.0 
```

**它对此应用了滞后:**

```
lag(cl[1:4]) 
```

**它生成以下输出:**

```
3x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-04 to 2000-01-06 

             Close      
2000-01-04 | 111.94     
2000-01-05 | 102.5      
2000-01-06 | 104.0 
```

#### **铅**

**超前与滞后相反:**

```
lead(cl[1:4]) 
```

**生成的输出如下:**

```
3x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-03 to 2000-01-05 

             Close      
2000-01-03 | 102.5      
2000-01-04 | 104.0      
2000-01-05 | 95.0 
```

**由于 cl 有 500 行长，我们可以一直领先到那个时候。目前，我们将领先 400:**

```
lead(cl, 400) 
```

**生成的输出如下:**

```
100x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-03 to 2000-05-24 

             Close     
2000-01-03 | 19.5      
2000-01-04 | 19.13     
2000-01-05 | 19.25     
2000-01-06 | 18.9      

2000-05-19 | 21.49     
2000-05-22 | 22.07     
2000-05-23 | 22.43     
2000-05-24 | 21.9 
```

#### **百分比**

**最常见的时间序列操作之一是计算百分比变化:**

```
percentchange(cl) 
```

**生成的输出如下:**

```
499x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2000-01-04 to 2001-12-31 

             Close    
2000-01-04 | -0.0843  
2000-01-05 | 0.0146   
2000-01-06 | -0.0865  
2000-01-07 | 0.0474   

2001-12-26 | 0.0061   
2001-12-27 | 0.027    
2001-12-28 | 0.0163   
2001-12-31 | -0.0236 
```

**这显示了与先前记录相比的百分比变化。**

### **时间序列中的组合方法**

**两个`TimeArrays`可以合并生成一个有意义的数组。**

#### **合并**

**Merge 联接两个 TimeArrays。默认情况下，它使用内部联接进行联接:**

```
merge(op[1:4], cl[2:6], :left) 
```

**生成的输出如下:**

```
4x2 TimeSeries.TimeArray{Float64,2,Date,Array{Float64,2}} 2000-01-03 to 2000-01-06 

             Open      Close      
2000-01-03 | 104.88    NaN        
2000-01-04 | 108.25    102.5      
2000-01-05 | 103.75    104.0      
2000-01-06 | 106.12    95.0 
```

**在上一个示例中，我们提供了想要执行的连接类型。我们也可以做右连接或外连接。**

#### **崩溃**

**`collapse`方法用于将数据压缩到更大的时间范围内。**

#### **地图**

**这用于时间序列数据的转换。这个方法的第一个参数是一个二元函数(时间戳和值)。该方法返回两个值，分别是新的时间戳和新的向量值:**

```
a = TimeArray([Date(2015, 10, 24), Date(2015, 11, 04)], [15, 16], ["Number"]) 
```

**生成的输出如下:**

```
 2x1 TimeSeries.TimeArray{Int64,1,Date,Array{Int64,1}} 2015-10-24 to 2015-11-04 

             Number    
2015-10-24 | 15        
2015-11-04 | 16 
```

**您可以按如下方式应用贴图方法:**

```
map((timestamp, values) -> (timestamp + Dates.Year(1), values), a) 
```

**这将转换提供的特定时间的记录:**

```
2x1 TimeSeries.TimeArray{Int64,1,Date,Array{Int64,1}} 2016-10-24 to 2016-11-04 

             Number    
2016-10-24 | 15        
2016-11-04 | 16 
```

**

# 总结

在这一章中，我们学习了什么是预测，以及为什么企业需要预测。预测有助于确定需求并采取必要的措施，在其他领域也有助于预测天气，等等。决策过程在很大程度上受到预测结果的影响。时间序列是洞察的排列，通常以标准间隔收集。它已被应用于各种领域，如医疗、气象、金融市场等。

我们还学习了不同类型的模型以及如何分析时间序列的趋势。我们还考虑了季节性对时间序列分析的影响。我们详细讨论了 ARIMA，也探索了朱莉娅的时间序列库。



# 参考文献

*   [http://timeseriesjl.readthedocs.io/en/latest/](http://timeseriesjl.readthedocs.io/en/latest/)
*   [https://documents . software . Dell . com/statistics/textbook/time-series-analysis](https://documents.software.dell.com/statistics/textbook/time-series-analysis)
*   [http://home.ubalt.edu/ntsbarsh/stat-data/forecast.htm](http://home.ubalt.edu/ntsbarsh/stat-data/forecast.htm)
*   [http://user www . sfsu . edu/EFC/classes/biol 710/time series/time series 1 . htm](http://userwww.sfsu.edu/efc/classes/biol710/timeseries/timeseries1.htm)
*   [https://onlinecourses.science.psu.edu/stat510/node/47](https://onlinecourses.science.psu.edu/stat510/node/47)
*   [http://www . ITL . NIST . gov/div 898/handbook/PMC/section 4/pm C4 . htm](http://www.itl.nist.gov/div898/handbook/pmc/section4/pmc4.htm)**