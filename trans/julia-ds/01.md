

# 一、基础——Julia的环境

Julia 是一门相当年轻的编程语言。2009 年，在 Alan Edelman 教授的指导下，麻省理工学院应用计算组的三名开发人员(Stefan Karpinski、Jeff Bezanson 和 Viral Shah)开始致力于一个项目，该项目将产生 Julia。2012 年 2 月，Julia 公开亮相，成为开源。源代码可以在 GitHub([https://github.com/JuliaLang/julia](https://github.com/JuliaLang/julia))上找到。注册包的源代码也可以在 GitHub 上找到。目前，所有四个最初的创作者，以及来自世界各地的开发者，都在积极地为 Julia 做贡献。

### 注意

当前版本是 0.4，离它的候选版本 1.0 还有一段距离。

基于坚实的原则，它在科学计算、数据科学和高性能计算领域的受欢迎程度稳步上升。

本章将指导你下载和安装 Julia 的所有必要组件。本章涵盖以下主题:

*   Julia有什么不同？
*   设置Julia的环境。
*   利用Julia的Shell和 REPL。
*   使用 jupiter 笔记本
*   包装管理
*   并行计算
*   多重调度
*   语言互用性

传统上，科学界使用较慢的动态语言来构建他们的应用，尽管他们需要最高的计算性能。有编程经验的领域专家，但通常不是经验丰富的开发人员，总是更喜欢动态语言而不是静态类型语言。

# Julia与众不同

多年来，随着编译器技术和语言设计的进步，有可能消除性能和动态原型之间的权衡。因此，科学计算需要像 Python 这样优秀的动态语言以及像 C 这样的性能。然后出现了 Julia，这是一种根据科学和技术计算的要求而设计的通用编程语言，它提供了与 C/C++相当的性能，并且具有像 Python 这样的高级动态语言那样足以进行原型开发的环境。Julia 性能的关键在于其设计和基于**低级虚拟机** (LLVM)的实时编译器，这使其能够接近 C 和 Fortran 的性能。

Julia 提供的主要功能有:

*   一种通用的高级动态编程语言，旨在有效地进行数值和科学计算
*   一个基于**的**低级虚拟机** ( **LLVM** )实时** ( **JIT** )编译器，使 Julia 能够接近 C/C++等静态编译语言的性能

以下引文来自 Julia 的开发团队——Jeff Bezanson、Stefan Karpinski、Viral Shah 和 Alan Edelman:

### 注意

我们很贪婪:我们想要更多。

我们想要一种开源的语言，有一个自由的许可证。我们想要 C 的速度和 Ruby 的活力。我们想要一种同形异义的语言，既有像 Lisp 那样的真正的宏，又有像 Matlab 那样明显、熟悉的数学符号。我们想要像 Python 一样可用于一般编程，像 R 一样易于统计，像 Perl 一样自然用于字符串处理，像 Matlab 一样强大用于线性代数，像 shell 一样善于将程序粘合在一起。这种东西学习起来非常简单，却能让最严肃的黑客感到高兴。我们希望它是交互式的，我们希望它是编译过的。

(我们有没有提到它应该和 C 一样快？)

人们经常将它与 Python、R、MATLAB 和 Octave 相比较。这些已经存在很长时间了，Julia 深受其影响，尤其是在数字和科学计算方面。尽管 Julia 非常擅长，但它并不仅限于科学计算，因为它也可以用于 web 和通用编程。

Julia 的开发团队旨在创造一种前所未有的卓越的能力和效率的结合，而不损害单一语言的易用性。Julia 的大部分核心都是用 C/C++实现的。Julia 的解析器是用 Scheme 写的。Julia 高效的跨平台 I/O 是由 Node.js 的 libuv 提供的。

Julia 的特点和优势可以总结如下:

*   它是为分布式并行计算而设计的。
*   Julia 提供了大量的数学函数库，具有很高的数值精度。
*   Julia 提供了多重分派的功能。多重分派是指使用参数类型的多种组合来定义函数行为。
*   Pycall 包使 Julia 能够使用 Matlab.jl 调用其代码和 Matlab 包中的 Python 函数，用 C 编写的函数和库也可以直接调用，不需要任何 API 或包装器。
*   Julia 为管理系统中的其他进程提供了强大的类似 shell 的功能。
*   与其他语言不同，Julia 中的用户定义类型是紧凑的，并且作为内置类型非常快。
*   数据分析大量使用矢量化代码来获得性能优势。Julia 消除了向量化代码以提高性能的需要。用 Julia 编写的去矢量化代码可以和矢量化代码一样快。
*   它使用轻量级“绿色”线程，也称为任务或协程、协作多任务或一次性延续。
*   Julia有一个强大的打字系统。提供的转换是优雅的和可扩展的。
*   它对 Unicode 有高效的支持。
*   它有元编程和类似 Lisp 的宏的工具。
*   它有一个内置的包管理器。(Pkg)
*   Julia 为不同的参数类型提供了高效、专业和自动的代码生成。
*   它是免费的开源软件，有麻省理工学院的许可。



# 设置环境

Julia是免费的。可以从它的网站下载，地址如下:[http://julialang.org/downloads/](http://julialang.org/downloads/)。该网站还有详尽的文档、示例以及教程和社区的链接。文档可以以流行的格式下载。

## 安装 Julia (Linux)

Ubuntu/Linux Mint 是最著名的 Linux 发行版之一，他们也提供了 Julia 的 deb 包。这些可用于 32 位和 64 位发行版。

要安装 Julia，添加 **PPA** ( **个人包存档**)。Ubuntu 用户有足够的特权拥有 PPA。它被视为构建和发布 Ubuntu 源码包的 apt 库。在终端中，键入以下内容:

```
sudo apt-get add-repository ppa:staticfloat/juliareleases 
sudo apt-get update 

```

这将添加 PPA 并更新存储库中的包索引。

现在安装 Julia:

```
sudo apt-get install Julia 

```

安装完成。要在终端中检查安装是否成功，请键入以下内容:

```
julia --version 

```

这给出了安装的Julia的版本。

![Installing Julia (Linux)](graphics/image_01_001.jpg)

要打开 Julia 的交互式 shell，请在终端中键入`julia`。要卸载 Julia，只需使用`apt`删除它:

```
sudo apt-get remove julia 

```

对于 Fedora/RHEL/CentOS 或基于它们的发行版，为您的发行版启用 EPEL 存储库。然后，点击提供的链接。使用以下命令启用 Julia 的存储库:

```
dnf copr enable nalimilan/julia

```

或者复制相关的`.repo`文件，如下所示:

```
/etc/yum.repos.d/

```

最后，在终端中键入以下内容:

```
yum install julia

```

## 安装Julia(苹果电脑)

使用 Mac OS X 的用户需要点击下载的`.dmg`文件来运行磁盘镜像。之后，拖动应用图标到**应用**文件夹。它可能会提示您询问是否要继续，因为源代码是从互联网上下载的，因此不安全。如果是为 Julia 语言官方网站下载的，请单击继续。

Julia 也可以使用 homebrew 在 Mac 上安装，如下所示:

```
brew update 
brew tap staticfloat/julia 
brew install julia 

```

安装完成。要检查终端中的安装是否成功，请键入以下内容:

```
julia --version 

```

这将为您提供安装的 Julia 版本。

## 安装 Julia (Windows)

根据您的系统配置(32 位/64 位)下载下载页面上提供的`.exe`文件。Julia 通过运行下载的`.exe`文件安装在 Windows 上，该文件会将 Julia 解压到一个文件夹中。这个文件夹中有一个名为`julia.bat`的批处理文件，可以用来启动 Julia 控制台。

要卸载，请删除`Julia`文件夹。

## 探索源代码

对于爱好者来说，Julia 的源代码是可用的，并且鼓励用户通过添加功能或修复错误来做出贡献。这是树的目录结构:

| `base/` | Julia 标准库的源代码 |
| `contrib/` | 编辑器支持 Julia 源码，杂项脚本 |
| `deps/` | 外部依赖性 |
| `doc/manual` | 用户手册的来源 |
| `doc/stdlib` | 标准库函数帮助文本的来源 |
| `examples/` | Julia 程序示例 |
| `src/` | Julia 语言核心的来源 |
| `test/` | 测试套件 |
| `test/perf` | 基准套件 |
| `ui/` | 各种前端的来源 |
| `usr/` | 由 Julia 的标准库加载的二进制文件和共享库 |



# 使用 REPL

Read-Eval-Print-Loop 是一个交互式 shell 或语言 shell，它提供了测试代码片段的功能。Julia 在后端提供了一个带有实时编译器的交互式 shell。我们可以在一行中给出输入，它被编译和评估，结果在下一行中给出。

![Using REPL](graphics/image_01_002.jpg)

使用 REPL 的好处是我们可以测试出代码中可能的错误。还有，对于新手来说是一个很好的环境。我们可以输入表达式，然后按*回车*进行求值。

一个 Julia 库，或者定制的 Julia 程序，可以使用`include`包含在 REPL 中。例如，我有一个名为`hello.jl`的文件，我将通过执行以下操作将它包含在 REPL 中:

```
julia> include ("hello.jl") 

```

Julia 还将 REPL 中编写的所有命令存储在`.julia_history`中。这个文件在 Ubuntu 上位于`/home/$USER`，在 Windows 上位于`C:\Users\username`，在 OS X 上位于`~/.julia_history`

与 Linux 终端一样，我们可以在 Julia 的 shell 中使用 *Ctrl* + *R* 进行反向搜索。这是一个非常好的特性，因为我们可以回顾输入命令的历史。

在语言包中键入`?`会将提示更改为:

```
help?> 

```

![Using REPL](graphics/image_01_003.jpg)

要清除屏幕，按下 *Ctrl* + *L* 。要退出 REPL，请按下 *Ctrl* + *D* 或键入以下内容:

```
julia> exit(). 

```



# 使用 Jupyter 笔记本

数据科学和科学计算有幸拥有一个令人惊叹的交互工具，叫做 Jupyter Notebook。使用 Jupyter Notebook，您可以在交互式 web 环境中编写和运行代码，该环境还具有可视化、图像和视频功能。它使得方程测试和原型制作变得更加容易。它支持超过 40 种编程语言，并且是完全开源的。

GitHub 支持 Jupyter 笔记本。记录计算的笔记本可以通过 Jupyter 笔记本浏览器或其他云存储共享。Jupyter 笔记本广泛用于编码机器学习算法、统计建模和数值模拟以及数据管理。

Jupyter Notebook 是用 Python 实现的，但是你可以用 40 种语言中的任何一种运行代码，只要你有它们的内核。您可以通过在终端中键入以下内容来检查您的系统上是否安装了 Python:

```
python -version 

```

这将给出 Python 的版本，如果它在系统上的话。最好是 Python 2.7.x 或 3.5.x 或更高版本。

如果没有安装 Python，您可以从 Windows 的官方网站下载来安装。对于 Linux，键入以下内容应该可以:

```
sudo apt-get install python 

```

如果您是 Python 和数据科学的新手，强烈建议您安装 Anaconda。用于数据科学、数值和科学计算的常用包(包括 Jupyter notebook)与 Anaconda 捆绑在一起，这使它成为设置环境的首选方式。可以在[https://www.continuum.io/downloads](https://www.continuum.io/downloads)找到说明。

Jupyter 存在于 Anaconda 包中，但是您可以通过键入以下命令来检查 Jupyter 包是否是最新的:

```
conda install jupyter 

```

另一种安装 Jupyter 的方法是使用`pip`:

```
pip install jupyter 

```

要检查 Jupyter 是否安装正确，请在终端中键入以下内容:

```
jupyter -version 

```

如果安装了 Jupyter，它应该给出它的版本。

现在，要使用 Jupyter 的 Julia，我们需要`IJulia`包。这可以使用 Julia 的包管理器来安装。

安装 IJulia 后，我们可以在 Jupyter 的**笔记本**部分下选择 Julia 来创建一个新的笔记本。

![Using Jupyter Notebook](graphics/image_01_004.jpg)

要获得所有软件包的最新版本，请在 Julia 的 shell 中键入以下内容:

```
julia> Pkg.update() 

```

之后，通过键入以下命令添加 IJulia 包:

```
julia> Pkg.add("IJulia") 

```

在 Linux 中，您可能会面临一些警告，所以最好构建这个包:

```
julia> Pkg.build("IJulia") 

```

安装完 IJulia 后，回到终端并启动 Jupyter 笔记本:

```
jupyter notebook 

```

将会打开一个浏览器窗口。在 **New** 下，你会发现用已经安装的内核创建新笔记本的选项。因为我们想开始一个Julia笔记本电脑，我们将选择**Julia 0.4.2** 。这将启动一个新的 Julia 笔记本。你可以尝试一个简单的例子。

在本例中，我们正在创建一个随机数直方图。这只是一个例子，我们将在接下来的章节中详细研究使用的组件。

![Using Jupyter Notebook](graphics/image_01_005.jpg)

Atom 和 Sublime 等热门编辑器都有针对 Julia 的插件。Atom 有语言—julia 和 Sublime 有 Sublime—IJulia，两者都可以从它们的包管理器中下载。



# 包装管理

Julia 提供了一个内置的包管理器。使用 Pkg 我们可以安装用 Julia 写的库。对于外部库，我们也可以从它们的源代码编译它们，或者使用操作系统的标准包管理器。在[http://pkg.julialang.org](http://pkg.julialang.org)维护已注册包的列表。

Pkg 在基本安装中提供。Pkg 模块包含所有的软件包管理器命令。

## pkg . status()–包裹状态

`Pkg.status()`是一个打印出当前已安装软件包列表和摘要的函数。当您需要知道您想要使用的包是否已安装时，这很方便。

第一次运行`Pkg`命令时，会自动创建包目录。命令要求`Pkg.status()`返回一个有效的安装包列表。`Pkg.status()`给出的包列表是由 Pkg 管理的注册版本。

`Pkg.installed()`也可用于返回所有已安装软件包及其版本的列表。

![Pkg.status() – package status](graphics/image_01_006.jpg)

## pkg . add()–添加包

Julia 的包管理器是声明性的和智能的。你只需要告诉它你想要什么，它就会计算出要安装什么版本，如果有依赖关系，它就会解决。因此，我们只需要添加我们想要的需求列表，它决定了要安装哪些包及其版本。

`~/.julia/v0.4/REQUIRE`文件包含了包需求。我们可以使用 vi 或 atom 等文本编辑器打开它，或者在 Julia 的 shell 中使用`Pkg.edit()`来编辑这个文件。编辑完文件后，运行`Pkg.resolve()`来安装或移除软件包。

我们也可以使用`Pkg.add(package_name)`来添加包，使用`Pkg.rm(package_name)`来删除包。之前，我们用`Pkg.add("IJulia")`安装了 IJulia 包。

当我们不想在我们的系统上再安装一个包时，`Pkg.rm()`用于从`REQUIRE`文件中删除需求。与`Pkg.add()`类似，`Pkg.rm()`首先从`REQUIRE`文件中删除包的需求，然后通过运行`Pkg.resolve()`来更新已安装包的列表。

## 使用未注册的软件包

通常，我们希望能够使用由我们的团队成员或在 Git 上发布过的人创建的包，但是它们不在 Pkg 的注册包中。Julia允许我们通过克隆来做到这一点。Julia 包托管在 Git 存储库中，可以使用 Git 支持的机制进行克隆。注册包的索引保持在`METADATA.jl`。对于非官方软件包，我们可以使用以下内容:

```
Pkg.clone("git://example.com/path/unofficialPackage/Package.jl.git") 

```

有时，未注册的软件包具有依赖关系，需要在使用前完成。如果是这种情况，在未注册的包的源代码树的顶部需要一个`REQUIRE`文件。未注册的包对已注册的包的依赖性由这个`REQUIRE`文件决定。当我们运行`Pkg.clone(url)`时，这些依赖项会自动安装。

### pkg . update()–包更新

有更新的包是好事。Julia 正在积极开发中，它的软件包经常更新，并增加了新的功能。

要更新所有软件包，请键入以下内容:

```
Pkg.update() 

```

在幕后，新的更改被放入位于`~/.julia/v0.4/` 的目录中的元数据文件，它检查自上次更新以来可能已经发布的任何新注册的包版本。如果有新注册的包版本，`Pkg.update()`会尝试更新在分支上检出的非脏包。这个更新过程通过计算要安装的软件包版本的最佳集合来满足顶级需求。必须安装的特定版本的软件包在 Julia 目录下的 REQUIRE 文件中定义(`~/.julia/v0.4/`)。

## 元数据存储库

使用官方的`METADATA.jl`库下载并安装注册的软件包。如果需要，还可以提供不同的`METADATA`存储库位置:

```
julia> Pkg.init("https://julia.customrepo.com/METADATA.jl.git", "branch") 

```

## 开发包装

Julia 允许我们查看源代码，当它被 Git 跟踪时，所有已安装的包的完整开发历史都是可用的。我们还可以进行我们想要的更改，并提交到我们自己的存储库中，或者修复 bug 并在上游贡献增强功能。

您可能还想创建自己的包，并在某个时间发布它们。Julia 的包管理器也允许你这样做。

要求在系统上安装 Git，开发人员需要在他们选择的主机提供商(GitHub、Bitbucket 等)上有一个帐户。最好能够通过 SSH 进行通信——要实现这一点，请将您的公共 ssh-key 上传到您的主机提供商。

## 创建新的包

最好将`REQUIRE`文件放在包存储库中。这应该有最起码的Julia版本的描述。

例如，如果我们想要创建一个名为`HelloWorld`的新的 Julia 包，我们会有以下内容:

```
Pkg.generate("HelloWorld", "MIT") 

```

这里，`HelloWorld`是我们想要创建的包，`MIT`是我们的包将拥有的许可证。许可证应该为包生成器所知。

这将创建如下目录:`~/.julia/v0.4/HelloWorld`。创建的目录被初始化为 Git 存储库。此外，软件包所需的所有文件都保存在这个目录中。然后，该目录被提交给存储库。

现在可以将它推送到远程存储库供全世界使用。



# 使用 Julia 的并行计算

现代计算技术的进步导致系统中出现了多核 CPU，有时这些系统被组合在一个集群中，能够执行单个系统可能无法单独执行的任务，或者即使执行也会花费不必要的时间。Julia 的并行处理环境是基于消息传递的。在不同的内存域中，程序允许有多个进程。

消息传递在 Julia 中的实现不同于其他流行的环境，比如 MPI。Julia 提供了单向通信，因此程序员在双进程操作中只显式地管理一个进程。

Julia 的并行编程范例建立在以下基础上:

*   远程引用
*   远程呼叫

在另一个进程上运行一个函数的请求称为远程调用。特定进程中的另一个对象对一个对象的引用称为远程引用。远程引用是大多数分布式对象系统中使用的一种结构。因此，由不同进程的对象使用某些特定参数对不同进程上的对象进行的调用被称为远程调用，这将返回对远程对象的引用，该引用被称为远程引用。

远程调用返回对其结果的远程引用。远程呼叫会立即返回。发出调用的进程继续执行下一个操作。同时，远程调用发生在其他地方。对其远程引用上的`wait()`的调用等待远程调用完成。使用`fetch()`可以获得结果的完整值，使用`put!()`将结果存储到远程引用。

Julia 使用单一进程默认值。要用多个处理器启动 Julia，请使用以下命令:

```
julia -p n

```

其中 n 是工作进程的数量。或者，可以通过使用`addproc(n)`从正在运行的系统中创建额外的处理器。建议将 n 设置为等于系统中 CPU 内核的数量。

`pmap`和`@parallel` 是两个最常用和最有用的函数。

Julia 提供了一个 *parallel for loop，*用来并行运行多个进程。其用法如下。

*Parallel for loop* 的工作原理是让多个流程分配迭代，然后减少结果(在本例中为(+)。这有点类似于 map-reduce 概念。迭代将在不同的过程上独立运行，并且这些过程获得的结果将在最后被组合(像 map-reduce)。一个循环的产物也可以成为另一个循环的进料。答案是整个平行循环的结果。

它与普通的迭代循环非常不同，因为迭代不是按照指定的顺序进行的。由于迭代在不同的进程上运行，任何发生在变量或数组上的写操作都不是全局可见的。使用的变量被复制并广播到并行 for 循环的每个进程。

例如:

```
arr = zeros(500000) 
@parallel for i=1:500000 
  arr[i] = i 
end 

```

这不会给出想要的结果，因为每个进程都有自己单独的`arr`副本。向量不会像预期的那样用`i`填充。我们必须避免这样的*平行循环*。

`pmap`指平行地图。例如:

![Parallel computation using Julia](graphics/image_01_007.jpg)

如果我们有许多大的随机矩阵，并且我们需要并行地获得奇异值，这个代码解决了这个问题。

茱莉亚的`pmap()`设计的不一样。它非常适合每个函数调用完成大量工作的情况，而`@parallel`适合处理涉及大量小迭代的情况。`pmap()`和`@parallel`都利用工作节点进行并行计算。然而，发起调用过程的节点在`@parallel`中为。



# Julia 的主要特点——多重派遣

函数是一个对象，使用某种表达式将一组参数映射到一个返回值。当这个函数对象不能返回值时，它抛出一个异常。对于不同类型的参数，同一个概念函数可以有不同的实现。例如，我们可以用一个函数将两个浮点数相加，用另一个函数将两个整数相加。但从概念上讲，我们只是把两个数字相加。Julia 提供了一种功能，通过这种功能可以很容易地实现同一概念的不同实现。不需要一次定义所有的函数。它们在小摘要中被定义。这些小的抽象是不同的参数类型组合，并有不同的相关行为。这些行为之一的定义称为方法。

方法定义接受的参数的类型和数量由其签名的注释来指示。因此，无论何时调用带有特定参数集的函数，都会应用最合适的方法。当一个函数被调用时应用一个方法被称为调度。传统上，面向对象语言只考虑调度中的第一个参数。Julia 与众不同，它会考虑函数的所有参数(不仅仅是第一个)，然后选择应该调用哪个方法。这就是众所周知的多重分派。

多重分派对于数学和科学代码特别有用。我们不应该认为这些操作属于某个参数多于其他任何参数。实现数学运算符时，会考虑所有的参数类型。多重分派并不局限于数学表达式，因为它可以用在许多真实世界的场景中，并且是构建程序的强大范例。

## 多种调度方式

`+` 是 Julia 中使用多重分派的函数。Julia 的所有标准函数和操作符都使用多重分派。对于参数类型和计数的各种可能组合，它们都有许多定义其行为的方法。使用`::`类型断言操作符，方法被限制为接受某些类型的参数:

```
julia> f(x::Float64, y::Float64) = x + y 

```

该函数定义仅适用于`x`和`y`都是`Float64`类型值的调用:

```
julia> f(10.0, 14.0) 
24.0 

```

如果我们试图将这个定义应用于其他类型的参数，将会导致方法错误。

![Methods in multiple dispatch](graphics/B05321_01_7.jpg)

参数必须与函数定义中定义的类型完全相同。

函数对象是在第一个方法定义中创建的。新的方法定义向现有的函数对象添加新的行为。当一个函数被调用时，参数的数量和类型被匹配，并且最具体的方法定义匹配将被执行。

下面的示例用两种方法创建一个函数。一个方法定义接受两个类型为`Float64`的参数，并将它们相加。第二个方法定义接受两个类型为`Number`的参数，将它们乘以 2 并相加。当我们调用带有`Float64`参数的函数时，应用第一个方法定义，当我们调用带有整数参数的函数时，应用第二个方法定义，因为数字可以取任何数值。在下面的例子中，我们使用多重分派来处理浮点数和整数。

![Methods in multiple dispatch](graphics/image_01_009.jpg)

在 Julia 中，所有值都是抽象类型“Any”的实例。当类型声明没有用`::`给出时，这意味着它没有被明确定义为实参的类型，因此 Any 是方法形参的默认类型，它没有接受任何类型值的限制。一般来说，一个方法定义以这样的方式编写，它将被应用于其他方法定义不适用的某些参数。这是 Julia 语言最强大的特性之一。

使用 Julia 的多重调度和灵活的参数类型系统，生成专门的代码和实现复杂的算法是非常有效的，并且非常容易表达，而不太关心底层实现。

## 歧义–方法定义

有时函数行为是以这样一种方式定义的，没有一个唯一的方法可以应用于某一组参数。在这种情况下，Julia 会抛出一个关于这种模糊性的警告，但是会任意选择一个方法。为了避免这种模糊性，我们应该定义一种方法来处理这种情况。

在下面的例子中，我们用一个类型为`Any`的参数和另一个类型为`Float64`的参数定义了一个方法。在第二个方法定义中，我们只是改变了顺序，但这并没有将其与第一个定义区分开来。在这种情况下，Julia 会给出一个模糊方法定义的警告，但是会允许我们继续。

![Ambiguities – method definitions](graphics/image_01_010.jpg)

# 促进语言互用性

虽然 Julia 可以用来编写大多数类型的代码，但是有一些成熟的数值和科学计算库，我们很想加以利用。这些库可以是 C、Fortran 或 Python。Julia 允许轻松使用用 Python、C 或 Fortran 编写的现有代码。这是通过让 Julia 执行简单高效的 C、Fortran 或 Python 函数来实现的。

Julia 应该可以使用 C/Fortran 库。使用`ccall` 对该代码进行了一次普通但有效的调用。当代码作为共享库可用时，这是可能的。Julia 的 JIT 生成与原生 C 调用相同的机器指令。因此，它通常与用最小的开销通过 C 代码调用没有什么不同。

导入 Python 代码可能是有益的，有时也是必要的，特别是对于数据科学，因为它已经有了一个详尽的机器学习和统计函数实现库。例如，它包含 scikit-learn 和 pandas。要在 Julia 中使用 Python，我们需要`PyCall.jl`。要添加`PyCall.jl`,请执行以下操作:

```
Pkg.add("PyCall") 

```

PyCall 包含一个宏`@pyimport`,它帮助导入 Python 包，并为其中的所有函数和常量提供 Julia 包装器，包括 Julia 和 Python 之间的自动类型转换。

PyCall 还提供了 Python 对象的低级操作功能，包括不透明 Python 对象的 PyObject 类型。它还有一个`pycall`函数(类似于 Julia 的`ccall`函数)，在 Julia 中可以用它来调用带有类型转换的 Python 函数。PyCall 不使用 Python 程序，而是直接链接到`libpython`库。在`Pkg.build`期间，它通过双关 python 找到了`libpython`的位置。

## 在 Julia 中调用 Python 代码

在大多数情况下，基于 Python 对象的运行时检查,`@pyimport`宏会自动将适当的类型转换为 Julia 类型。它通过使用低级函数来更好地控制这些类型转换。在返回类型已知的情况下使用 PyCall 有助于提高性能，既消除了运行时类型推断的开销，又为 Julia 编译器提供了更多的类型信息:

*   `pycall(function::PyObject, returntype::Type, args...)`:使用给定的`args...`(标准的 Julia 类型，如果可能的话，会自动转换为相应的 Python 类型)调用给定的 Python 函数(通常从模块中查找)，将返回值转换为`returntype`(使用 PyObject 的`returntype`返回未转换的 Python 对象引用，或者使用 PyAny 请求自动转换)。
*   `pyimport(s)`:导入 Python 模块(一个字符串或符号)并返回一个指向它的指针(一个 PyObject)。模块中的函数或其他符号可以通过 s[name]来查找，其中名称是一个字符串(对于原始的 PyObject)或一个符号(对于自动类型转换)。与`@pyimport`宏不同，它没有定义 Julia 模块，成员不能用`s.name`访问。



# 总结

在这一章中，我们学习了 Julia 的不同之处，以及基于 LLVM 的 JIT 编译器如何使 Julia 接近 C/C++的性能。我们向您介绍了如何下载 Julia，安装它，并从源代码编译它。我们发现的显著特征是，这种语言优雅、简洁、强大，并且具有惊人的数字和科学计算能力。

我们研究了一些通过命令行(REPL)与 Julia 一起工作的例子，并且看到了语言Shell有多么丰富的特性。找到的功能有制表符补全、反向搜索和帮助功能。我们还讨论了为什么要使用 Jupyter Notebook，并继续用 IJulia 包设置 Jupyter。我们做了一个简单的例子来使用 Jupyter 笔记本和 Julia 的可视化包，牛虻。

此外，我们了解了 Julia 强大的内置包管理以及如何添加、更新和删除模块。此外，我们经历了创建自己的包并将其发布到社区的过程。我们还向您介绍了 Julia 最强大的特性之一——多重分派，并研究了一些如何创建方法定义来实现多重分派的基本示例。

此外，我们还向您介绍了并行计算，解释了它与传统的消息传递有何不同，以及如何利用所有可用的计算资源。我们还学习了 Julia 的语言互操作性特性，以及如何从 Julia 程序中调用 Python 模块或库。



# 参考文献

*   -= the last fantasy =-荣誉出品本字幕仅供学习交流，严禁用于商业途径
*   [https://github.com/JuliaLang](https://github.com/JuliaLang)
*   [https://github.com/JuliaStats](https://github.com/JuliaStats)