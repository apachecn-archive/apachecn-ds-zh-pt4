

# 六、使用 Seaborn 和定制技术绘图

在前一章中，我们学习了如何在宽格式数据上使用`matplotlib`和`pandas`创建许多不同的可视化效果。在这一章中，我们将看到如何使用`seaborn`从长格式数据中进行可视化，以及如何定制我们的图来提高它们的可解释性。记住，人类的大脑擅长在视觉表象中寻找模式；通过清晰而有意义的数据可视化，我们可以帮助他人(更不用说我们自己)理解数据想要表达的意思。

Seaborn 能够制作许多我们在前一章中创造的相同的情节；然而，它也可以快速处理长格式数据，允许我们使用数据的子集将附加信息编码到我们的可视化中，例如不同类别的面和/或颜色。我们将通过使用`seaborn`来完成我们在上一章中所做的一些实现，这些实现更容易(或者更美观)，例如热图和结对图(散点图矩阵的`seaborn`等价物)。此外，我们将探索`seaborn`提供的一些新的情节类型，以解决其他情节类型可能易受影响的问题。

之后，我们将改变思路，开始讨论定制数据可视化的外观。我们将逐步完成创建注释、添加参考线、正确标记我们的图、控制所使用的调色板以及裁剪轴以满足我们的需求的过程。这是我们需要的最后一块，让我们的可视化准备好呈现给别人。

在本章中，我们将讨论以下主题:

*   将 seaborn 用于更高级的地块类型
*   使用 matplotlib 格式化绘图
*   自定义可视化

# 章节材料

本章的材料可以在 GitHub 上找到，网址是[https://GitHub . com/stef molin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch _ 06](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06)。我们将再次使用三个数据集，所有这些数据集都可以在`data/`目录中找到。在`fb_stock_prices_2018.csv`文件中，我们有脸书 2018 年所有交易日的股价。这个数据是 OHLC 数据(开盘价、最高价、最低价和收盘价)，以及交易量。它是使用`stock_analysis`包收集的，我们将在 [*第 7 章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146) 、*金融分析——比特币和股票市场*中构建这个包。股市周末休市，所以我们只有交易日的数据。

`earthquakes.csv`文件包含从 2018 年 9 月 18 日到 2018 年 10 月 13 日从**美国地质调查局**(**USGS**)API([https://earthquake.usgs.gov/fdsnws/event/1/](https://earthquake.usgs.gov/fdsnws/event/1/))提取的地震数据。对于每一次地震，我们都有震级(`mag`栏)、测得的震级(`magType`栏)、时间(`time`栏)、发生地点(`place`栏)；我们还有`parsed_place`列，表示地震发生的州或国家(我们在第 2 章 、*使用Pandas数据帧*中添加了该列)。其他不必要的列已被删除。

在`covid19_cases.csv`文件中，我们有一个由**欧洲疾病预防控制中心** ( **ECDC** )提供的*每日全球各国新增新冠肺炎报告病例数*数据集的导出，可在[https://www . ecdc . Europa . eu/en/publications-data/download-todays-data-geographic-distribution-新冠肺炎-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide) 找到。对于这些数据的脚本化或自动化收集，ECDC 通过以下链接提供当天的 CSV 文件:[https://open data . ecdc . Europa . eu/covid 19/case distribution/CSV](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv)。我们将使用的快照是 2020 年 9 月 19 日收集的，包含 2019 年 12 月 31 日至 2020 年 9 月 18 日每个国家的新增新冠肺炎病例数，以及 2020 年 9 月 19 日的部分数据。对于这一章，我们将着眼于从 2020 年 1 月 18 日到 2020 年 9 月 18 日的 8 个月时间跨度。

在本章中，我们将学习三本 Jupyter 笔记本。这些都是按照使用顺序编号的。我们将开始探索`1-introduction_to_seaborn.ipynb`笔记本中`seaborn`的功能。接下来，我们将继续讨论`2-formatting_plots.ipynb`笔记本，讨论如何格式化和标记我们的图。最后，在`3-customizing_visualizations.ipynb`笔记本中，我们将学习如何添加参考线，阴影区域，包括注释，以及定制我们的可视化。文字会提示我们何时切换笔记本。

小费

补充的`covid19_cases_map.ipynb`笔记本展示了一个使用全球新冠肺炎案例在地图上绘制数据的例子。它可以用来开始使用 Python 制作地图，也建立在我们将在本章中讨论的一些格式的基础上。

此外，我们有两个 Python ( `.py`)文件，其中包含我们将在整个章节中使用的函数:`viz` `.py`和`color_utils.py`。让我们从探索`seaborn`开始吧。

# 利用 seaborn 进行高级绘图

正如我们在前一章中看到的，`pandas`为我们想要创建的大多数可视化提供了实现；然而，还有另一个库`seaborn`，它为更复杂的可视化提供了额外的功能，并使得用长格式数据创建可视化比`pandas`容易得多。这些看起来也比由`matplotlib`生成的标准可视化效果更好。

在这一部分，我们将使用`1-introduction_to_seaborn.ipynb`笔记本。首先，我们必须导入`seaborn`，它的传统别名是`sns`:

```
>>> import seaborn as sns
```

让我们也导入`numpy`、`matplotlib.pyplot`和`pandas`，然后读入脸书股票价格和地震数据的 CSV 文件:

```
>>> %matplotlib inline
>>> import matplotlib.pyplot as plt
>>> import numpy as np
>>> import pandas as pd 
>>> fb = pd.read_csv(
...     'data/fb_stock_prices_2018.csv',
...     index_col='date', 
...     parse_dates=True
... )
>>> quakes = pd.read_csv('data/earthquakes.csv')
```

虽然`seaborn`为我们在前一章中介绍的许多情节类型提供了的替代方案，但在大多数情况下，我们将只介绍`seaborn`使成为可能的新类型，而将其余的内容作为练习。使用`seaborn` API 的其他可用功能可以在[https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)找到。

## 分类数据

2018 年 9 月 28 日印尼发生毁灭性海啸；它是在印度尼西亚帕卢附近发生 7.5 级地震后发生的([https://www . live science . com/63721-tsunami-seismic-Indonesia . html](https://www.livescience.com/63721-tsunami-earthquake-indonesia.html))。让我们创建一个可视化图形来了解印度尼西亚使用的震级类型、记录的震级范围以及有多少地震伴随着海啸。为此，我们需要一种方法来绘制关系，其中一个变量是分类变量(`magType`)，另一个是数字变量(`mag`)。

重要说明

关于不同震级类型的信息可以在 https://www . USGS . gov/natural-hazards/seismic-hazards/science/magnitude-types 上找到。

当我们在 [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 、*用 Pandas 和 Matplotlib* 可视化数据中讨论散点图时，我们被限制为两个变量都是数值；然而，有了`seaborn`，我们有了两种额外的绘图类型，允许我们有一个分类变量和一个数字变量。第一个是`stripplot()`函数，它将点绘制成表示每个类别的条带。第二个是`swarmplot()`函数，我们将在后面看到。

让我们用`stripplot()`创建这个可视化。我们将发生在印尼的地震子集传递给`data`参数，并指定我们希望将`magType`放在*x*-轴(`x`)，将震级放在*y*-轴(`y`)，并根据地震是否伴随海啸(`hue`)来给点着色:

```
>>> sns.stripplot(
...     x='magType', 
...     y='mag', 
...     hue='tsunami',
...     data=quakes.query('parsed_place == "Indonesia"')
... )
```

使用生成的图，我们可以看到所讨论的地震是`mww`列中最高的橙色点(如果不使用提供的 Jupyter 笔记本，不要忘记调用`plt.show()`):

![Figure 6.1 – Seaborn's strip plot
](image/fig_6.1.jpg)

图 6.1-Seaborn 的带状图

正如我们所料，在大多数情况下，海啸是与更高震级的地震一起发生的；然而，由于较低星等的点高度集中，我们无法真正看到所有的点。我们可以尝试调整`jitter`参数，该参数控制添加多少随机噪声到该点以减少重叠，或者调整`alpha`参数以增加透明度，就像我们在上一章所做的那样；幸运的是，还有另一个函数`swarmplot()`，它将尽可能地减少重叠，所以我们将使用它来代替:

```
>>> sns.swarmplot(
...     x='magType', 
...     y='mag', 
...     hue='tsunami',
...     data=quakes.query('parsed_place == "Indonesia"'),
...     size=3.5 # point size
... )
```

**蜂群图**(或蜂群图)还有的额外好处，让我们一瞥可能的分布情况。我们现在可以在`mb`柱的下部看到更多的地震:

![Figure 6.2 – Seaborn's swarm plot
](image/fig_6.2.jpg)

图 6.2-Seaborn 的虫群图

在前一章的*用Pandas*绘图一节中，当我们讨论如何可视化分布时，我们讨论了盒状图。Seaborn 为大型数据集提供了一个增强的箱线图，其中显示了额外的分位数，以获得关于分布形状的更多信息，特别是在尾部。让我们使用增强的箱线图来比较不同震级类型的地震震级，正如我们在 [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 、*使用 Pandas 和 Matplotlib* 可视化数据中所做的那样:

```
>>> sns.boxenplot(
...     x='magType', y='mag', data=quakes[['magType', 'mag']]
... )
>>> plt.title('Comparing earthquake magnitude by magType')
```

这导致了下面的图:

![Figure 6.3 – Seaborn's enhanced box plot
](image/fig_6.3.jpg)

图 6.3-Seaborn 的增强型箱线图

小费

Heike Hofmann、Karen Kafadar 和 Hadley Wickham 的论文*Letter-value plots:box plots for the large data*中介绍了增强的盒图，该论文可在 https://vita.had.co.nz/papers/letter-value-plot.html 的[找到。](https://vita.had.co.nz/papers/letter-value-plot.html)

箱线图对于可视化数据的分位数非常有用，但是我们丢失了关于分布的信息。正如我们所见，增强的箱线图是解决这一问题的一种方法，另一种策略是使用小提琴图，它结合了内核密度估计(对基本分布的估计)和箱线图:

```
>>> fig, axes = plt.subplots(figsize=(10, 5))
>>> sns.violinplot(
...     x='magType', y='mag', data=quakes[['magType', 'mag']], 
...     ax=axes, scale='width' # all violins have same width
... )
>>> plt.title('Comparing earthquake magnitude by magType')
```

方框图部分贯穿每个小提琴图的中心；然后使用方框图作为其 *x* 轴，在两侧绘制**核密度估计值** ( **KDE** )。由于 KDE 是对称的，因此我们可以从箱线图的任一侧读取它:

![Figure 6.4 – Seaborn's violin plot
](image/fig_6.4.jpg)

图 6.4-Seaborn 的小提琴图

`seaborn`文档还根据绘制的数据类型列出了绘制功能；分类图的完整版本可在 https://seaborn.pydata.org/api.html#categorical-plots 的[获得。一定要检查一下`countplot()`和`barplot()`函数，看看我们在上一章用`pandas`创建的条形图上](https://seaborn.pydata.org/api.html#categorical-plots)的变化。

## 相关性和热图

如前所述，让我们学习一种比我们在 [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 、*用 Pandas 和 Matplotlib* 可视化数据更简单的生成热图的方法。我们将再次绘制 OHLC 股票价格、交易量日志以及最高价和最低价(`max_abs_change`)之间的每日差异之间的相关性热图；然而，这一次，我们将使用`seaborn`，它为我们提供了`heatmap()`函数，以一种更简单的方式产生这个可视化:

```
>>> sns.heatmap(
...     fb.sort_index().assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     ).corr(), 
...     annot=True, 
...     center=0, 
...     vmin=-1, 
...     vmax=1
... )
```

小费

在使用`seaborn`时，我们仍然可以使用来自`matplotlib`的函数，比如`plt.savefig()`和`plt.tight_layout()`。注意，如果`plt.tight_layout()`有问题，将`bbox_inches='tight'`改为`plt.savefig()`。

我们传入`center=0`，以便`seaborn`将`0`(无相关性)的值放在它所使用的色图的中心。为了将色标的边界设置为相关系数的边界，我们还需要提供`vmin=-1`和`vmax=1`。请注意，我们还传入了`annot=True`以在每个框中写入相关系数——我们通过一个函数调用就可以在一个图中获得数字数据和视觉数据的好处:

![Figure 6.5 – Seaborn's heatmap
](image/fig_6.5.jpg)

图 6.5-Seaborn 的热图

Seaborn 还为我们提供了`pandas.plotting`模块中提供的`scatter_matrix()`函数的替代函数，称为`pairplot()`。我们可以用它来查看脸书数据中列之间的相关性，作为散点图，而不是热图:

```
>>> sns.pairplot(fb)
```

这一结果使我们很容易理解热图中显示的 OHLC 列之间近乎完美的正相关关系，同时也为我们展示了沿对角线的每一列的直方图:

![Figure 6.6 – Seaborn's pair plot
](image/fig_6.6.jpg)

图 6.6-Seaborn 的配对图

脸书 2018 年下半年的表现明显比上半年差，所以我们可能有兴趣看看数据的分布在今年每个季度是如何变化的。与`pandas.plotting.scatter_matrix()`函数一样，我们可以用`diag_kind`参数指定沿对角线做什么；然而，与`pandas`不同，我们可以使用`hue`参数基于其他数据轻松地给所有东西着色。为此，我们只需添加`quarter`列，然后将其提供给`hue`参数:

```
>>> sns.pairplot(
...     fb.assign(quarter=lambda x: x.index.quarter), 
...     diag_kind='kde', hue='quarter'
... )
```

我们现在可以看到 OHLC 柱的分布如何在第一季度具有较低的标准偏差(以及随后较低的方差),以及股票价格如何在第四季度失去了很多优势(分布向左移动):

![Figure 6.7 – Utilizing the data to determine plot colors
](image/fig_6.7.jpg)

图 6.7–利用数据确定绘图颜色

小费

我们可以也通过`kind='reg'`到`pairplot()`来显示回归线。

如果我们只想比较两个变量，我们可以使用`jointplot()`，它会给我们一个散点图以及每个变量沿侧面的分布。让我们再次看看交易量日志如何与脸书股票的每日最高价和最低价之间的差异相关联，正如我们在 [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 、*用 Pandas 和 Matplotlib* 可视化数据中所做的那样:

```
>>> sns.jointplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     )
... )
```

使用`kind`参数的默认值，我们得到分布的直方图和中心的平面散点图:

![Figure 6.8 – Seaborn's joint plot
](image/fig_6.8.jpg)

图 6.8-Seaborn 的联合图

Seaborn 为`kind`的论点给了我们大量的选择。例如，我们可以使用六边形，因为当我们使用散点图时会有明显的重叠:

```
>>> sns.jointplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     kind='hex',
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     )
... )
```

我们现在可以在左下角看到大量的点:

![Figure 6.9 – Joint plot using hexbins
](image/fig_6.9.jpg)

图 6.9–使用 hexbins 的联合图

查看值的浓度的另一种方式是使用`kind='kde'`，这为我们提供了一个**等高线图**来表示联合密度估计值以及每个变量的 KDEs:

```
>>> sns.jointplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     kind='kde',
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     )
... )
```

等高线图中的每条曲线包含给定密度的点:

![Figure 6.10 – Joint distribution plot
](image/fig_6.10.jpg)

图 6.10-联合分布图

此外，我们可以在中心绘制一个回归图，并获得 kde 以及沿侧边的直方图:

```
>>> sns.jointplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     kind='reg',
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     )
... )
```

这导致通过散点图绘制出一条线性回归线，以及一条以较浅颜色环绕该线的置信带:

![Figure 6.11 – Joint plot with linear regression and KDEs
](image/fig_6.11.jpg)

图 6.11–线性回归和 KDEs 的联合图

这种关系看起来是线性的，但是我们应该查看**残差**来检查。残差是观察值减去使用回归线预测的值。我们可以直接查看使用`kind='resid'`进行的前一次回归产生的残差:

```
>>> sns.jointplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     kind='resid',
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low
...     )
... )
# update y-axis label (discussed next section)
>>> plt.ylabel('residuals')
```

请注意，随着交易量的增加，残差似乎越来越远离零，这可能意味着这不是建立这种关系的正确方式:

![Figure 6.12 – Joint plot showing linear regression residuals
](image/fig_6.12.jpg)

图 6.12-显示线性回归残差的联合图

我们刚刚看到，我们可以使用`jointplot()`得到一个回归图或残差图；很自然地，`seaborn`公开了函数来直接生成这些函数，而不需要创建整个联合绘图的开销。接下来我们来讨论这些。

## 回归图

`regplot()`函数将计算一条回归线并绘制它，而`residplot()`函数将计算回归并仅绘制残差。我们可以为写一个函数来组合这些，但是首先，要做一些设置。

我们的函数将绘制任意两列的所有排列(与组合相反；有排列的顺序问题，比如`(open, close)`不等价于`(close, open)`。这允许我们将每一列视为回归变量和因变量；由于我们不知道关系的方向，所以我们让查看器在调用函数后决定。这将生成许多支线剧情，因此我们将创建一个新的 dataframe，仅包含脸书数据中的几列。

我们将会看到交易量的对数(`log_volume`)和脸书股票最高价和最低价之间的每日差额(`max_abs_change`)。让我们使用`assign()`来创建这些新列，并将它们保存在一个名为`fb_reg_data`的新数据框架中:

```
>>> fb_reg_data = fb.assign(
...     log_volume=np.log(fb.volume), 
...     max_abs_change=fb.high - fb.low
... ).iloc[:,-2:]
```

接下来，我们需要导入`itertools`，它是 Python 标准库(【https://docs.python.org/3/library/itertools.html】)的一部分。在编写绘图函数时，`itertools`会非常有用；它使得为诸如排列、组合和无限循环或重复之类的事情创建有效的迭代器变得非常容易:

```
>>> import itertools
```

**可迭代对象**是可以迭代的对象。当我们开始一个循环时，一个**迭代器**从 iterable 中创建。在每次迭代中，迭代器提供它的下一个值，直到用完为止；这意味着一旦我们完成了一次迭代，所有的条目都没有了，它也不能被重用。迭代器是可迭代的，但不是所有的可迭代的都是迭代器。不是迭代器的可重复使用。

我们在使用`itertools`时得到的迭代器只能通过以下方式使用一次:

```
>>> iterator = itertools.repeat("I'm an iterator", 1)
>>> for i in iterator:
...     print(f'-->{i}')
-->I'm an iterator
>>> print(
...     'This printed once because the iterator '
...     'has been exhausted'
... )
This printed once because the iterator has been exhausted
>>> for i in iterator:
...     print(f'-->{i}')
```

另一方面，列表是一个可迭代的；我们可以写一些东西来循环列表中的所有元素，我们仍然有一个列表供以后重用:

```
>>> iterable = list(itertools.repeat("I'm an iterable", 1))
>>> for i in iterable:
...     print(f'-->{i}')
-->I'm an iterable
>>> print('This prints again because it\'s an iterable:')
This prints again because it's an iterable:
>>> for i in iterable:
...     print(f'-->{i}')
-->I'm an iterable
```

现在我们有了一些关于`itertools`和迭代器的背景知识，让我们为回归和残差置换图编写函数:

```
def reg_resid_plots(data):
    """
    Using `seaborn`, plot the regression and residuals plots 
    side-by-side for every permutation of 2 columns in data.
    Parameters:
        - data: A `pandas.DataFrame` object
    Returns:
        A matplotlib `Axes` object.
    """
    num_cols = data.shape[1]
    permutation_count = num_cols * (num_cols - 1)
    fig, ax = \
        plt.subplots(permutation_count, 2, figsize=(15, 8))
    for (x, y), axes, color in zip(
        itertools.permutations(data.columns, 2), 
        ax,
        itertools.cycle(['royalblue', 'darkorange'])
    ):
        for subplot, func in zip(
 axes, (sns.regplot, sns.residplot)
 ):
            func(x=x, y=y, data=data, ax=subplot, color=color)
            if func == sns.residplot:
                subplot.set_ylabel('residuals')
    return fig.axes
```

在这个函数中，我们可以看到，到目前为止，本章和上一章所涉及的所有材料都汇集在一起；我们计算我们需要多少支线剧情，因为我们将有两个情节为每个排列，我们只需要排列的数量来确定行计数。我们利用了`zip()`函数，它在元组中一次给出来自多个可迭代对象的值，并利用元组解包轻松地迭代排列元组和`Axes`对象的 2D NumPy 数组。花些时间确保你明白这里发生了什么；本章末尾的*延伸阅读*部分也有关于`zip()`和元组解包的资源。

重要说明

如果我们给`zip()`提供不同长度的 iterables，那么我们只会得到与最短长度相等的若干元组。出于这个原因，我们可以使用无限迭代器，比如我们在使用`itertools.repeat()`时得到的那些迭代器，它无限重复相同的值(当我们没有指定重复值的次数时)，以及`itertools.cycle()`，它在所有提供的值之间无限循环。

调用我们的函数很容易，只有一个参数:

```
>>> from viz import reg_resid_plots
>>> reg_resid_plots(fb_reg_data)
```

第一行子集是我们之前在联合图中看到的，第二行是翻转`x`和`y`变量时的回归:

![Figure 6.13 – Seaborn linear regression and residual plots
](image/fig_6.13.jpg)

图 6.13–Seaborn 线性回归和残差图

小费

`regplot()`函数分别通过`order`和`logistic`参数支持多项式和逻辑回归。

Seaborn 还使得用`lmplot()`跨我们数据的不同子集绘制回归图变得容易。我们可以用`hue`、`col`和`row`来分割我们的回归图，它们将根据给定列中的值来着色，分别为每个值创建一个新列，为每个值创建一个新行。

我们看到脸书的表现在一年的每个季度都不同，所以让我们用脸书的股票数据计算每个季度的回归，使用交易量和最高价与最低价之间的每日差异，看看这种关系是否也会改变:

```
>>> sns.lmplot(
...     x='log_volume', 
...     y='max_abs_change', 
...     col='quarter',
...     data=fb.assign(
...         log_volume=np.log(fb.volume), 
...         max_abs_change=fb.high - fb.low,
...         quarter=lambda x: x.index.quarter
...     )
... )
```

请注意，第四季度的回归线比前几个季度的斜率更陡:

![Figure 6.14 – Seaborn linear regression plots with subsets
](image/fig_6.14.jpg)

图 6.14–带有子集的 Seaborn 线性回归图

注意运行`lmplot()`的结果是一个`FacetGrid`对象，这是`seaborn`的一个强大特性。现在我们来讨论一下，如何用里面的任何情节直接制作这些。

## 刻面

刻面允许我们跨支线绘制我们的数据的子集(刻面)。我们已经看到了一些`seaborn`函数的结果；然而，我们可以很容易地使他们为自己使用任何绘图功能。让我们创建一个可视化图形，以便根据是否发生海啸来比较印度尼西亚和巴布亚新几内亚的地震震级分布。

首先，我们用将要使用的数据创建一个`FacetGrid`对象，并用`row`和`col`参数定义它如何成为子集:

```
>>> g = sns.FacetGrid(
...     quakes.query(
...         'parsed_place.isin('
...         '["Indonesia", "Papua New Guinea"]) '
...         'and magType == "mb"'
...     ),   
...     row='tsunami',
...     col='parsed_place',
...     height=4
... )
```

然后，我们使用`FacetGrid.map()`方法在每个子集上运行绘图函数，传递任何必要的参数。我们将使用`sns.histplot()`函数为位置和海啸数据子集制作带有 kde 的直方图:

```
>>> g = g.map(sns.histplot, 'mag', kde=True)
```

对于这两个位置，我们可以看到，当地震震级为 5.0 或更大时，就会发生海啸:

![Figure 6.15 – Plotting with facet grids
](image/fig_6.15.jpg)

图 6.15–用小平面网格绘图

我们对`seaborn`的绘图能力的讨论到此结束。然而，我鼓励你检查一下 API(【https://seaborn.pydata.org/api.html】T2)来看看额外的功能。此外，当希望绘制一些数据时，一定要参考*附录*中的*选择合适的可视化*部分。

# 用 matplotlib 格式化绘图

使我们的可视化形象化的很大一部分是选择正确的绘图类型，并对它们进行很好的标记，以便它们易于理解。通过仔细调整我们可视化的最终外观，我们使它们更容易阅读和理解。

现在让我们转到`2-formatting_plots.ipynb`笔记本，运行安装代码以导入我们需要的包，并读入脸书股票数据和新冠肺炎每日新闻案例数据:

```
>>> %matplotlib inline
>>> import matplotlib.pyplot as plt
>>> import numpy as np
>>> import pandas as pd 
>>> fb = pd.read_csv(
...     'data/fb_stock_prices_2018.csv', 
...     index_col='date', 
...     parse_dates=True
... ) 
>>> covid = pd.read_csv('data/covid19_cases.csv').assign(
...     date=lambda x: \
...         pd.to_datetime(x.dateRep, format='%d/%m/%Y')
... ).set_index('date').replace(
...     'United_States_of_America', 'USA'
... ).sort_index()['2020-01-18':'2020-09-18']
```

在接下来的几节中，我们将讨论如何向图中添加标题、轴标签和图例，以及如何自定义轴。请注意，本节中的所有内容都需要在运行`plt.show()`之前调用，或者如果使用`%matplotlib inline` magic 命令，则需要在同一个 Jupyter 笔记本单元中调用。

## 标题和标签

到目前为止，我们创建的一些可视化没有标题或轴标签。我们知道图中发生了什么，但是如果我们将它们展示给其他人，可能会有些混乱。明确我们的标签和标题是一个好习惯。

我们看到，当使用`pandas`绘图时，我们可以通过将`title`参数传递给`plot()`方法来添加标题，但是我们也可以使用`plt.title()`通过`matplotlib`来这样做。注意，我们可以将`x` / `y`值传递给`plt.title()`来控制文本的位置。我们也可以改变字体和大小。给我们的轴贴标签也一样容易；我们可以用`plt.xlabel()`和`plt.ylabel()`。让我们画出脸书的收盘价，并用`matplotlib`标记一切:

```
>>> fb.close.plot()
>>> plt.title('FB Closing Price')
>>> plt.xlabel('date')
>>> plt.ylabel('price ($)')
```

这导致了下面的图:

![Figure 6.16 – Labeling plots with matplotlib
](image/fig_6.16.jpg)

图 6.16–用 matplotlib 标记图

当处理支线剧情时，我们必须采取不同的方法。为了直接看到这一点，让我们制作脸书股票的 OHLC 数据的支线剧情，并用`plt.title()`给整个剧情一个标题，用`plt.ylabel()`给每个支线剧情的 *y* 轴一个标签:

```
>>> fb.iloc[:,:4]\
...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))
>>> plt.title('Facebook 2018 Stock Data')
>>> plt.ylabel('price ($)')
```

使用`plt.title()`将标题放在最后一个副情节上，而不是像我们预期的那样作为整个情节的标题。同样的事情也发生在 *y* 轴标签上:

![Figure 6.17 – Labeling subplots can be confusing
](image/fig_6.17.jpg)

图 6.17-给支线剧情加标签可能会令人困惑

在支线剧情的情况下，我们想给整个人物一个标题；因此，我们用`plt.suptitle()`来代替。相反，我们想给每个子情节一个*y*-轴标签，所以我们对调用`plot()`返回的每个`Axes`对象使用`set_ylabel()`方法。注意，`Axes`对象是在一个与子情节布局维数相同的 NumPy 数组中返回的，所以为了更容易迭代，我们调用`flatten()`:

```
>>> axes = fb.iloc[:,:4]\
...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))
>>> plt.suptitle('Facebook 2018 Stock Data')
>>> for ax in axes.flatten():
...     ax.set_ylabel('price ($)')
```

这个产生了整个剧情的标题和每个支线剧情的 *y* 轴标签:

![Figure 6.18 – Labeling subplots
](image/fig_6.18.jpg)

图 6.18–标记子情节

请注意，`Figure`类也有一个`suptitle()`方法，`Axes`类的`set()`方法让我们在一次调用中标记轴、给图加标题等等，例如，`set(xlabel='…', ylabel='…', title='…', …)`。根据我们要做的事情，我们可能需要直接调用`Figure`或`Axes`对象上的方法，所以了解它们很重要。

## 传说

Matplotlib 使得可以通过`plt.legend()`函数和`Axes.legend()`方法控制图例的许多方面。例如，我们可以指定图例的位置和图例的格式，包括自定义字体、颜色等等。当绘图最初没有图例时，`plt.legend()`函数和`Axes.legend()`方法也可以用来显示图例。以下是一些常用的参数示例:

![Figure 6.19 – Helpful parameters for legend formatting
](image/fig_6.19.jpg)

图 6.19–图例格式化的有用参数

图例将使用绘制的每个对象的标签。如果我们不想让某个东西出现，我们可以让它的标签为空字符串。然而，如果我们只是想改变某些东西的显示方式，我们可以通过`label`参数传递它的显示名称。让我们绘制脸书股票的收盘价和 20 天移动平均线，使用`label`参数为图例提供一个描述性名称:

```
>>> fb.assign(
...     ma=lambda x: x.close.rolling(20).mean()
... ).plot(
...     y=['close', 'ma'], 
...     title='FB closing price in 2018',
...     label=['closing price', '20D moving average'],
...     style=['-', '--']
... )
>>> plt.legend(loc='lower left')
>>> plt.ylabel('price ($)')
```

默认情况下，`matplotlib`试图找到绘图的最佳位置，但有时它会覆盖部分绘图，如本例所示。因此，我们选择将图例放置在图的左下角。注意，图例中的文本是我们在`label`参数中提供给`plot()`的文本:

![Figure 6.20 – Moving the legend
](image/fig_6.20.jpg)

图 6.20–移动图例

注意，我们向参数`loc`传递了一个字符串来指定图例的位置；我们还可以选择将代码作为整数或元组传递给`(x, y)`坐标，以绘制图例框的左下角。下表包含可能的位置字符串:

![Figure 6.21 – Common legend locations
](image/fig_6.21.jpg)

图 6.21–常见图例位置

现在让我们来看看用`framealpha`、`ncol`和`title`参数来设计图例的样式。我们将绘制从 2020 年 1 月 18 日到 2020 年 9 月 18 日的 8 个月期间，巴西、中国、义大利、西班牙和美国每日新增新冠肺炎病例的百分比。此外，我们将删除图的顶部和右侧脊线，使其看起来更清晰:

```
>>> new_cases = covid.reset_index().pivot(
...     index='date',
...     columns='countriesAndTerritories',
...     values='cases'
... ).fillna(0)
>>> pct_new_cases = new_cases.apply(
...     lambda x: x / new_cases.apply('sum', axis=1), axis=0
... )[
...     ['Italy', 'China', 'Spain', 'USA', 'India', 'Brazil']
... ].sort_index(axis=1).fillna(0)
>>> ax = pct_new_cases.plot(
...     figsize=(12, 7),
...     style=['-'] * 3 + ['--', ':', '-.'],
...     title='Percentage of the World\'s New COVID-19 Cases'
...           '\n(source: ECDC)'
... )
>>> ax.legend(title='Country', framealpha=0.5, ncol=2)
>>> ax.set_xlabel('')
>>> ax.set_ylabel('percentage of the world\'s COVID-19 cases')
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

我们的图例整齐地排列成两列，并包含一个标题。我们还增加了图例边框的透明度:

![Figure 6.22 – Formatting the legend
](image/fig_6.22.jpg)

图 6.22–格式化图例

小费

不要试图记住所有可用的选项而不知所措。如果我们不试图学习每一个可能的定制，而是在需要时查找与我们脑海中的可视化相匹配的功能，这就更容易了。

## 格式化坐标轴

回到 [*第 1 章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015) ，*数据分析简介*，我们讨论了如果不小心，轴限值会如何导致误导图。当使用来自`pandas`的`plot()`方法时，我们可以选择将其作为元组传递给`xlim` / `ylim`参数。或者，通过`matplotlib`，我们可以用`plt.xlim()` / `plt.ylim()`功能或`set_xlim()` / `set_ylim()`方法在`Axes`对象上调整每个轴的极限。我们分别传递最小值和最大值；如果我们想保留自动生成的内容，我们可以传入`None`。让我们修改之前绘制的每个国家全球每日新增新冠肺炎病例百分比图，使 *y* 轴从零开始:

```
>>> ax = pct_new_cases.plot(
...     figsize=(12, 7),
...     style=['-'] * 3 + ['--', ':', '-.'],
...     title='Percentage of the World\'s New COVID-19 Cases'
...           '\n(source: ECDC)'
... )
>>> ax.legend(framealpha=0.5, ncol=2)
>>> ax.set_xlabel('')
>>> ax.set_ylabel('percentage of the world\'s COVID-19 cases')
>>> ax.set_ylim(0, None)
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

注意y 轴现在从零开始:

![Figure 6.23 – Updating axis limits with matplotlib
](image/fig_6.23.jpg)

图 6.23–用 matplotlib 更新轴限值

如果我们想改变轴的刻度，我们可以使用`plt.xscale()` / `plt.yscale()`并传递我们想要的刻度类型。因此，例如，`plt.yscale('log')`将使用对数刻度作为 *y* 轴；我们在前一章中已经看到了如何用`pandas`来实现这一点。

我们还可以通过将刻度位置和标签传递给`plt.xticks()`或`plt.yticks()`来控制显示哪些刻度线以及它们的标签。注意，我们也可以调用这些函数来获取刻度位置和标签。例如，由于我们的数据在每月 18 日开始和结束，让我们将前面图中的刻度线移动到每月 18 日，然后相应地标记刻度:

```
>>> ax = pct_new_cases.plot(
...     figsize=(12, 7),
...     style=['-'] * 3 + ['--', ':', '-.'],
...     title='Percentage of the World\'s New COVID-19 Cases'
...           '\n(source: ECDC)'
... )
>>> tick_locs = covid.index[covid.index.day == 18].unique()
>>> tick_labels = \
...     [loc.strftime('%b %d\n%Y') for loc in tick_locs]
>>> plt.xticks(tick_locs, tick_labels)
>>> ax.legend(framealpha=0.5, ncol=2)
>>> ax.set_xlabel('')
>>> ax.set_ylabel('percentage of the world\'s COVID-19 cases')
>>> ax.set_ylim(0, None)
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

移动刻度后，我们在图中的第一个数据点(2020 年 1 月 18 日)和最后一个数据点(2020 年 9 月 18 日)上有一个刻度标签:

![Figure 6.24 – Editing tick labels
](image/fig_6.24.jpg)

图 6.24–编辑刻度标签

我们目前将百分比表示为小数，但我们可能希望使用百分号来格式化标签。注意，不需要使用`plt.yticks()`函数来这样做；相反，我们可以使用来自`matplotlib.ticker`模块的`PercentFormatter`类:

```
>>> from matplotlib.ticker import PercentFormatter
>>> ax = pct_new_cases.plot(
...     figsize=(12, 7),
...     style=['-'] * 3 + ['--', ':', '-.'],
...     title='Percentage of the World\'s New COVID-19 Cases'
...           '\n(source: ECDC)'
... )
>>> tick_locs = covid.index[covid.index.day == 18].unique()
>>> tick_labels = \
...     [loc.strftime('%b %d\n%Y') for loc in tick_locs]
>>> plt.xticks(tick_locs, tick_labels)
>>> ax.legend(framealpha=0.5, ncol=2)
>>> ax.set_xlabel('')
>>> ax.set_ylabel('percentage of the world\'s COVID-19 cases')
>>> ax.set_ylim(0, None)
>>> ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

通过指定`xmax=1`，我们用表示我们的值应该除以 1(因为它们已经是百分比)，然后乘以 100 并附加百分号。这导致沿着 *y* 轴的百分比:

![Figure 6.25 – Formatting tick labels as percentages
](image/fig_6.25.jpg)

图 6.25–将刻度标签格式化为百分比

另一个有用的格式化程序是`EngFormatter`类，它会使用**工程符号**自动将数字格式化为千、百万等等。让我们用这个来绘制每个大陆累计的新冠肺炎病例数，以百万计:

```
>>> from matplotlib.ticker import EngFormatter
>>> ax = covid.query('continentExp != "Other"').groupby([
...     'continentExp', pd.Grouper(freq='1D')
... ]).cases.sum().unstack(0).apply('cumsum').plot(
...     style=['-', '-', '--', ':', '-.'],
...     title='Cumulative COVID-19 Cases per Continent'
...           '\n(source: ECDC)'
... )
>>> ax.legend(title='', loc='center left')
>>> ax.set(xlabel='', ylabel='total COVID-19 cases')
>>> ax.yaxis.set_major_formatter(EngFormatter())
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

注意，我们不需要将的累积案例数除以 100 万来获得这些数字——我们传递给`set_major_formatter()`的`EngFormatter`对象根据数据自动计算出它应该使用数百万(M ):

![Figure 6.26 – Formatting tick labels with engineering notation
](image/fig_6.26.jpg)

图 6.26–用工程符号格式化记号标签

`PercentFormatter`和`EngFormatter`类都格式化刻度标签，但是有时我们想要改变刻度的位置而不是格式化它们。一种方法是使用`MultipleLocator`类，这使得我们可以很容易地将刻度放在我们选择的数字的倍数上。为了说明我们如何利用这一点，让我们来看看从 2020 年 4 月 18 日到 2020 年 9 月 18 日新西兰每天的新新冠肺炎病例:

```
>>> ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(
...     title='Daily new COVID-19 cases in New Zealand'
...           '\n(source: ECDC)'
... )
>>> ax.set(xlabel='', ylabel='new COVID-19 cases')
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

在我们没有干预分笔成交点位置的情况下，`matplotlib`以 2.5 的增量显示分笔成交点。我们知道没有半箱这样的东西，所以只显示整数分笔成交点的数据更有意义:

![Figure 6.27 – Default tick locations
](image/fig_6.27.jpg)

图 6.27–默认刻度位置

让我们通过使用`MultipleLocator`类来解决这个问题。这里，我们不是格式化轴标签，而是控制显示哪些标签；出于这个原因，我们必须调用`set_major_locator()`方法，而不是`set_major_formatter()`:

```
>>> from matplotlib.ticker import MultipleLocator
>>> ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(
...     title='Daily new COVID-19 cases in New Zealand'
...           '\n(source: ECDC)'
... )
>>> ax.set(xlabel='', ylabel='new COVID-19 cases') 
>>> ax.yaxis.set_major_locator(MultipleLocator(base=3))
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

自从我们传入了`base=3`，我们的 *y* 轴现在包含了三个增量的整数:

![Figure 6.28 – Using integer tick locations
](image/fig_6.28.jpg)

图 6.28–使用整数刻度位置

这些只是`matplotlib.ticker`模块提供的三个特性，所以我强烈建议您查阅文档以获得更多信息。本章末尾的*延伸阅读*部分也有链接。

# 定制可视化

到目前为止，我们学习的所有创建数据可视化的代码都是为了制作可视化本身。现在我们有了一个强大的基础，我们准备好学习如何添加参考线，控制颜色和纹理，并包括注释。

在`3-customizing_visualizations.ipynb`笔记本中，让我们处理我们的导入并读取脸书股票价格和地震数据集:

```
>>> %matplotlib inline
>>> import matplotlib.pyplot as plt
>>> import pandas as pd
>>> fb = pd.read_csv(
...     'data/fb_stock_prices_2018.csv', 
...     index_col='date', 
...     parse_dates=True
... )
>>> quakes = pd.read_csv('data/earthquakes.csv')
```

小费

改变创建图的风格是改变其外观和感觉的简单方法，无需单独设置每个方面。要设置`seaborn`的样式，请使用`sns.set_style()`。通过`matplotlib`，我们可以使用`plt.style.use()`来指定我们想要使用的样式表。这些将用于在该会话中创建的所有可视化。相反，如果我们只希望它用于一个单独的情节，我们可以使用`sns.set_context()`或`plt.style.context()`。通过查看`plt.style.available`中的值，可以在上述函数和`matplotlib`的文档中找到`seaborn`的可用样式。

## 添加参考线

很多时候，我们想把注意力吸引到我们图上的一个特定值，也许是一个边界或转折点。我们可能感兴趣的是这条线是交叉的还是作为一个隔板。在金融学中，水平参考线可以画在股票价格的线图上，标记支撑和阻力。

**支撑位**是下跌趋势有望逆转的价格水平，因为股票现在处于更吸引买家购买的价格水平，推动价格上涨并远离该点。另一方面，**阻力**是一个价格水平，在该价格水平上，上升趋势预计会逆转，因为该价格是一个有吸引力的卖点；因此，价格下跌，远离这一点。当然，这并不是说这些水平不会被超越。既然我们有脸书股票数据，让我们把支撑线和阻力线加到收盘价的线图上。

重要说明

如何计算支撑和阻力超出了本章的范围，但是第七章[](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)*、*金融分析-比特币和股票市场*，将包括一些使用支点计算这些的代码。此外，请务必查看*延伸阅读*部分，以获得关于支撑和阻力的更深入介绍。*

 *我们的两条横向参考线将位于 124.46 美元的支撑和 138.53 美元的阻力。这两个数字都是使用`stock_analysis`包得出的，我们将在 [*第 7 章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146) 、*金融分析——比特币和股票市场*中构建这个包。我们只需要创建一个`StockAnalyzer`类的实例来计算这些指标:

```
>>> from stock_analysis import StockAnalyzer
>>> fb_analyzer = StockAnalyzer(fb)
>>> support, resistance = (
...     getattr(fb_analyzer, stat)(level=3)
...     for stat in ['support', 'resistance']
... )
>>> support, resistance
(124.4566666666667, 138.5266666666667)
```

我们将使用`plt.axhline()`函数来完成这个任务，但是请注意，这也适用于`Axes`对象。请记住，我们提供给`label`参数的文本将被填充到图例中:

```
>>> fb.close['2018-12']\
...     .plot(title='FB Closing Price December 2018')
>>> plt.axhline(
...     y=resistance, color='r', linestyle='--',
...     label=f'resistance (${resistance:,.2f})'
... )
>>> plt.axhline(
...     y=support, color='g', linestyle='--',
...     label=f'support (${support:,.2f})'
... )
>>> plt.ylabel('price ($)')
>>> plt.legend()
```

我们应该已经熟悉了前面章节中的 f-string 格式，但是请注意这里变量名后面的附加文本(`:,.2f`)。支撑和阻力分别作为浮点数存储在`support`和`resistance`变量中。冒号(`:`)在**格式说明符**(通常写成`format_spec`)之前，它告诉 Python 如何格式化那个变量；在这种情况下，我们将其格式化为十进制(`f`)，用逗号作为千位分隔符(`,`)，小数点后有两位精度(`.2`)。这也适用于`format()`方法，在这种情况下，它看起来像`'{:,.2f}'.format(resistance)`。这种格式在我们的绘图中形成了一个信息丰富的图例:

![Figure 6.29 – Creating horizontal reference lines with matplotlib
](image/fig_6.29.jpg)

图 6.29–使用 matplotlib 创建水平参考线

重要说明

那些拥有个人投资账户的人可能会在那里找到一些关于支持和阻力的文献，因为这些文献有助于了解目标价格的可行性。此外，这些参考线可以被交易者用来分析股票的势头，并决定是否该买入/卖出股票。

回到地震数据，让我们用`plt.axvline()`画出垂直参考线，表示印度尼西亚地震震级分布平均值的标准偏差数。位于 GitHub 库的`viz.py`模块中的`std_from_mean_kde()`函数使用`itertools`来轻松组合我们需要绘制的颜色和值:

```
import itertools
def std_from_mean_kde(data):
    """
    Plot the KDE along with vertical reference lines
    for each standard deviation from the mean.
    Parameters:
        - data: `pandas.Series` with numeric data
    Returns:
        Matplotlib `Axes` object.
    """
    mean_mag, std_mean = data.mean(), data.std()
    ax = data.plot(kind='kde')
    ax.axvline(mean_mag, color='b', alpha=0.2, label='mean')
    colors = ['green', 'orange', 'red']
    multipliers = [1, 2, 3]
    signs = ['-', '+']
    linestyles = [':', '-.', '--']
    for sign, (color, multiplier, style) in itertools.product(
        signs, zip(colors, multipliers, linestyles)
    ):
        adjustment = multiplier * std_mean
        if sign == '-':
            value = mean_mag – adjustment
            label = '{} {}{}{}'.format(
                r'$\mu$', r'$\pm$', multiplier, r'$\sigma$'
            )
        else:
            value = mean_mag + adjustment
            label = None # label each color only once
        ax.axvline(
            value, color=color, linestyle=style, 
            label=label, alpha=0.5
        )
    ax.legend()
    return ax
```

来自`itertools`的`product()`函数将给出任意数量的可重复项的所有组合。这里，我们压缩了颜色、乘数和线条样式，因为我们总是希望乘数为 1 的是绿色虚线；乘数为 2 的橙色点划线；红色的虚线代表乘数 3。当`product()`使用这些元组时，我们得到所有东西的正负符号组合。为了让我们的图例不至于太拥挤，我们只在使用标志时标注一次每种颜色。因为我们在每次迭代中都有一个字符串和一个元组的组合，所以我们在我们的`for`语句中解包元组以便于使用。

小费

如果我们遵循某种模式，我们可以使用 LaTeX 数学符号(【https://www.latex-project.org/】)来标记我们的图。首先，我们必须在字符串前面加上`r`字符，将它标记为`raw`。然后，我们必须用`$`符号将乳胶圈起来。例如，我们在前面的代码中使用`r'$\mu$'`代表希腊字母μ。

让我们使用`std_from_mean_kde()`函数来查看印度尼西亚地震震级估计分布的哪些部分在平均值的一个、两个或三个标准差内:

```
>>> from viz import std_from_mean_kde
>>> ax = std_from_mean_kde(
...     quakes.query(
...         'magType == "mb" and parsed_place == "Indonesia"'
...     ).mag
... )
>>> ax.set_title('mb magnitude distribution in Indonesia')
>>> ax.set_xlabel('mb earthquake magnitude')
```

请注意，KDE 是右偏的，它在右侧有一个较长的尾部，平均值在众数的右侧:

![Figure 6.30 – Including vertical reference lines
](image/fig_6.30.jpg)

图 6.30–包括垂直参考线

小费

要制作任意斜率的直线，只需使用同一个`Axes`对象将直线的端点作为两个`x`值和两个`y`值(例如，`[0, 2]`和`[2, 0]`)传递给`plt.plot()`。对于非直线，`np.linspace()`可用于在`[start, stop)`上创建一系列均匀间隔的点，这些点可用于`x`值和计算`y`值。提醒一下，当指定一个范围时，方括号表示包含两个端点，圆括号表示不包含端点，所以[0，1]从 0 到尽可能接近 1，而不等于 1。如果我们不命名存储桶，我们会在使用`pd.cut()`和`pd.qcut()`时看到这些。

## 阴影区域

在某些情况下，参考线本身并不那么有趣，但两者之间的区域很有趣；为此，我们有`axvspan()`和`axhspan()`。让我们再来看看脸书股票收盘价的支撑和阻力。我们可以使用`axhspan()`来给介于两者之间的区域加阴影:

```
>>> ax = fb.close.plot(title='FB Closing Price')
>>> ax.axhspan(support, resistance, alpha=0.2)
>>> plt.ylabel('Price ($)')
```

注意阴影区域的颜色是由`facecolor`参数决定的。对于本例，我们接受默认值:

![Figure 6.31 – Adding a horizontal shaded region
](image/fig_6.31.jpg)

图 6.31–添加水平阴影区域

当我们对两条曲线之间的区域感兴趣时，我们可以使用`plt.fill_between()`和`plt.fill_betweenx()`函数。`plt.fill_between()`函数接受一组`x`值和两组`y`值；如果我们要求相反，我们可以使用`plt.fill_betweenx()`。让我们用`plt.fill_between()`对第四季度每天脸书的高价位和低价位之间的区域进行着色:

```
>>> fb_q4 = fb.loc['2018-Q4']
>>> plt.fill_between(fb_q4.index, fb_q4.high, fb_q4.low)
>>> plt.xticks([
...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'
... ])
>>> plt.xlabel('date')
>>> plt.ylabel('price ($)')
>>> plt.title(
...     'FB differential between high and low price Q4 2018'
... )
```

这让我们对某一天的价格变化有了更好的了解；垂直距离越高，波动越大:

![Figure 6.32 – Shading between two curves
](image/fig_6.32.jpg)

图 6.32–两条曲线之间的阴影

通过向`where`参数提供布尔掩码，我们可以指定何时填充曲线之间的区域。让我们只填写上一个示例中的十二月。我们将在整个时间段内为高价格曲线和低价格曲线添加虚线，以查看发生了什么:

```
>>> fb_q4 = fb.loc['2018-Q4']
>>> plt.fill_between(
...     fb_q4.index, fb_q4.high, fb_q4.low, 
...     where=fb_q4.index.month == 12, 
...     color='khaki', label='December differential'
... )
>>> plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')
>>> plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low') 
>>> plt.xticks([
...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'
... ])
>>> plt.xlabel('date')
>>> plt.ylabel('price ($)')
>>> plt.legend()
>>> plt.title(
...     'FB differential between high and low price Q4 2018'
... )
```

这导致了下面的图:

![Figure 6.33 – Selectively shading between two curves
](image/fig_6.33.jpg)

图 6.33–两条曲线之间的选择性阴影

通过参考线和阴影区域，我们能够引起对某些区域的注意，甚至可以在图例中对它们进行标注，但是我们受限于可以用来解释它们的文本。现在让我们讨论如何为附加上下文注释我们的情节。

## 注释

我们经常会发现需要在我们的可视化中注释特定的点，要么指出事件，比如脸书的股票价格因某些新闻报道而下跌的日子，要么标记对比较重要的值。例如，让我们使用`plt.annotate()`函数来标记支撑和阻力:

```
>>> ax = fb.close.plot(
...     title='FB Closing Price 2018',
...     figsize=(15, 3)
... )
>>> ax.set_ylabel('price ($)')
>>> ax.axhspan(support, resistance, alpha=0.2)
>>> plt.annotate(
...     f'support\n(${support:,.2f})',
...     xy=('2018-12-31', support),
...     xytext=('2019-01-21', support),
...     arrowprops={'arrowstyle': '->'}
... )
>>> plt.annotate(
...     f'resistance\n(${resistance:,.2f})',
...     xy=('2018-12-23', resistance)
... ) 
>>> for spine in ['top', 'right']:
...     ax.spines[spine].set_visible(False)
```

注意注释是不同的；当我们注释阻力时，我们只提供了注释的文本和用`xy`参数注释的点的坐标。然而，当我们注释支持时，我们也为`xytext`和`arrowprops`参数提供了值；这允许我们将文本放在值出现的地方之外的地方，并添加一个箭头来指示它出现的位置。通过这样做，我们可以避免用我们的标签掩盖最近几天的数据:

![Figure 6.34 – Including annotations
](image/fig_6.34.jpg)

图 6.34–包括注释

`arrowprops`参数给了我们很多我们想要的箭头类型的定制，尽管可能很难做到完美。举个例子，让我们用百分比跌幅来注释 7 月份脸书价格的大幅下跌:

```
>>> close_price = fb.loc['2018-07-25', 'close']
>>> open_price = fb.loc['2018-07-26', 'open']
>>> pct_drop = (open_price - close_price) / close_price
>>> fb.close.plot(title='FB Closing Price 2018', alpha=0.5)
>>> plt.annotate(
...     f'{pct_drop:.2%}', va='center',
...     xy=('2018-07-27', (open_price + close_price) / 2),
...     xytext=('2018-08-20', (open_price + close_price) / 2),
...     arrowprops=dict(arrowstyle='-[,widthB=4.0,lengthB=0.2')
... )
>>> plt.ylabel('price ($)')
```

注意，我们能够通过在 f 字符串的格式说明符中使用`.2%`将`pct_drop`变量格式化为具有两位精度的百分比。此外，通过指定`va='center'`，我们告诉`matplotlib`在箭头中间垂直居中我们的注释:

![Figure 6.35 – Customizing the annotation's arrow
](image/fig_6.35.jpg)

图 6.35–定制注释箭头

Matplotlib 提供了很大的灵活性来定制这些注释——我们可以传递`matplotlib`中的`Text`类支持的任何选项([https://matplotlib . org/API/text _ API . html # matplotlib . text . text](https://matplotlib.org/api/text_api.html#matplotlib.text.Text))。要改变颜色，只需在`color`参数中传递想要的颜色。我们还可以分别通过`fontsize`、`fontweight`、`fontfamily`和`fontstyle`参数来控制字体大小、粗细、字体系列和样式。

## 颜色

为了一致性，我们制作的可视化效果应该坚持一种配色方案。公司和学术机构通常都有定制的调色板用于演示。我们也可以很容易地在可视化中采用相同的调色板。

到目前为止，我们要么用它们的单个字符名称为`color`参数提供颜色，比如用`'b'`代表蓝色，`'k'`代表黑色，要么用它们的名称(`'blue'`或`'black'`)。我们也看到过`matplotlib`有很多颜色可以通过名字指定；完整列表可在 https://matplotlib.org/examples/color/named_colors.html[的文档中找到。](https://matplotlib.org/examples/color/named_colors.html)

重要说明

请记住，如果我们用`style`参数提供一种颜色，我们只能使用具有单个字符缩写的颜色。

另外，我们可以为我们想要的颜色提供一个十六进制代码；那些过去使用过 HTML 或 CSS 的人无疑会对它们很熟悉，因为它们是指定确切颜色的一种方式(不管不同地方如何称呼它)。对于那些不熟悉十六进制颜色代码的人来说，它指定了用于在`#RRGGBB`格式中产生所讨论的颜色的红色、绿色和蓝色的数量。黑色是`#000000`，白色是`#FFFFFF`(不区分大小写)。这可能会令人困惑，因为`F`绝对不是一个数字；不过这些都是十六进制数(基数 16，不是我们传统使用的基数 10)，其中`0-9`还是代表`0-9`，但是`A-F`代表`10-15`。

Matplotlib 接受十六进制代码作为参数`color`的字符串。为了说明这一点，让我们画出脸书在`#8000FF`的开盘价:

```
>>> fb.plot(
...     y='open',
...     figsize=(5, 3),
...     color='#8000FF',
...     legend=False,
...     title='Evolution of FB Opening Price in 2018'
... )
>>> plt.ylabel('price ($)')
```

这会产生一个紫色线图:

![Figure 6.36 – Changing line color
](image/fig_6.36.jpg)

图 6.36–改变线条颜色

或者，可以给我们 RGB 值或**红、绿、蓝、阿尔法** ( **RGBA** )值，在这种情况下，我们可以将值作为元组传递给`color`参数。如果我们不提供 alpha，它将默认为`1`表示不透明。这里需要注意的一点是，虽然我们会发现这些数字出现在范围[0，255]内，但是`matplotlib`要求它们在范围[0，1]内，所以我们必须将每个数字除以 255。除了我们使用 RGB 元组而不是十六进制代码之外，以下代码与前面的示例等效:

```
fb.plot(
    y='open',
    figsize=(5, 3),
    color=(128 / 255, 0, 1),
    legend=False,
    title='Evolution of FB Opening Price in 2018'
)
plt.ylabel('price ($)')
```

在前一章中，我们看到了几个例子，在这些例子中，我们需要用许多不同的颜色来绘制不同的数据，但是这些颜色从何而来呢？嗯，`matplotlib`有许多用于此目的的色彩映射表。

### 彩色地图

不需要预先指定我们想要使用的所有颜色，`matplotlib`可以获取一个颜色图并在那里循环显示颜色。当我们在前一章讨论热图时，我们考虑了为给定的任务使用正确类别的色图的重要性。有三种类型的色彩映射表，每种都有自己的用途，如下表所示:

![Figure 6.37 – Types of colormaps
](image/fig_6.37.jpg)

图 6.37–色彩映射表的类型

小费

在[https://www.color-hex.com/](https://www.color-hex.com/)通过名称、十六进制和 RGB 值浏览颜色，并在[https://matplotlib . org/gallery/color/colormap _ reference . html](https://matplotlib.org/gallery/color/colormap_reference.html)找到彩色地图的完整色谱。

在 Python 中，我们可以通过运行以下命令获得所有可用色彩映射表的列表:

```
>>> from matplotlib import cm
>>> cm.datad.keys()
dict_keys(['Blues', 'BrBG', 'BuGn', 'BuPu', 'CMRmap', 'GnBu', 
           'Greens', 'Greys', 'OrRd', 'Oranges', 'PRGn', 
           'PiYG', 'PuBu', 'PuBuGn', 'PuOr', 'PuRd', 'Purples', 
           'RdBu', 'RdGy', 'RdPu', 'RdYlBu', 'RdYlGn', 
           'Reds', ..., 'Blues_r', 'BrBG_r', 'BuGn_r', ...])
```

请注意，有些色彩映射表出现了两次，其中一次出现的顺序相反，由名称上的`_r`后缀表示。这非常有帮助，因为我们不必反转数据来将值映射到我们想要的颜色。Pandas 接受这些颜色图作为字符串或带有`plot()`方法的`colormap`参数的`matplotlib`颜色图，这意味着我们可以传入`'coolwarm_r'`、`cm.get_cmap('coolwarm_r')`或`cm.coolwarm_r`并得到相同的结果。

让我们用`coolwarm_r`色图来显示脸书股票的收盘价如何在 20 天滚动最低价和最高价之间波动:

```
>>> ax = fb.assign(
...     rolling_min=lambda x: x.low.rolling(20).min(),
...     rolling_max=lambda x: x.high.rolling(20).max()
... ).plot(
...     y=['rolling_max', 'rolling_min'], 
...     colormap='coolwarm_r', 
...     label=['20D rolling max', '20D rolling min'],
...     style=[':', '--'],
...     figsize=(12, 3),
...     title='FB closing price in 2018 oscillating between '
...           '20-day rolling minimum and maximum price'
... )
>>> ax.plot(
...     fb.close, 'purple', alpha=0.25, label='closing price'
... )
>>> plt.legend()
>>> plt.ylabel('price ($)')
```

注意通过使用反色图，用红色代表热性能(滚动最大值)和用蓝色代表冷性能(滚动最小值)是多么容易，而不是试图确保`pandas`首先绘制滚动最小值:

![Figure 6.38 – Working with colormaps
](image/fig_6.38.jpg)

图 6.38–使用色彩映射表

`colormap`对象是一个可调用的对象，这意味着我们可以将范围[0，1]内的值传递给它，它将告诉我们颜色图上该点的 RGBA 值，我们可以将其用于`color`参数。这使我们能够更好地控制我们从色彩映射表中使用的颜色。我们可以使用这种技术来控制如何在我们的数据中分布颜色图。例如，我们可以要求使用`color`参数的`ocean`色图的中点:

```
>>> cm.get_cmap('ocean')(.5)
(0.0, 0.2529411764705882, 0.5019607843137255, 1.0)
```

小费

在`covid19_cases_map.ipynb`笔记本中有一个使用色图作为可调用的例子，其中新冠肺炎案例计数被映射到颜色，颜色越深表示案例越多。

尽管有丰富的彩色地图可用，我们可能会发现需要创建自己的。也许我们有自己喜欢的调色板，或者要求我们使用特定的配色方案。我们可以用`matplotlib`制作自己的彩色地图。让我们制作一个混合色图，从紫色(`#800080`)到黄色(`#FFFF00`)，中间是橙色(`#FFA500`)。我们为此需要的所有功能都在`color_utils.py`中。如果我们从与文件相同的目录中运行 Python，我们可以像这样导入函数:

```
>>> import color_utils
```

首先，我们需要将这些十六进制颜色转换成它们的 RGB 等价物，这就是`hex_to_rgb_color_list()`函数要做的。请注意，当 RGB 值对两个数字使用相同的十六进制数字时，此函数也可以处理三个数字的简写十六进制代码(例如，`#F1D`是`#FF11DD`的简写等价物):

```
import re
def hex_to_rgb_color_list(colors):
    """
    Take color or list of hex code colors and convert them 
    to RGB colors in the range [0,1].
    Parameters:
        - colors: Color or list of color strings as hex codes
    Returns:
        The color or list of colors in RGB representation.
    """
    if isinstance(colors, str):
        colors = [colors]
    for i, color in enumerate(
        [color.replace('#', '') for color in colors]
    ):
        hex_length = len(color)
        if hex_length not in [3, 6]:
            raise ValueError(
                'Colors must be of the form #FFFFFF or #FFF'
            )
        regex = '.' * (hex_length // 3)
        colors[i] = [
            int(val * (6 // hex_length), 16) / 255
            for val in re.findall(regex, color)
        ]
    return colors[0] if len(colors) == 1 else colors
```

小费

看一下`enumerate()`函数；这让我们在迭代时获取索引和该索引处的值，而不是在循环中查找值。另外，注意 Python 通过指定基数用`int()`函数将 10 进制数转换成十六进制数是多么容易。(请记住，`//`是整数除法——我们必须这样做，因为`int()`需要的是整数而不是浮点数。)

我们需要的下一个函数是获取这些 RGB 颜色并为颜色图创建值。该功能需要执行以下操作:

1.  为颜色定义创建一个具有 256 个插槽的 4D NumPy 数组。注意，我们不想改变透明度，所以我们将第四维(阿尔法)单独留下。
2.  对于每个维度(红色、绿色和蓝色)，使用`np.linspace()`函数创建目标颜色之间的均匀过渡(即，从颜色 1 的红色分量过渡到颜色 2 的红色分量，然后过渡到颜色 3 的红色分量，依此类推，然后对绿色分量和最后的蓝色分量重复该过程)。
3.  返回一个我们可以在绘图时使用的`ListedColormap`对象。

这就是`blended_cmap()`函数的作用:

```
from matplotlib.colors import ListedColormap
import numpy as np
def blended_cmap(rgb_color_list):
    """
    Create a colormap blending from one color to the other.
    Parameters:
        - rgb_color_list: List of colors represented as 
          [R, G, B] values in the range [0, 1], like 
          [[0, 0, 0], [1, 1, 1]], for black and white.
    Returns: 
        A matplotlib `ListedColormap` object
    """
    if not isinstance(rgb_color_list, list):
        raise ValueError('Colors must be passed as a list.')
    elif len(rgb_color_list) < 2:
        raise ValueError('Must specify at least 2 colors.')
    elif (
        not isinstance(rgb_color_list[0], list)
        or not isinstance(rgb_color_list[1], list)
    ) or (
        (len(rgb_color_list[0]) != 3 
        or len(rgb_color_list[1]) != 3)
    ):
        raise ValueError(
            'Each color should be a list of size 3.'
        )
    N, entries = 256, 4 # red, green, blue, alpha
    rgbas = np.ones((N, entries))
    segment_count = len(rgb_color_list) – 1
    segment_size = N // segment_count
    remainder = N % segment_count # need to add this back later
    for i in range(entries - 1): # we don't alter alphas
        updates = []
        for seg in range(1, segment_count + 1):
            # handle uneven splits due to remainder
            offset = 0 if not remainder or seg > 1 \
                     else remainder
            updates.append(np.linspace(
                start=rgb_color_list[seg - 1][i], 
                stop=rgb_color_list[seg][i], 
                num=segment_size + offset
            ))
        rgbas[:,i] = np.concatenate(updates)
    return ListedColormap(rgbas)
```

我们可以使用`draw_cmap()`函数绘制一个颜色条，这允许我们可视化我们的颜色图:

```
import matplotlib.pyplot as plt
def draw_cmap(cmap, values=np.array([[0, 1]]), **kwargs):
    """
    Draw a colorbar for visualizing a colormap.
    Parameters:
        - cmap: A matplotlib colormap
        - values: Values to use for the colormap
        - kwargs: Keyword arguments to pass to `plt.colorbar()`
    Returns:
        A matplotlib `Colorbar` object, which you can save 
        with: `plt.savefig(<file_name>, bbox_inches='tight')`
    """
    img = plt.imshow(values, cmap=cmap)
    cbar = plt.colorbar(**kwargs)
    img.axes.remove()
    return cbar
```

这个函数使我们可以很容易地为我们选择的任何可视化添加一个带有自定义颜色图的颜色条；`covid19_cases_map.ipynb`笔记本上有一个使用新冠肺炎案例绘制在世界地图上的例子。现在，让我们使用这些函数来创建和可视化我们的色彩映射表。我们将通过导入模块来使用它们(我们之前已经这样做了):

```
>>> my_colors = ['#800080', '#FFA500', '#FFFF00']
>>> rgbs = color_utils.hex_to_rgb_color_list(my_colors)
>>> my_cmap = color_utils.blended_cmap(rgbs)
>>> color_utils.draw_cmap(my_cmap, orientation='horizontal')
```

这导致下面的颜色条显示我们的颜色图:

![Figure 6.39 – Custom blended colormap
](image/fig_6.39.jpg)

图 6.39–自定义混合色彩映射表

小费

Seaborn 还提供了额外的调色板，以及方便的实用工具，用于挑选色彩映射表和定制色彩映射表，以便在 Jupyter 笔记本中与`matplotlib`交互使用。查看*选择调色板*教程([https://seaborn.pydata.org/tutorial/color_palettes.html](https://seaborn.pydata.org/tutorial/color_palettes.html))了解更多信息。笔记本还包含一个简短的示例。

正如我们在我们创建的颜色条中看到的，这些颜色图能够显示不同的颜色梯度，以捕捉连续体上的值。如果我们只是想让我们的线图中的每一条线都是不同的颜色，我们很可能想要在不同的颜色之间循环。为此，我们可以使用带有颜色列表的`itertools.cycle()`;它们不会混合，但是我们可以无休止地循环，因为这将是一个无限迭代器。我们在本章前面使用了这种技术来定义我们自己的回归残差图的颜色:

```
>>> import itertools
>>> colors = itertools.cycle(['#ffffff', '#f0f0f0', '#000000'])
>>> colors
<itertools.cycle at 0x1fe4f300>
>>> next(colors)
'#ffffff'
```

更简单的情况是，我们在某个地方有一个颜色列表，但我们可以编写一个简单的**生成器**，它只是从那个主列表中*产生*，而不是将它放入我们的绘图代码并在内存中存储另一个副本。通过使用生成器，我们可以有效地利用内存，而不会让我们的绘图代码与颜色逻辑拥挤在一起。注意，生成器被定义为一个函数，但是它没有使用`return`，而是使用了`yield`。下面的代码片段展示了这个场景的模型，它类似于`itertools`解决方案；然而，它不是无限的。这正好说明我们可以找到很多方法在 Python 中做一些事情；我们必须找到最能满足我们需求的实施方案:

```
from my_plotting_module import master_color_list
def color_generator():
    yield from master_color_list
```

使用`matplotlib`，另一种方法是用颜色列表实例化一个`ListedColormap`对象，并为`N`定义一个大的值，这样它可以重复足够长的时间(如果我们不提供它，它将只遍历颜色一次):

```
>>> from matplotlib.colors import ListedColormap
>>> red_black = ListedColormap(['red', 'black'], N=2000)
>>> [red_black(i) for i in range(3)]
[(1.0, 0.0, 0.0, 1.0), 
 (0.0, 0.0, 0.0, 1.0), 
 (1.0, 0.0, 0.0, 1.0)]
```

请注意，我们也可以使用来自`matplotlib`团队的`cycler`，这增加了额外的灵活性，允许我们定义颜色、线条样式、标记、线条宽度等的组合来循环。API 详细说明了可用的功能，可以在 https://matplotlib.org/cycler/的[找到。我们将在](https://matplotlib.org/cycler/) [*第 7 章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146) 、*金融分析——比特币和股票市场*中看到这样的例子。

### 条件着色

色彩映射表使得根据数据中的值改变颜色变得容易，但是如果我们只想在满足某些条件时使用特定的颜色，会发生什么呢？在这种情况下，我们需要围绕颜色选择构建一个函数。

我们可以编写一个生成器来根据我们的数据确定绘图颜色，并且只在需要时才进行计算。假设我们想根据 1992 年到 200018 年(不，这不是一个错别字)是否是闰年来给它们分配颜色，并区分它们为什么不是闰年(例如，我们想为可被 100 整除但不是 400 整除的年份分配一种特殊的颜色，这些年份不是闰年)。我们当然不想在内存中保存这么大的列表，所以我们创建了一个生成器来按需计算颜色:

```
def color_generator():
    for year in range(1992, 200019): # integers [1992, 200019)
        if year % 100 == 0 and year % 400 != 0: 
            # special case (divisible by 100 but not 400)
            color = '#f0f0f0'
        elif year % 4 == 0:
            # leap year (divisible by 4)
            color = '#000000'
        else:
            color = '#ffffff'
        yield color
```

重要说明

**模运算符** (%)返回除法运算的余数。例如，4 % 2 等于 0，因为 4 可以被 2 整除。但是，由于 4 不能被 3 整除，所以 4 % 3 是非零的；之所以是 1，是因为我们可以一次把 3 装进 4，这样就会剩下 1(4-3)。模运算符可用于检查一个数被另一个数整除的情况，通常用于检查一个数是奇数还是偶数。在这里，我们用它来看看是否满足闰年的条件(取决于整除)。

由于我们将`year_colors`定义为一个生成器，Python 将记住我们在这个函数中的位置，并在`next()`被调用时恢复:

```
>>> year_colors = color_generator()
>>> year_colors
<generator object color_generator at 0x7bef148dfed0>
>>> next(year_colors)
'#000000'
```

更简单的生成器可以用**生成器表达式**写成。例如，如果我们不再关心特例，我们可以使用下面的语句:

```
>>> year_colors = (
...     '#ffffff'
...     if (not year % 100 and year % 400) or year % 4
...     else '#000000' for year in range(1992, 200019)
... )
>>> year_colors
<generator object <genexpr> at 0x7bef14415138>
>>> next(year_colors)
'#000000'
```

那些不是来自 Python 的人可能会觉得奇怪，我们在前面的代码片段中的布尔条件实际上是数字(`year % 400`产生一个整数)。这是利用了 Python 的*真值* / *假值*；零值(如数字`0`)或空值(如`[]`或`''`)为*假*。因此，虽然在第一个生成器中，我们编写了`year % 400 != 0`来准确地显示发生了什么，但是更多的**python 式的**方式是`year % 400`，因为如果没有余数(计算结果为 0)，该语句将被计算为`False`，反之亦然。显然，我们有时必须在可读性和 python 化之间做出选择，但是了解如何编写 python 代码是有好处的，因为这通常会更有效率。

小费

在 Python 中运行`import this`来看看**Python 的禅**，其中给出了对 Python 意味着什么的一些想法。

既然我们已经在`matplotlib`中接触了一些颜色，让我们考虑另一种方法来突出我们的数据。根据我们绘制的内容或者我们的可视化将如何使用(例如，黑白)，使用纹理和颜色一起使用或者代替颜色可能是有意义的。

## 纹理

除了定制我们可视化中使用的颜色，`matplotlib`还可以包含具有各种绘图功能的纹理。这是通过`hatch`论证实现的，`pandas`将为我们传递下去。让我们用纹理条创建一个 2018 年第四季度脸书股票周成交量柱状图:

```
>>> weekly_volume_traded = fb.loc['2018-Q4']\
...     .groupby(pd.Grouper(freq='W')).volume.sum()
>>> weekly_volume_traded.index = \
...     weekly_volume_traded.index.strftime('W %W')
>>> ax = weekly_volume_traded.plot(
...     kind='bar',
...     hatch='*',
...     color='lightgray',
...     title='Volume traded per week in Q4 2018'
... )
>>> ax.set(
...     xlabel='week number', 
...     ylabel='volume traded'
... )
```

有了`hatch='*'`，我们的酒吧里都是星星。请注意，我们还设置了每个条形的颜色，因此这里有很大的灵活性:

![Figure 6.40 – Using textured bars
](image/fig_6.40.jpg)

图 6.40–使用纹理条

纹理也可以组合成新的图案，并重复以加强效果。让我们再来看一下`plt.fill_between()`的例子，我们只对十二月的部分进行了着色(*图 6.33* )。这一次我们将使用纹理来区分每个月，而不仅仅是 12 月；我们将用圆环填充十月，用斜线填充十一月，用小圆点填充十二月:

```
>>> import calendar
>>> fb_q4 = fb.loc['2018-Q4']
>>> for texture, month in zip(
...     ['oo', '/\\/\\', '...'], [10, 11, 12]
... ):
...     plt.fill_between(
...         fb_q4.index, fb_q4.high, fb_q4.low,
...         hatch=texture, facecolor='white',
...         where=fb_q4.index.month == month,
...         label=f'{calendar.month_name[month]} differential'
...     )
>>> plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')
>>> plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low')
>>> plt.xticks([
...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'
... ])
>>> plt.xlabel('date')
>>> plt.ylabel('price ($)')
>>> plt.title(
...     'FB differential between high and low price Q4 2018'
... )
>>> plt.legend()
```

使用`hatch='o'`会产生薄的环，所以我们使用`'oo'`在十月得到更厚的环。对于 11 月，我们想要一个交叉模式，所以我们组合了两个正斜杠和两个反斜杠(我们实际上有四个反斜杠，因为它们必须被转义)。为了实现十二月的小圆点，我们使用了三个周期——我们添加的越多，纹理就变得越密集:

![Figure 6.41 – Combining textures
](image/fig_6.41.jpg)

图 6.41–组合纹理

我们对地块定制的讨论到此结束。这绝不意味着是完整的，所以一定要探索更多的 API。

# 总结

咻，太多了！我们学习了如何使用`matplotlib`、`pandas`和`seaborn`创建令人印象深刻的定制可视化效果。我们讨论了如何将`seaborn`用于额外的绘图类型和一些常见类型的更简洁版本。现在，我们可以轻松地制作自己的颜色图，注释我们的地块，添加参考线和阴影区域，调整轴/图例/标题，并控制可视化效果的大多数方面。我们也尝到了与`itertools`合作并创造我们自己的发电机的滋味。

花些时间练习我们在章节末练习中讨论的内容。在下一章中，我们将把我们学到的所有知识应用到金融中，我们将构建自己的 Python 包，并将比特币与股票市场进行比较。

# 练习

使用我们在本书中学到的知识和本章中的数据，创建以下可视化效果。确保向图中添加标题、轴标签和图例(在适当的地方):

1.  使用`seaborn`，创建一个热图，以可视化地震震级与使用`mb`震级类型测量的地震是否有海啸之间的相关系数。
2.  创建一个脸书交易量和收盘价的箱线图，并用乘数 1.5 为图基围栏的边界画参考线。界限将在*Q*1*—1.5×IQR*和 *Q* 3 *+ 1.5 × IQR* 。确保在数据上使用`quantile()`方法来简化这个过程。(选择你喜欢的剧情方向，但是一定要使用支线剧情。)
3.  绘制全球累计新冠肺炎病例的演变，并在超过 100 万的日期添加垂直虚线。确保相应地格式化 *y* 轴上的刻度标签。
4.  用`axvspan()`画出一个从`'2018-07-25'`到`'2018-07-31'`的矩形，在收盘价的折线图上，它标志着脸书价格的大幅下跌。
5.  Using the Facebook stock price data, annotate the following three events on a line plot of the closing price:

    a)**2018 年 7 月 25 日**收盘后公布的用户增长令人失望

    b) **剑桥分析公司故事爆料**2018 年 3 月 19 日(影响市场的时候)

    c) **FTC 于 2018 年 3 月 20 日发起调查**

6.  修改`reg_resid_plots()`函数以使用`matplotlib`色彩图，而不是在两种颜色之间循环。记住，对于这个用例，我们应该选择一个定性的颜色图或者自己制作一个。

# 延伸阅读

查看以下资源，了解本章所涵盖主题的更多信息:

*   *选择彩色地图*:【https://matplotlib.org/tutorials/colors/colormaps.html 
*   *控制身材美学(seaborn)*:【https://seaborn.pydata.org/tutorial/aesthetics.html】T2
*   *用样式表和 rcParams 定制 Matplotlib*:[https://Matplotlib . org/tutorials/introductive/Customizing . html](https://matplotlib.org/tutorials/introductory/customizing.html)
*   *格式字符串语法*:[https://docs . python . org/3/library/String . html # Format-String-Syntax](https://docs.python.org/3/library/string.html#format-string-syntax)
*   *生成器表达式(人教版 289)*:【https://www.python.org/dev/peps/pep-0289/】T2
*   *信息仪表板设计:显示一目了然的监测数据，第二版，作者:Stephen first*:[https://www . Amazon . com/Information-Dashboard-Design-At-Glance/DP/1938377001/](https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/)
*   *Matplotlib 命名的颜色*:【https://matplotlib.org/examples/color/named_colors.html】T2
*   *多重赋值和元组解包提高 Python 代码可读性*:[https://trey hunner . com/2018/03/tuple-unpacking-improves-Python-code-readability/](https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/)
*   Python: range 不是迭代器！:[https://trey hunner . com/2018/02/python-range-is-not-an-iterator/](https://treyhunner.com/2018/02/python-range-is-not-an-iterator/)
*   *Python zip()函数*:【https://www.journaldev.com/15891/python-zip-function 
*   *Seaborn API 参考*:【https://seaborn.pydata.org/api.html 
*   斯蒂芬·诺什:【https://www.amazon.com/gp/product/0970601972/】T2
*   *样式表引用(Matplotlib)*:[https://Matplotlib . org/gallery/Style _ sheets/Style _ sheets _ reference . html](https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html)
*   *支持和阻力基础知识*:[https://www . investopedia . com/trading/Support-and-Resistance-Basics/](https://www.investopedia.com/trading/support-and-resistance-basics/)
*   *迭代器协议:Python 中“For Loops”如何工作*:[https://trey hunner . com/2016/12/Python-Iterator-Protocol-How-For-Loops-Work/](https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/)
*   *量化信息的可视化展示，作者爱德华·r·图夫特*:[https://www . Amazon . com/Visual-Display-Quantitative-Information/DP/1930824130](https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130)
*   *Tick formatters*:[https://matplotlib . org/gallery/ticks _ and _ spines/Tick-formatters . html](https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html)
*   *python 是什么意思？*:[https://stack overflow . com/questions/25011078/what-do-python IC-mean](https://stackoverflow.com/questions/25011078/what-does-pythonic-mean)*