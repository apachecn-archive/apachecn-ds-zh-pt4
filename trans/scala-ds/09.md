<title>Chapter 9. Concurrency with Akka</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 第九章。Akka 的并发性

本书的大部分内容都集中在利用多核和分布式架构上。在[第 4 章](ch04.html "Chapter 4. Parallel Collections and Futures")、*并行集合和未来*中，您学习了如何使用并行集合将批处理问题分布到几个线程上，以及如何使用未来执行异步计算。在[第 7 章](ch07.html "Chapter 7. Web APIs")、*Web API*中，我们应用了这些知识来查询带有几个并发线程的 GitHub API。

未来和并行集合等并发抽象通过限制您可以做的事情来简化并发编程的巨大复杂性。例如，并行集合迫使您将并行化问题表述为集合上的一系列纯函数。

参与者提供了一种不同的思考并发性的方式。演员非常擅长封装*状态*。管理不同执行线程之间共享的状态可能是开发并发应用程序中最具挑战性的部分，正如我们将在本章中发现的，actors 使它变得易于管理。

# GitHub 关注者图

在前两章中，我们探索了 GitHub API，学习了如何使用 *json-4s* 查询 API 并解析结果。

假设我们想要提取 GitHub 追随者图:我们想要一个程序，它将从一个特定的用户开始，提取这个用户的追随者，然后提取他们的追随者，直到我们告诉它停止。问题是我们事先不知道我们需要获取什么 URL:当我们下载特定用户的追随者的登录名时，我们需要验证我们之前是否已经获取了这些用户。如果没有，我们将他们添加到我们需要获取其追随者的用户队列中。算法爱好者可能会认为这是*广度优先搜索*。

让我们概述一下如何用单线程的方式编写这个程序。中心组件是一组已访问用户和未来要访问的用户队列:

```
val seedUser = "odersky" // the origin of the network

// Users whose URLs need to be fetched 

val queue = mutable.Queue(seedUser) 

// set of users that we have already fetched 

// (to avoid re-fetching them)

val fetchedUsers = mutable.Set.empty[String] 

while (queue.nonEmpty) {

  val user = queue.dequeue

  if (!fetchedUsers(user)) {

    val followers = fetchFollowersForUser(user)

    followers foreach { follower =>           

      // add the follower to queue of people whose 

      // followers we want to find.

      queue += follower

    }

    fetchedUsers += user

  }

}
```

在这里，`fetchFollowersForUser`方法有签名`String => Iterable[String]`，由负责获取登录名，将其转换为 GitHub API 中的 URL，查询 API，并从响应中提取关注者列表。我们不会在这里实现它，但是你可以在本书的代码示例的`chap09/single_threaded`目录中找到一个完整的示例(【https://github.com/pbugnion/s4ds】[)。如果你已经阅读了](https://github.com/pbugnion/s4ds)[第 7 章](ch07.html "Chapter 7. Web APIs")、*Web API*，你应该已经拥有了实现这一点的所有工具。

虽然这种方法可行，但速度会非常慢。瓶颈显然是`fetchFollowersForUser`方法，特别是查询 GitHub API 的部分。这个程序不适合我们在本书前面看到的并发结构，因为我们需要保护程序的状态，由用户队列和获取的用户组体现，免受竞争条件的影响。注意，这不仅仅是使队列和集合线程安全的问题。我们还必须保持两者同步。

参与者提供了一个优雅的抽象来封装状态。它们是轻量级对象，每个对象执行一个任务(可能重复执行)，并通过传递消息相互通信。参与者的内部状态只能从参与者自身内部进行更改。重要的是，参与者一次只处理一条消息，有效地防止了竞态条件。

通过将程序状态隐藏在actor 中，我们可以更有效地对程序进行推理:如果引入了一个使状态不一致的 bug，那么罪魁祸首将完全定位在那个 actor 中。

<title>Actors as people</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 作为人的演员

在上一节中，您了解了 actor 封装状态，通过消息与外部世界进行交互。参与者使并发编程更加直观，因为他们的行为有点像理想的劳动力。

我们来想一个演员系统，代表一个有五个人的初创公司。首席执行官克里斯和负责营销的马克。然后是工程团队的负责人莎莉。莎莉有两个跟班，鲍勃和凯文。因为每个好的组织都需要一个组织结构图，请参考下图:

![Actors as people](graphics/4795_09_01.jpg)

假设克里斯收到一份订单。他将查看订单，决定是否是他自己可以处理的事情，如果不是，他将把它转发给马克或莎莉。让我们假设订单要求一个小程序，因此 Bob 将订单转发给 Sally。Sally 正忙于处理积压的订单，因此她无法立即处理订单消息，它将暂时留在她的邮箱中。当她最终开始处理订单时，她可能会决定将订单分成几部分，一部分给 Kevin，一部分给 Bob。

当 Bob 和 Kevin 完成项目时，他们将向 Sally 发送消息通知她。当订单的每个部分都完成后，Sally 会将各个部分汇总在一起，并将结果直接发送给客户或 Chris。

跟踪完成订单必须完成哪些工作的任务落在了莎莉身上。当她收到来自 Bob 和 Kevin 的消息时，她必须更新正在进行的任务列表，并检查与该订单相关的每个任务是否都已完成。这种协调对于传统的*同步*块来说更具挑战性:对正在进行的任务列表和已完成任务列表的每次访问都需要同步。通过将这种逻辑嵌入到 Sally(她一次只能处理一条消息)中，我们可以确保不会出现竞态条件。

我们的初创公司运转良好，因为每个人负责做一件事情:克里斯要么委托给马克，要么委托给莎莉，莎莉将订单分成几部分，分配给鲍勃和凯文，鲍勃和凯文完成每一部分。你可能会想“等等，所有的逻辑都嵌入在 Bob 和 Kevin 身上，他们是梯子底部的员工，做所有的实际工作”。与雇员不同，参与者是廉价的，所以如果嵌入在参与者中的逻辑变得太复杂，很容易引入额外的委托层，直到任务变得足够简单。

我们初创公司的员工拒绝一心多用。当他们得到一件工作时，他们完全处理它，然后继续下一个任务。这意味着他们不会被多重任务的复杂性弄糊涂。参与者通过一次处理一条消息，大大减少了引入并发错误(如竞争条件)的可能性。

更重要的是，通过提供程序员可以直观理解的抽象——人类工作者的抽象——Akka 使得关于并发性的推理更加容易。

<title>Hello world with Akka</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 你好，Akka 世界

让我们安装 Akka。我们将它作为依赖项添加到我们的`build.sbt`文件中:

```
scalaVersion := "2.11.7"

libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.4.0"
```

我们现在可以按如下方式导入 Akka:

```
import akka.actor._
```

对于我们进入演员世界的第一次尝试，我们将构建一个演员来回应它收到的每一条消息。本节的代码示例位于本书提供的示例代码中的目录`chap09/hello_akka`([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)):

```
// EchoActor.scala

import akka.actor._

class EchoActor extends Actor with ActorLogging {

  def receive = {

    case msg:String => 

      Thread.sleep(500)

      log.info(s"Received '$msg'") 

  }

}
```

让我们把这个例子分开，从构造函数开始。我们的演员类必须扩展`Actor`。我们还添加了`ActorLogging`，这是一个添加了`log`属性的实用特征。

`Echo` actor 公开了一个方法`receive`。这是演员与外界沟通的唯一方式。为了有用，所有的参与者都必须公开一个`receive` 方法。`receive`方法是一个部分函数，通常用多个`case`语句实现。当一个 actor 开始处理一个消息时，它会将它与每个`case`语句进行匹配，直到找到一个匹配的语句。然后，它将执行相应的块。

我们的 echo actor 接受单一类型的消息，一个普通的字符串。当这个消息被处理后，actor 等待半秒钟，然后将消息回显到日志文件中。

让我们实例化几个 Echo actors 并向它们发送消息:

```
// HelloAkka.scala

import akka.actor._

object HelloAkka extends App {

  // We need an actor system before we can 

  // instantiate actors

  val system = ActorSystem("HelloActors")

  // instantiate our two actors

  val echo1 = system.actorOf(Props[EchoActor], name="echo1")

  val echo2 = system.actorOf(Props[EchoActor], name="echo2")

  // Send them messages. We do this using the "!" operator

  echo1 ! "hello echo1"

  echo2 ! "hello echo2"

  echo1 ! "bye bye"

  // Give the actors time to process their messages, 

  // then shut the system down to terminate the program

  Thread.sleep(500)

  system.shutdown

}
```

运行这个命令会得到下面的输出:

```

[INFO] [07/19/2015 17:15:23.954] [HelloActor-akka.actor.default-dispatcher-2] [akka://HelloActor/user/echo1] Received 'hello echo1'

[INFO] [07/19/2015 17:15:23.954] [HelloActor-akka.actor.default-dispatcher-3] [akka://HelloActor/user/echo2] Received 'hello echo2'

[INFO] [07/19/2015 17:15:24.955] [HelloActor-akka.actor.default-dispatcher-2] [akka://HelloActor/user/echo1] Received 'bye bye'

```

请注意，`echo1`和`echo2`角色显然是并发执行的:`hello echo1`和`hello echo2`是同时登录的。传递给`echo1`的第二条消息在演员完成处理`hello echo1`后得到处理。

有一些不同的事情需要注意:

*   要开始实例化 actor，我们必须首先创建一个 actor 系统。每个应用程序通常有一个单一参与者系统。
*   我们实例化演员的方式看起来有点奇怪。我们没有调用构造函数，而是创建了一个 actor properties 对象`Props[T]`。然后，我们要求 actor 系统创建一个具有这些属性的 actor。事实上，我们从来没有用`new`实例化 actor:它们要么是通过调用 actor 系统中的`actorOf`方法创建的，要么是从另一个 actor 内部调用类似的方法创建的(稍后将详细介绍)。

我们从来不从演员外部调用演员的方法。与参与者交互的唯一方式是向其发送消息。我们使用*告诉*操作符`!`来实现这一点。因此，没有办法从一个演员的外部扰乱这个演员的内部(或者至少，Akka 使得扰乱一个演员的内部变得困难)。

<title>Case classes as messages</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 作为消息的案例类

在我们的“hello world”示例中，我们构造了一个 actor，该 actor 将接收一个字符串作为消息。任何对象都可以作为消息传递，只要它是不可变的。使用 case 类来表示消息是非常常见的。由于额外的类型安全性，这比使用字符串更好:编译器将捕获 case 类中的错别字，而不是字符串。

让我们重写我们的`EchoActor`来接受 case 类的实例作为消息。我们将让它接受两个不同的消息:`EchoMessage(message)`和`EchoHello`，这只是回显一个默认消息。本节和下一节的示例位于本书提供的示例代码的`chap09/hello_akka_case_classes`目录中(【https://github.com/pbugnion/s4ds】)。

一个常见的 Akka 模式是定义参与者可以在参与者的同伴对象中接收的消息:

```
// EchoActor.scala

object EchoActor { 

  case object EchoHello

  case class EchoMessage(msg:String)

}
```

让我们更改参与者定义以接受这些消息:

```
class EchoActor extends Actor with ActorLogging {

  import EchoActor._ // import the message definitions

  def receive = {

    case EchoHello => log.info("hello")

    case EchoMessage(s) => log.info(s)  

  }

}
```

我们现在可以将`EchoHello` 和`EchoMessage`发送给我们的演员:

```
echo1 ! EchoActor.EchoHello

echo2 ! EchoActor.EchoMessage("We're learning Akka.")
```

<title>Actor construction</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 演员构造

对于 Akka 新手来说，演员结构是一个常见的困难来源。与(大多数)普通对象不同，您从不显式实例化参与者。你永远不会写，例如，`val echo = new EchoActor`。事实上，如果您尝试这样做，Akka 会引发一个异常。

在 Akka 中创建 actor 是一个两步过程:首先创建一个`Props`对象，它封装了构造 actor 所需的属性。构造`Props`对象的方式根据参与者是否接受构造函数参数而有所不同。如果构造函数不带参数，我们只需将 actor 类作为类型参数传递给`Props`:

```
val echoProps = Props[EchoActor]
```

如果我们有一个 actor，它的构造函数接受参数，我们必须在定义`Props`对象时将这些参数作为附加参数传递。例如，让我们考虑下面的演员:

```
class TestActor(a:String, b:Int) extends Actor { ... }
```

我们将构造函数参数传递给`Props`对象，如下所示:

```
val testProps = Props(classOf[TestActor], "hello", 2)
```

`Props`实例只是实现了创建一个 actor 的配置。它实际上并没有创造任何东西。为了创建一个 actor，我们将`Props`实例传递给在`ActorSystem`实例上定义的`system.actorOf`方法:

```
val system = ActorSystem("HelloActors")

val echo1 = system.actorOf(echoProps, name="hello-1")
```

`name`参数是可选的，但是对于日志记录和错误消息非常有用。由`.actorOf`返回的值不是演员本身:它是对演员的一个*引用*(这有助于把它想象成演员居住的地址)并且具有`ActorRef`类型。`ActorRef`是不可变的，但是可以序列化和复制，不会影响底层的 actor。

除了在 actor 系统上调用`actorOf`之外，还有另一种创建 actor 的方法:每个 actor 公开一个`context.actorOf`方法，该方法将一个`Props`实例作为其参数。上下文只能从参与者内部访问:

```
class TestParentActor extends Actor {

  val echoChild = context.actorOf(echoProps, name="hello-child")

  ...

}
```

从 actor 系统创建的 actor 和从另一个 actor 的上下文创建的 actor 的区别在于 actor 层次结构:每个 actor 都有一个父 actor。在另一个执行元的上下文中创建的任何执行元都将该执行元作为其父执行元。由 actor 系统创建的 actor 有一个预定义的 actor，称为*用户监护人*，作为其父 actor。当我们在本章末尾学习参与者生命周期时，我们将理解参与者层次结构的重要性。

一个非常常见的习语是在 actor 的 companion 对象中定义一个`props`方法，作为该 actor 的`Props`实例的工厂方法。让我们来修正一下`EchoActor` 的伴侣对象:

```
object EchoActor {

  def props:Props = Props[EchoActor]

  // message case class definitions here

}
```

然后，我们可以实例化该 actor，如下所示:

```
val echoActor = system.actorOf(EchoActor.props)
```

<title>Anatomy of an actor</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 解剖一个演员

在进入一个成熟的应用程序之前，让我们看看 actor 框架的不同组件，以及它们是如何组合在一起的:

*   **邮箱**:一个邮箱基本上就是一个队列。每个演员都有自己的邮箱。当您向一个参与者发送消息时，该消息会进入它的邮箱，并且不做任何事情，直到参与者将它从队列中取出并通过它的`receive`方法传递它。
*   消息:消息使得参与者之间的同步成为可能。消息可以具有任何类型，唯一的要求是它应该是不可变的。一般来说，最好使用 case 类或 case 对象来帮助编译器检查消息类型。
*   **Actor 引用**:当我们使用`val echo1 = system.actorOf(Props[EchoActor])`创建一个 Actor 时，`echo1`拥有类型`ActorRef`。一个`ActorRef`是一个演员的代理，是世界上其他人与之交互的对象:当你发送消息时，你把它发送给`ActorRef`，而不是直接发送给演员。事实上，你永远无法在 Akka 中直接获得一个演员的句柄。演员可以使用`.self`方法为自己获得一个`ActorRef`。
*   **actor context** :每个 Actor 都有一个 `context`属性，通过这个属性可以访问方法来创建或访问其他 Actor，并找到关于外部世界的信息。我们已经看到了如何用`context.actorOf(props)`创建新的演员。我们还可以通过`context.parent`获得一个演员父母的引用。一个演员也可以用`context.stop(actorRef)`停止另一个演员，这里`actorRef`是我们想要停止的演员的引用。
*   **调度器**:调度器是在 actor 中实际执行代码的机器。默认调度程序使用 fork/join 线程池。Akka 让我们为不同的演员使用不同的调度程序。调整调度程序有助于优化性能并优先考虑某些演员。参与者运行的调度程序可以通过`context.dispatcher`访问。调度程序实现了`ExecutionContext`接口，因此它们可以用于运行期货。

<title>Follower network crawler</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 跟随者网络爬虫

本章的最终目的是构建一个爬虫来探索 GitHub 的追随者图表。我们已经在本章前面概述了如何以单线程方式实现这一点。让我们设计一个 actor 系统来同时完成这个任务。

代码中的活动部分是管理哪些用户已经被获取或正在被获取的数据结构。这些需要封装在一个 actor 中，以避免多个 actor 试图同时改变它们时产生的竞态条件。因此，我们将创建一个 *fetcher manager* actor，其工作是跟踪哪些用户已经被获取，以及我们下一步将获取哪些用户。

可能成为瓶颈的代码部分是查询 GitHub API。因此，我们希望能够扩大同时从事这项工作的员工数量。我们将创建一个由*fetcher*组成的池，参与者负责在 API 中查询特定用户的追随者。最后，我们将创建一个 actor，其职责是解释 API 的响应。这个 actor 将把它对响应的解释转发给另一个 actor，后者将提取追随者并把他们交给 fetcher manager。

这是程序的架构的样子:

![Follower network crawler](graphics/4795_09_02.jpg)

GitHub API 爬虫的 Actor 系统

我们程序中的每个参与者都执行一项任务:获取器只需查询 GitHub API，队列管理器只需将工作分配给获取器。Akka 最佳实践要求给演员尽可能窄的责任范围。这在向外扩展时实现了更好的粒度(例如，通过添加更多的 fetcher actors，我们只是并行化了瓶颈)和更好的弹性:如果一个 actor 失败了，它只会影响他的责任范围。我们将在本章后面探讨演员的失败。

我们将分几个步骤构建应用程序，在编写程序时探索 Akka 工具包。先说 `build.sbt`文件。除了 Akka，我们将把`scalaj-http`和`json4s`标记为依赖关系:

```
// build.sbt

scalaVersion := "2.11.7"

libraryDependencies ++= Seq(

  "org.json4s" %% "json4s-native" % "3.2.10",

  "org.scalaj" %% "scalaj-http" % "1.1.4",

  "com.typesafe.akka" %% "akka-actor" % "2.3.12"

)
```

<title>Fetcher actors</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 费彻演员

我们的应用程序的主力是获取器，即负责从 GitHub 获取关注者详细信息的角色。在第一种情况下，我们的演员将接受一个单一的消息，`Fetch(user)`。它将获取对应于`user`的追随者，并将响应记录到屏幕上。我们将使用[第 7 章](ch07.html "Chapter 7. Web APIs")、*Web API*中开发的方法，用 OAuth 令牌查询 GitHub API。我们将通过 actor 构造函数注入令牌。

让我们从伴星开始。这将包含`Fetch(user)`消息的定义和创建`Props`实例的两个工厂方法。您可以在本书提供的示例代码([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds))的`chap09/fetchers_alone`目录中找到本节的代码示例:

```
// Fetcher.scala

import akka.actor._

import scalaj.http._

import scala.concurrent.Future

object Fetcher {

  // message definitions

  case class Fetch(login:String)

  // Props factory definitions

  def props(token:Option[String]):Props = 

    Props(classOf[Fetcher], token)

  def props():Props = Props(classOf[Fetcher], None)

}
```

现在让我们定义提取器本身。将来我们会将调用包装到 GitHub API 中。这避免了单个缓慢的请求阻塞参与者。当我们的 actor 接收到一个`Fetch`请求时，它将这个请求包装成一个 future，发送出去，然后可以处理下一个消息。让我们继续并实现我们的 actor:

```
// Fetcher.scala

class Fetcher(val token:Option[String])

extends Actor with ActorLogging {

  import Fetcher._ // import message definition

  // We will need an execution context for the future.

  // Recall that the dispatcher doubles up as execution

  // context.

  import context.dispatcher

  def receive = {

    case Fetch(login) => fetchUrl(login)

  }

  private def fetchUrl(login:String) {

    val unauthorizedRequest = Http(

      s"https://api.github.com/users/$login/followers")

    val authorizedRequest = token.map { t =>

      unauthorizedRequest.header("Authorization", s"token $t")

    }

    // Prepare the request: try to use the authorized request

    // if a token was given, and fall back on an unauthorized 

    // request

    val request = authorizedRequest.getOrElse(unauthorizedRequest)

    // Fetch from github

    val response = Future { request.asString }

    response.onComplete { r =>

      log.info(s"Response from $login: $r")

    }

  }

}
```

让我们实例化一个 actor 系统和四个 fetchers 来检查我们的 actor 是否按预期工作。我们将从环境中读取 GitHub 令牌，如[第 7 章](ch07.html "Chapter 7. Web APIs")、*Web API*中所述，然后创建四个 actorss 并要求每个 actor 获取特定 GitHub 用户的追随者。我们等待五秒钟请求完成，然后关闭系统:

```
// FetcherDemo.scala

import akka.actor._

object FetcherDemo extends App {

  import Fetcher._ // Import the messages

  val system = ActorSystem("fetchers")

  // Read the github token if present.

  val token = sys.env.get("GHTOKEN")

  val fetchers = (0 until 4).map { i =>

    system.actorOf(Fetcher.props(token))

  }

  fetchers(0) ! Fetch("odersky")

  fetchers(1) ! Fetch("derekwyatt")

  fetchers(2) ! Fetch("rkuhn")

  fetchers(3) ! Fetch("tototoshi")

  Thread.sleep(5000) // Wait for API calls to finish

  system.shutdown // Shut system down

}
```

让我们通过 SBT 运行代码:

```

$ GHTOKEN="2502761..." sbt run

[INFO] [11/08/2015 16:28:06.500] [fetchers-akka.actor.default-dispatcher-2] [akka://fetchers/user/$d] Response from tototoshi: Success(HttpResponse([{"login":"akr4","id":10892,"avatar_url":"https://avatars.githubusercontent.com/u/10892?v=3","gravatar_id":""...

```

注意我们是如何明确地需要使用`system.shutdown`关闭 actor 系统的。程序挂起，直到系统关闭。但是，关闭系统会停止所有的参与者，所以我们需要确保他们已经完成了工作。我们通过插入对`Thread.sleep`的调用来实现这一点。

使用`Thread.sleep`等待直到 API 调用结束来关闭 actor 系统有点粗糙。更好的方法可能是让参与者向系统发回信号，表明他们已经完成了任务。稍后当我们实现*提取器管理器*角色时，我们将看到这种模式的例子。

Akka 包括一个功能丰富的*调度器*来调度事件。我们可以使用调度程序来替换对`Thread.sleep`的调用，方法是调度系统在未来五秒后关闭。这是更可取的，因为调度程序不会阻塞调用线程，不像`Thread.sleep`。要使用调度程序，我们需要导入一个全局执行上下文和持续时间模块:

```
// FetcherDemoWithScheduler.scala

import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.duration._
```

然后，我们可以通过将对`Thread.sleep`的调用替换为以下内容来安排系统关闭:

```
system.scheduler.scheduleOnce(5.seconds) { system.shutdown }
```

除了`scheduleOnce`之外，调度器还公开了一个`schedule`方法，让您调度事件定期发生(例如，每两秒钟一次)。这对于心跳检查或监控系统非常有用。欲了解更多信息，请阅读位于 http://doc.akka.io/docs/akka/snapshot/scala/scheduler.html[的调度程序 API 文档。](http://doc.akka.io/docs/akka/snapshot/scala/scheduler.html)

请注意，我们没有获取每个关注者，这实际上有点作弊。对关注者查询的响应实际上是分页的，所以我们需要获取几个页面来获取所有的关注者。为参与者添加逻辑来实现这一点并不复杂。我们现在将忽略这一点，并假设每个用户最多有 100 个关注者。

<title>Routing</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 路由

在前面的例子中，我们创建了四个 fetchers 并一个接一个地向它们发送消息。我们有一群相同的参与者，我们在他们之间分配任务。手动将消息路由到正确的参与者以最大化我们的池的利用率是痛苦的，并且容易出错。幸运的是，Akka 为我们提供了几个路由策略，我们可以使用它们在我们的演员池中分配工作。让我们用自动路由重写前面的例子。您可以在本书提供的示例代码([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds))的`chap09/fetchers_routing`目录中找到本节的代码示例。我们将重复使用与上一节相同的`Fetchers`及其伴随对象的定义。

让我们从导入路由包开始:

```
// FetcherDemo.scala

import akka.routing._
```

一个*路由器*是一个角色，它将收到的消息转发给它的孩子。定义角色池最简单的方法是告诉 Akka 创建一个路由器，并为其子节点传递一个`Props`对象。然后，路由器将直接管理工作线程的创建。在我们的例子中(我们将只对文本中与前一个例子不同的部分进行评论，但是你可以在本章的例子所在的`fetchers_routing`目录中找到完整的代码)，我们用下面的代码替换定制的`Fetcher`创建代码:

```
// FetcherDemo.scala

// Create a router with 4 workers of props Fetcher.props()

val router = system.actorOf(

  RoundRobinPool(4).props(Fetcher.props(token))

)
```

然后，我们可以将获取消息直接发送到路由器。路由器将以循环方式将消息路由到孩子:

```
List("odersky", "derekwyatt", "rkuhn", "tototoshi").foreach { 

  login => router ! Fetch(login)

}
```

在本例中，我们使用了循环路由器。Akka 提供许多不同类型的路由器，包括具有动态池大小的路由器，以满足不同类型的负载平衡。前往 Akka 文档查看所有可用路由器的列表，在[http://doc.akka.io/docs/akka/snapshot/scala/routing.html](http://doc.akka.io/docs/akka/snapshot/scala/routing.html)。

<title>Message passing between actors</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 演员之间的信息传递

仅仅记录 API 的响应是没有多大用处的。要遍历从动图，我们必须执行以下操作:

*   检查响应的返回代码，确保 GitHub API 对我们的请求感到满意
*   将响应解析为 JSON
*   提取跟随者的登录名，如果我们还没有获取它们，将它们推入队列

你在第 7 章、*和*中学习了如何做所有这些事情，但不是在 actors 的上下文中。

我们可以向我们的`Fetcher` actor 的`receive`方法添加额外的处理步骤:我们可以通过未来的组合向 API 响应添加进一步的转换。然而，让参与者做几种不同的事情，并且可能以几种不同的方式失败，这是一种反模式:当我们学习管理参与者生命周期时，我们会看到，如果参与者包含几个逻辑位，那么对我们的参与者系统进行推理会变得更加困难。

因此，我们将使用三个不同参与者的管道:

*   我们已经遇到过的提取器只负责从 GitHub 获取一个 URL。如果 URL 格式不正确或者无法访问 GitHub API，它们将会失败。
*   响应解释器负责从 GitHub API 获取响应，并将其解析到 JSON。如果它在任一步失败，它将只记录错误(在实际的应用程序中，我们可能会根据失败的类型采取不同的纠正措施)。如果它成功地提取了 JSON，它将把 JSON 数组传递给 follower 提取器。
*   追随者提取器将从 JSON 数组中提取追随者，并将他们传递给我们需要获取其追随者的用户队列。

我们已经构建了 fetchers，尽管我们需要修改它们来将 API 响应转发给响应解释器，而不仅仅是记录它。

您可以在本书提供的示例代码([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds))的`chap09/all_workers`目录中找到本节的代码示例。第一步是修改提取器，这样它们就可以将响应转发给响应解释器，而不是记录响应。为了能够将响应转发给 response 解释器，fetchers 需要引用这个 actor。我们将通过 fetcher 构造函数将引用传递给响应解释器，现在是:

```
// Fetcher.scala

class Fetcher(

  val token:Option[String], 

  val responseInterpreter:ActorRef) 

extends Actor with ActorLogging {

  ...

}
```

我们还必须修改伴生对象中的`Props`工厂方法:

```
// Fetcher.scala

def props(

  token:Option[String], responseInterpreter:ActorRef

):Props = Props(classOf[Fetcher], token, responseInterpreter)
```

我们还必须修改`receive`方法，将 HTTP 响应转发给解释器，而不仅仅是记录它:

```
// Fetcher.scala

class Fetcher(...) extends Actor with ActorLogging {

  ...

  def receive = {

    case Fetch(login) => fetchFollowers(login)

  }

  private def fetchFollowers(login:String) {

    val unauthorizedRequest = Http(

      s"https://api.github.com/users/$login/followers")

    val authorizedRequest = token.map { t =>

      unauthorizedRequest.header("Authorization", s"token $t")

    }

    val request = authorizedRequest.getOrElse(unauthorizedRequest)

    val response = Future { request.asString }

    // Wrap the response in an InterpretResponse message and

    // forward it to the interpreter.

    response.onComplete { r =>

      responseInterpreter !

        ResponseInterpreter.InterpretResponse(login, r)

    }

  }

}
```

*响应解释器*获取响应，决定它是否有效，将其解析为 JSON，并将其转发给追随者提取器。响应解释器需要一个对 follower 提取器的引用，我们将在构造函数中传递这个引用。

我们先来定义一下`ResponseInterpreter`伴侣。它将只包含响应解释器可以接收的消息的定义，以及创建一个`Props`对象来帮助实例化的工厂:

```
// ResponseInterpreter.scala

import akka.actor._

import scala.util._

import scalaj.http._

import org.json4s._

import org.json4s.native.JsonMethods._

object ResponseInterpreter {

  // Messages

  case class InterpretResponse(

    login:String, response:Try[HttpResponse[String]]

  )

  // Props factory

  def props(followerExtractor:ActorRef) = 

    Props(classOf[ResponseInterpreter], followerExtractor)

}
```

`ResponseInterpreter`的主体应该感觉很熟悉:当 actor 收到一条消息，给出一个要解释的响应时，它使用你在[第 7 章](ch07.html "Chapter 7. Web APIs")、*Web API*中学到的技术将其解析为 JSON。如果我们成功解析了响应，我们会将解析后的 JSON 转发给 follower 提取器。如果我们无法解析响应(可能是因为它的格式不正确)，我们只记录错误。我们可以通过其他方式来恢复，例如，将这个登录重新添加到队列管理器中，以便再次获取:

```
// ResponseInterpreter.scala

class ResponseInterpreter(followerExtractor:ActorRef) 

extends Actor with ActorLogging {

  // Import the message definitions

  import ResponseInterpreter._

  def receive = {

    case InterpretResponse(login, r) => interpret(login, r)

  }

  // If the query was successful, extract the JSON response

  // and pass it onto the follower extractor.

  // If the query failed, or is badly formatted, throw an error

  // We should also be checking error codes here.

  private def interpret(

    login:String, response:Try[HttpResponse[String]]

  ) = response match {

    case Success(r) => responseToJson(r.body) match {

      case Success(jsonResponse) => 

        followerExtractor ! FollowerExtractor.Extract(

          login, jsonResponse)

      case Failure(e) => 

        log.error(

          s"Error parsing response to JSON for $login: $e")

    }

    case Failure(e) => log.error(

      s"Error fetching URL for $login: $e")

  }

  // Try and parse the response body as JSON. 

  // If successful, coerce the `JValue` to a `JArray`.

  private def responseToJson(responseBody:String):Try[JArray] = {

    val jvalue = Try { parse(responseBody) }

    jvalue.flatMap {

      case a:JArray => Success(a)

      case _ => Failure(new IllegalStateException(

        "Incorrectly formatted JSON: not an array"))

    }

  }

}
```

我们现在有三分之二的工人演员。最后一个环节是跟随者提取器。这个 actor 的工作很简单:它接受响应解释器传递给它的`JArray`,并将其转换成一个追随者列表。现在，我们将只记录这个列表，但是当我们构建提取器管理器时，追随者提取器将发送消息，要求管理器将追随者添加到要提取的登录队列中。

和以前一样，companion 只是定义了这个演员可以接收的消息和一个道具工厂方法:

```
// FollowerExtractor.scala

import akka.actor._

import org.json4s._

import org.json4s.native.JsonMethods._

object FollowerExtractor {

  // Messages

  case class Extract(login:String, jsonResponse:JArray)

  // Props factory method

  def props = Props[FollowerExtractor]

}
```

`FollowerExtractor`类接收包含代表追随者的信息的`JArray`的`Extract`消息。它提取`login`字段并记录下来:

```
class FollowerExtractor extends Actor with ActorLogging {

  import FollowerExtractor._

  def receive = {

    case Extract(login, followerArray) => {

      val followers = extractFollowers(followerArray)

      log.info(s"$login -> ${followers.mkString(", ")}")

    }

  }

  def extractFollowers(followerArray:JArray) = for {

    JObject(follower) <- followerArray

    JField("login", JString(login)) <- follower

  } yield login

}
```

让我们写一个新的`main`方法来锻炼我们所有的演员:

```
// FetchNetwork.scala

import akka.actor._

import akka.routing._

import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.duration._

object FetchNetwork extends App {

  import Fetcher._ // Import messages and factory method

  // Get token if exists

  val token = sys.env.get("GHTOKEN")

  val system = ActorSystem("fetchers")

  // Instantiate actors

  val followerExtractor = system.actorOf(FollowerExtractor.props)

  val responseInterpreter =   

    system.actorOf(ResponseInterpreter.props(followerExtractor))

  val router = system.actorOf(RoundRobinPool(4).props(

    Fetcher.props(token, responseInterpreter))

  )

  List("odersky", "derekwyatt", "rkuhn", "tototoshi") foreach {

    login => router ! Fetch(login)

  }

  // schedule a shutdown

  system.scheduler.scheduleOnce(5.seconds) { system.shutdown }

}
```

让我们来看看 SBT 的情况:

```

$ GHTOKEN="2502761d..." sbt run

[INFO] [11/05/2015 20:09:37.048] [fetchers-akka.actor.default-dispatcher-3] [akka://fetchers/user/$a] derekwyatt -> adulteratedjedi, joonas, Psycojoker, trapd00r, tyru, ...

[INFO] [11/05/2015 20:09:37.050] [fetchers-akka.actor.default-dispatcher-3] [akka://fetchers/user/$a] tototoshi -> akr4, yuroyoro, seratch, yyuu, ...

[INFO] [11/05/2015 20:09:37.051] [fetchers-akka.actor.default-dispatcher-3] [akka://fetchers/user/$a] odersky -> misto, gkossakowski, mushtaq, ...

[INFO] [11/05/2015 20:09:37.052] [fetchers-akka.actor.default-dispatcher-3] [akka://fetchers/user/$a] rkuhn -> arnbak, uzoice, jond3k, TimothyKlim, relrod, ...

```

<title>Queue control and the pull pattern</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 队列控制和拉模式

我们现在已经定义了爬虫应用程序中的三个工作者角色。下一步是定义经理。*获取器管理器*负责保存一个要获取的登录名队列以及一组我们已经看到的登录名，以避免多次获取相同的登录名。

第一种尝试可能涉及构建一个 actor，它保存一组我们已经看到的用户，并在给它一个新用户要获取时，将它分派给一个循环路由器用于获取。这种方法的问题是获取者邮箱中的消息数量会迅速积累:对于每个 API 查询，我们可能会得到数十个关注者，每个关注者都可能会返回到获取者的收件箱中。这让我们很难控制堆积的工作量。

这可能导致的第一个问题涉及 GitHub API 速率限制:即使有身份验证，我们也被限制在每小时 5000 个请求。一旦达到这个阈值，就停止查询是非常有用的。如果每个获取器都有成百上千的用户需要获取，我们就无法做出响应。

一个更好的替代方案是使用*拉*系统:当获取器发现自己空闲时，它们从中央队列请求工作。拉式系统在 Akka 很常见，当我们的生产者生产工作的速度比消费者处理工作的速度快时(参考 http://www.michaelpollmeier.com/akka-work-pulling-pattern/)。

经理和取物员之间的对话将按如下方式进行:

*   如果管理器从没有工作的状态变为有工作的状态，它会向所有提取器发送一个`WorkAvailable`消息。
*   每当一个获取器接收到一个`WorkAvailable`消息或者当它完成一项工作时，它就向队列管理器发送一个`GiveMeWork`消息。
*   当队列管理器接收到一条`GiveMeWork`消息时，如果没有工作可用或者受到限制，它将忽略该请求。如果它有工作，它发送一个`Fetch(user)`消息给 actor。

让我们从修改 fetcher 开始。您可以在本书提供的示例代码([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds))的`chap09/ghub_crawler`目录中找到本节的代码示例。我们将通过构造函数向获取器管理器传递一个引用。我们需要更改伴生对象来添加`WorkAvailable`消息和`props`工厂，以包含对管理器的引用:

```
// Fecther.scala

object Fetcher {

  case class Fetch(url:String)

  case object WorkAvailable

  def props(

    token:Option[String], 

    fetcherManager:ActorRef, 

    responseInterpreter:ActorRef):Props =

      Props(classOf[Fetcher], 

        token, fetcherManager, responseInterpreter)

}
```

我们还需要改变`receive`方法，这样一旦处理完一个请求或者当它收到一个`WorkAvailable`消息时，它就会询问`FetcherManager`请求更多的工作。

这是 fetchers 的最终版本:

```
class Fetcher(

  val token:Option[String], 

  val fetcherManager:ActorRef,

  val responseInterpreter:ActorRef) 

extends Actor with ActorLogging {

  import Fetcher._

  import context.dispatcher

  def receive = {

    case Fetch(login) => fetchFollowers(login)

    case WorkAvailable => 

      fetcherManager ! FetcherManager.GiveMeWork

  }

  private def fetchFollowers(login:String) {

    val unauthorizedRequest = Http(

      s"https://api.github.com/users/$login/followers")

    val authorizedRequest = token.map { t =>

      unauthorizedRequest.header("Authorization", s"token $t")

    }

    val request = authorizedRequest.getOrElse(unauthorizedRequest)

    val response = Future { request.asString }

    response.onComplete { r =>

      responseInterpreter ! 

        ResponseInterpreter.InterpretResponse(login, r)

      fetcherManager ! FetcherManager.GiveMeWork

    }

  }

}
```

现在我们有了 fetchers 的工作定义，让我们构建`FetcherManager`。这是迄今为止我们构建的最复杂的 actor，在我们开始构建它之前，我们需要了解更多关于 Akka 工具包组件的知识。

<title>Accessing the sender of a message</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 访问消息的发送者

当我们的获取器管理器收到一个`GiveMeWork`请求时，我们需要将工作发送回正确的获取器。我们可以使用`sender`方法访问发送消息的参与者，这是`Actor`的一个方法，它返回与发送当前正在处理的消息的参与者相对应的`ActorRef`。因此，与获取器管理器中的`GiveMeWork`相对应的`case`语句为:

```
def receive = {

  case GiveMeWork =>

    login = // get next login to fetch

    sender ! Fetcher.Fetch(login)

  ...

}
```

由于`sender`是一个*方法*，它的返回值将随着每个新消息的到来而改变。因此，它只能与`receive`方法同步使用。特别是，在未来使用它是危险的:

```
def receive = {

  case DoSomeWork =>

    val work = Future { Thread.sleep(20000) ; 5 }

    work.onComplete { result => 

      sender ! Complete(result) // NO!

    }

}
```

问题是，当未来在消息被处理后 20 秒完成时，参与者很可能正在处理不同的消息，因此`sender`的返回值将会改变。因此，我们将把`Complete`消息发送给一个完全不同的参与者。

如果您需要在`receive`方法之外回复消息，比如当未来完成时，您应该将当前发送者的值绑定到一个变量:

```
def receive = {

  case DoSomeWork =>

    // bind the current value of sender to a val

    val requestor = sender

    val work = Future { Thread.sleep(20000) ; 5 }

    work.onComplete { result => requestor ! Complete(result) }

}
```

<title>Stateful actors</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 有状态参与者

取货者管理器的行为取决于它是否有工作分配给取货者:

*   如果它有工作要做，它需要用一个`Fetcher.Fetch`消息来响应`GiveMeWork`消息
*   如果它没有工作，它必须忽略`GiveMeWork`消息，如果增加了工作，它必须发送一个`WorkAvailable`消息给获取器

在 Akka 中，对状态的概念进行编码非常简单。我们指定不同的`receive`方法，并根据状态从一种方法切换到另一种方法。我们将为我们的提取器管理器定义以下`receive`方法，对应于每个状态:

```
// receive method when the queue is empty

def receiveWhileEmpty: Receive = { 

    ... 

}

// receive method when the queue is not empty

def receiveWhileNotEmpty: Receive = {

    ...

}
```

注意，我们必须将接收方法的返回类型定义为`Receive`。为了将 actor 从一种方法切换到另一种方法，我们可以使用`context.become(methodName)`。因此，例如，当最后一个登录名被弹出队列时，我们可以过渡到使用带有`context.become(receiveWhileEmpty)`的`receiveWhileEmpty`方法。我们通过将`receiveWhileEmpty`分配给`receive`方法来设置初始状态:

```
def receive = receiveWhileEmpty
```

<title>Follower network crawler</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 跟随者网络爬虫

我们现在准备编写网络爬虫的剩余部分。最大的缺失是 fetcher 管理器。让我们从伴星开始。与 worker actors 一样，它只包含 actor 可以接收的消息的定义和创建`Props`实例的工厂:

```
// FetcherManager.scala

import scala.collection.mutable

import akka.actor._

object FetcherManager {

  case class AddToQueue(login:String)

  case object GiveMeWork

  def props(token:Option[String], nFetchers:Int) = 

    Props(classOf[FetcherManager], token, nFetchers)

}
```

管理器可以接收两个消息:`AddToQueue`，告诉它将一个用户名添加到需要获取其追随者的用户队列中，以及`GiveMeWork`，由获取者在失业时发出。

管理器将负责启动获取器、响应解释器和追随者提取器，并维护用户名的内部队列和我们已经看到的一组用户名:

```
// FetcherManager.scala

class FetcherManager(val token:Option[String], val nFetchers:Int) 

extends Actor with ActorLogging {

  import FetcherManager._

  // queue of usernames whose followers we need to fetch

  val fetchQueue = mutable.Queue.empty[String]

  // set of users we have already fetched. 

  val fetchedUsers = mutable.Set.empty[String]

  // Instantiate worker actors

  val followerExtractor = context.actorOf(

    FollowerExtractor.props(self))

  val responseInterpreter = context.actorOf(

    ResponseInterpreter.props(followerExtractor))

  val fetchers = (0 until nFetchers).map { i =>

    context.actorOf(

      Fetcher.props(token, self, responseInterpreter))

  }

  // receive method when the actor has work:

  // If we receive additional work, we just push it onto the

  // queue.

  // If we receive a request for work from a Fetcher,

  // we pop an item off the queue. If that leaves the 

  // queue empty, we transition to the 'receiveWhileEmpty'

  // method.

  def receiveWhileNotEmpty:Receive = {

    case AddToQueue(login) => queueIfNotFetched(login)

    case GiveMeWork =>

      val login = fetchQueue.dequeue

      // send a Fetch message back to the sender.

      // we can use the `sender` method to reply to a message

      sender ! Fetcher.Fetch(login)

      if (fetchQueue.isEmpty) { 

        context.become(receiveWhileEmpty) 

      }

  }

  // receive method when the actor has no work:

  // if we receive work, we add it onto the queue, transition

  // to a state where we have work, and notify the fetchers

  // that work is available.

  def receiveWhileEmpty:Receive = {

    case AddToQueue(login) =>

      queueIfNotFetched(login)

      context.become(receiveWhileNotEmpty)

      fetchers.foreach { _ ! Fetcher.WorkAvailable }

    case GiveMeWork => // do nothing

  }

  // Start with an empty queue.

  def receive = receiveWhileEmpty

  def queueIfNotFetched(login:String) {

    if (! fetchedUsers(login)) {

      log.info(s"Pushing $login onto queue") 

      // or do something useful...

      fetchQueue += login

      fetchedUsers += login

    }

  }

}
```

我们现在有一个 fetcher 管理器。除了从动提取器之外，其余的代码可以保持不变。代替记录追随者名字的，它必须发送`AddToQueue`消息给管理者。我们将在构造时向管理器传递一个引用:

```
// FollowerExtractor.scala

import akka.actor._

import org.json4s._

import org.json4s.native.JsonMethods._

object FollowerExtractor {

  // messages

  case class Extract(login:String, jsonResponse:JArray)

  // props factory method

  def props(manager:ActorRef) = 

    Props(classOf[FollowerExtractor], manager)

}

class FollowerExtractor(manager:ActorRef)

extends Actor with ActorLogging {

  import FollowerExtractor._

  def receive = {

    case Extract(login, followerArray) =>

      val followers = extractFollowers(followerArray)

      followers foreach { f => 

        manager ! FetcherManager.AddToQueue(f) 

      }

  }

  def extractFollowers(followerArray:JArray) = for {

    JObject(follower) <- followerArray

    JField("login", JString(login)) <- follower

  } yield login

}
```

运行这一切的`main`方法非常简单，因为实例化 actors 的所有代码都被转移到了`FetcherManager`中。我们只需要实例化管理器，并给它网络中的第一个节点，它将完成剩下的工作:

```
// FetchNetwork.scala

import akka.actor._

object FetchNetwork extends App {

  // Get token if exists

  val token = sys.env.get("GHTOKEN")

  val system = ActorSystem("GithubFetcher")

  val manager = system.actorOf(FetcherManager.props(token, 2))

  manager ! FetcherManager.AddToQueue("odersky")

}
```

请注意，我们不再试图关闭 actor 系统。我们将让它运行，爬行网络，直到我们停止它或达到认证限制。让我们在 SBT 运行这个:

```

$ GHTOKEN="2502761d..." sbt "runMain FetchNetwork"

[INFO] [11/06/2015 06:31:04.614] [GithubFetcher-akka.actor.default-dispatcher-2] [akka://GithubFetcher/user/$a] Pushing odersky onto queue

[INFO] [11/06/2015 06:31:05.563] [GithubFetcher-akka.actor.default-dispatcher-4] [akka://GithubFetcher/user/$a] Pushing misto onto queueINFO] [11/06/2015 06:31:05.563] [GithubFetcher-akka.actor.default-dispatcher-4] [akka://GithubFetcher/user/$a] Pushing gkossakowski onto queue

^C

```

我们的程序除了记录追随者之外，实际上并不对他们做任何有用的事情。我们可以替换`log.info`调用，例如，将节点存储在数据库中或将图形绘制到屏幕上。

<title>Fault tolerance</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 容错

真正的程序会失败，而且会以不可预知的方式失败。Akka 和 Scala 社区总体上倾向于明确地为失败做准备，而不是试图编写可靠的应用程序。*容错*系统是指当一个或多个组件出现故障时仍能继续运行的系统。单个子系统的失败并不一定意味着应用程序的失败。这如何适用于 Akka？

参与者模型提供了封装失败的自然单元:参与者。当一个参与者在处理消息时抛出异常，默认行为是让参与者重新启动，但是异常不会泄漏出来并影响系统的其余部分。例如，让我们在响应解释器中引入一个任意的失败。我们将修改`receive`方法，在要求它解释马丁·奥德斯基的追随者之一 `misto`的响应时抛出一个异常:

```
// ResponseInterpreter.scala

def receive = {

  case InterpretResponse("misto", r) => 

    throw new IllegalStateException("custom error")

  case InterpretResponse(login, r) => interpret(login, r)

}
```

如果您通过 SBT 重新运行代码，您会注意到记录了一个错误。然而，程序不会崩溃。它只是像平常一样继续:

```

[ERROR] [11/07/2015 12:05:58.938] [GithubFetcher-akka.actor.default-dispatcher-2] [akka://GithubFetcher/user/$a/$b] custom error

java.lang.IllegalStateException: custom error

 at ResponseInterpreter$

 ...

[INFO] [11/07/2015 12:05:59.117] [GithubFetcher-akka.actor.default-dispatcher-2] [akka://GithubFetcher/user/$a] Pushing samfoo onto queue

```

没有一个`misto`的追随者会被加入队列:他从未通过`ResponseInterpreter`阶段。让我们一步一步地看看抛出异常时会发生什么:

*   向解释器发送`InterpretResponse("misto", ...)`消息。这会导致它抛出异常并终止。其他参与者都不会受到该异常的影响。
*   使用与最近去世的演员相同的道具实例来创建响应解释器的新实例。
*   当响应解释器完成初始化时，它会绑定到与已故演员相同的`ActorRef`。这意味着，就系统的其余部分而言，一切都没有改变。
*   邮箱被绑定到`ActorRef`而不是 actor，因此新的响应解释器将拥有与其前任相同的邮箱，没有令人不快的消息。

因此，无论出于什么原因，如果我们的爬虫在获取或解析用户的响应时崩溃，应用程序将受到最小的影响——我们只是不会获取该用户的关注者。

当重新启动时，参与者拥有的任何内部状态都会丢失。因此，例如，如果 fetcher 管理器死亡，我们将丢失队列和已访问用户的当前值。与丢失内部状态相关联的风险可以通过以下方式来减轻:

*   对失败采取不同的策略:例如，我们可以继续处理消息，而不需要在失败时重启参与者。当然，如果演员因为内部状态不一致而死亡，这就没什么用了。在下一节中，我们将讨论如何改变故障恢复策略。
*   通过定期将内部状态写入磁盘并在重启时从备份中加载来备份内部状态。
*   通过确保将所有“有风险的”操作委托给其他参与者来保护具有关键状态的参与者。在我们的爬虫示例中，所有与外部服务的交互，比如查询 GitHub API 和解析响应，都发生在没有内部状态的参与者身上。正如我们在前面的例子中看到的，如果其中一个参与者死亡，应用程序受到的影响很小。相比之下，precious fetcher 管理器只允许与净化的输入交互。这被称为*错误内核*模式:可能导致错误的代码被委托给神风行动者。

<title>Custom supervisor strategies</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 定制主管策略

失败时重启参与者的默认策略并不总是我们想要的。特别是，对于携带大量数据的 actor，我们可能希望在异常后恢复处理，而不是重新启动 actor。Akka 让我们通过在演员的主管中设置一个*主管策略*来定制这种行为。

回想一下，所有演员都有父母，包括顶级演员，他们是名为*用户监护人*的特殊演员的孩子。默认情况下，一个参与者的主管是他的父母，主管决定在失败时对参与者采取什么措施。

因此，要改变参与者对失败的反应，您必须设置其父级的主管策略。通过设置`supervisorStrategy`属性可以做到这一点。默认策略相当于以下策略:

```
val supervisorStrategy = OneForOneStrategy() {

  case _:ActorInitializationException => Stop

  case _:ActorKilledException => Stop

  case _:DeathPactException => Stop

  case _:Exception => Restart

}
```

主管战略有两个组成部分:

*   `OneForOneStrategy`确定策略仅适用于失败的参与者。相比之下，我们可以使用`AllForOneStrategy`，它对所有被监管者应用相同的策略。如果单个子进程失败，所有子进程都将重新启动(或者停止或恢复)。
*   将`Throwables`映射到`Directive`的部分功能，这是关于如何响应故障的指令。例如，默认策略将`ActorInitializationException`(如果构造函数失败就会发生)映射到`Stop`指令，并将(几乎所有)其他异常映射到`Restart`。

有四个指令:

*   `Restart`:这摧毁了出错的演员，并重新启动它，将新生演员绑定到旧演员`ActorRef`。这清除了参与者的内部状态，这可能是一件好事(参与者可能因为一些内部不一致而失败)。
*   `Resume`:参与者只是继续处理收件箱中的下一条消息。
*   `Stop`:演员停止，不重启。这在您用来完成单个操作的一次性参与者中很有用:如果该操作失败，就不再需要该参与者。
*   主管自己重新抛出异常，希望它的主管知道如何处理它。

主管无权访问其失败的子级。因此，如果一个演员有可能需要不同恢复策略的孩子，最好创建一组中间监督演员来监督不同的孩子组。

作为设置管理器策略的一个例子，让我们调整`FetcherManager`管理器策略，采用全对一策略，并在其中一个失败时停止其子策略。我们从相关的进口开始:

```
import akka.actor.SupervisorStrategy._
```

然后，我们只需要在`FetcherManager`定义中设置`supervisorStrategy`属性:

```
class FetcherManager(...) extends Actor with ActorLogging {

  ...

  override val supervisorStrategy = AllForOneStrategy() {

    case _:ActorInitializationException => Stop

    case _:ActorKilledException => Stop

    case _:Exception => Stop

  }

  ...

}
```

如果您通过 SBT 运行它，您会注意到当代码遇到由响应解释器抛出的自定义异常时，系统会暂停。这是因为除了 fetcher manager 之外的所有演员现在都死了。

<title>Life-cycle hooks</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 生命周期挂钩

Akka 让我们通过*生命周期钩子*来指定响应演员生活中特定事件而运行的代码。Akka 定义了以下挂钩:

*   `preStart()`:在 actor 的构造函数完成之后，开始处理消息之前运行。这对于运行依赖于完全构造的 actor 的初始化代码很有用。
*   `postStop()`:当 actor 在停止处理消息后死亡时运行。这对于在终止执行元之前运行清理代码很有用。
*   这是在一个演员收到重新开始的命令后调用的。`preRestart`方法可以访问抛出的异常和有问题的消息，允许采取纠正措施。`preRestart`的默认行为是让每个孩子停下来，然后调用`postStop`。
*   `postRestart(reason:Throwable)`:在一个 actor 重启后调用。默认行为是调用`preStart()`。

让我们使用系统钩子在程序运行之间保持`FetcherManager`的状态。您可以在本书提供的示例代码(【https://github.com/pbugnion/s4ds】)中的`chap09/ghub_crawler_fault_tolerant`目录下找到本节的代码示例。这将使提取器管理器容错。我们将使用`postStop`将当前队列和已访问用户集写入文本文件，使用`preStart`从磁盘中读取这些文本文件。让我们从导入读写文件所需的库开始:

```
// FetcherManager.scala

import scala.io.Source 

import scala.util._

import java.io._
```

我们将存储两个文本文件的名称，其中我们将状态保存在`FetcherManager`伴随对象中(更好的方法是将它们存储在配置文件中):

```
// FetcherManager.scala

object FetcherManager {

  ...

  val fetchedUsersFileName = "fetched-users.txt"

  val fetchQueueFileName = "fetch-queue.txt"

}
```

在`preStart`方法中，我们从文本文件中加载已获取的用户集和待获取的用户积压，在`postStop`方法中，我们用这些数据结构的新值覆盖这些文件:

```
class FetcherManager(

  val token:Option[String], val nFetchers:Int

) extends Actor with ActorLogging {

  ...

  /** pre-start method: load saved state from text files */

  override def preStart {

    log.info("Running pre-start on fetcher manager")

    loadFetchedUsers

    log.info(

      s"Read ${fetchedUsers.size} visited users from source"

    )

    loadFetchQueue

    log.info(

      s"Read ${fetchQueue.size} users in queue from source"

    )

    // If the saved state contains a non-empty queue, 

    // alert the fetchers so they can start working.

    if (fetchQueue.nonEmpty) {

      context.become(receiveWhileNotEmpty)

      fetchers.foreach { _ ! Fetcher.WorkAvailable }

    }

  }

  /** Dump the current state of the manager */

  override def postStop {

    log.info("Running post-stop on fetcher manager")

    saveFetchedUsers

    saveFetchQueue

  }

     /* Helper methods to load from and write to files */

  def loadFetchedUsers {

    val fetchedUsersSource = Try { 

      Source.fromFile(fetchedUsersFileName) 

    }

    fetchedUsersSource.foreach { s =>

      try s.getLines.foreach { l => fetchedUsers += l }

      finally s.close

    }

  }

  def loadFetchQueue {

    val fetchQueueSource = Try { 

      Source.fromFile(fetchQueueFileName) 

    }

    fetchQueueSource.foreach { s =>

      try s.getLines.foreach { l => fetchQueue += l }

      finally s.close

    }

  }

  def saveFetchedUsers {

    val fetchedUsersFile = new File(fetchedUsersFileName)

    val writer = new BufferedWriter(

      new FileWriter(fetchedUsersFile))

    fetchedUsers.foreach { user => writer.write(user + "\n") }

    writer.close()

  }

  def saveFetchQueue {

    val queueUsersFile = new File(fetchQueueFileName)

    val writer = new BufferedWriter(

      new FileWriter(queueUsersFile))

    fetchQueue.foreach { user => writer.write(user + "\n") }

    writer.close()

  }

...

}
```

既然我们保存了爬虫程序关闭时的状态，我们可以为程序设置一个更好的终止条件，而不是在我们厌倦时简单地中断程序。例如，在生产中，当数据库中有足够多的名字时，我们可能会停止爬行器。在这个例子中，我们将简单地让爬虫运行 30 秒，然后关闭它。

让我们修改一下`main`方法:

```
// FetchNetwork.scala

import akka.actor._

import scala.concurrent.ExecutionContext.Implicits.global

import scala.concurrent.duration._

object FetchNetwork extends App {

  // Get token if exists

  val token = sys.env.get("GHTOKEN")

  val system = ActorSystem("GithubFetcher")

  val manager = system.actorOf(FetcherManager.props(token, 2))

  manager ! FetcherManager.AddToQueue("odersky")

  system.scheduler.scheduleOnce(30.seconds) { system.shutdown }

}
```

30 秒后，我们只需调用`system.shutdown`，递归地停止所有的演员。这将停止 fetcher 管理器，调用`postStop`生命周期钩子。程序运行一次后，我在`fetched-users.txt`档案中有 2164 个名字。再次运行它会将这个数字增加到 3，728 个用户。

当代码运行时，我们可以通过让 fetcher 管理器定期转储数据结构来进一步提高容错能力。因为写入磁盘(或数据库)会带来一定的风险(如果数据库服务器停机或磁盘已满怎么办？)最好将编写数据结构的任务委托给一个定制的参与者，而不是让经理陷入危险。

我们的爬虫有一个小问题:当提取器管理器停止时，它会停止提取器参与者、响应解释器和跟随器提取器。但是，没有存储当前正在经历这些角色的用户。这也导致在代码末尾有少量未交付的消息:如果响应解释器在提取器之前停止，提取器将试图向不存在的参与者交付。这只占了一小部分用户。为了恢复这些登录名，我们可以创建一个收割者角色，它的工作是按照正确的顺序协调所有工人角色的杀戮，并收割他们的内部状态。这种模式在*德里克·怀亚特*([http://letit crash . com/post/30165507578/shut down-patterns-in-akka-2](http://letitcrash.com/post/30165507578/shutdown-patterns-in-akka-2))的博客文章中有记载。

<title>What we have not talked about</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 我们没有谈到的

Akka 是一个非常丰富的生态系统，丰富得无法用一章来描述。工具箱中有一些您需要的重要部分，但是我们在这里没有涉及到它们。我们将给出简要的描述，但是您可以参考 Akka 文档来了解更多细节:

*   ask 操作符`?`提供了 tell 操作符`!`的一种替代方式，我们已经使用它向参与者发送消息。与“tell”不同，它只是向参与者发送一条消息，而 ask 操作符需要一个响应。当我们需要问演员问题而不仅仅是告诉他们做什么时，这是很有用的。ask 模式记录在[http://doc . akka . io/docs/akka/snapshot/Scala/actors . html # Ask _ _ Send-And-Receive-Future](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Ask__Send-And-Receive-Future)中。
*   死亡观察允许演员观看另一个演员，并在它死亡时接收消息。这对于可能依赖于另一个参与者但不是其直接主管的参与者非常有用。这在[http://doc . akka . io/docs/akka/snapshot/Scala/actors . html # life cycle _ Monitoring _ aka _ death watch](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Lifecycle_Monitoring_aka_DeathWatch)中有所记载。
*   在我们的爬虫中，我们通过构造函数显式地传递对参与者的引用。我们还可以使用 actor 层次结构来查找 Actor，该层次结构的语法让人想起文件系统中位于[http://doc . akka . io/docs/akka/snapshot/Scala/Actors . html # Identifying _ Actors _ via _ Actor _ Selection](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Identifying_Actors_via_Actor_Selection)的文件。
*   我们简要地探讨了如何用不同的接收方法实现有状态参与者，并使用`context.become`在它们之间切换。Akka 提供了一个更强大的替代方案，基于有限状态机来编码一组更复杂的状态和转换:[http://doc.akka.io/docs/akka/snapshot/scala/fsm.html](http://doc.akka.io/docs/akka/snapshot/scala/fsm.html)。
*   在本章中，我们还没有讨论在几个节点上分布 actor 系统。消息传递架构很适合分布式设置:[http://doc.akka.io/docs/akka/2.4.0/common/cluster.html](http://doc.akka.io/docs/akka/2.4.0/common/cluster.html)。

<title>Summary</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 总结

在这一章中，你学习了如何组织参与者来解决一个并发的难题。更重要的是，我们看到了 Akka 的 actor 框架是如何鼓励我们根据封装的可变数据的许多独立块来考虑并发问题的，这些块通过消息传递来同步。Akka 使得并发编程更容易推理，也更有趣。

<title>References</title><link href="epub.css" rel="stylesheet" type="text/css"> 

# 参考文献

德里克·怀亚特的书， *Akka 并发*，是对 Akka 的精彩介绍。对于任何想做严肃的 Akka 编程的人来说，它绝对应该是第一站。

**让它崩溃** 博客([http://letitcrash.com](http://letitcrash.com))是 Akka 的官方博客，包含许多解决常见问题的习语和模式的例子。