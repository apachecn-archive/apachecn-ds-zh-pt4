

# 一、用于数据科学的 Python

在本章中，我们将介绍以下配方:

*   使用字典对象
*   使用字典中的字典
*   使用元组
*   使用集合
*   写清单
*   从另一个列表创建列表-列表理解
*   使用迭代器
*   生成迭代器和生成器
*   使用可重复项
*   将函数作为变量传递
*   在另一个函数中嵌入函数
*   将函数作为参数传递
*   返回一个函数
*   用装饰器改变函数行为
*   用 lambda 创建匿名函数
*   使用地图功能
*   使用过滤器
*   使用 zip 和 izip
*   从表格数据处理数组
*   预处理列
*   排序列表
*   用关键字排序
*   使用 itertools



# 简介

Python 编程语言提供了许多内置的数据结构和函数，对于数据科学编程来说非常方便。在这一章中，我们将看看一些最常用的。在随后的章节中，你会看到这些将在不同的主题的不同章节中使用。从长远来看，很好地掌握这些将有助于你快速启动一个程序来处理数据和开发算法。

虽然本章是对方便的数据结构和方法的快速概述，但是当您成为一名经验丰富的 Python 用户时，您将开始发现自己组合这些数据结构的方法来满足您的需求。

这些数据结构中的每一个都有一个实用程序，尽管不同的环境可能需要使用两个或更多的数据结构来满足您的需求。你会在本书的一些例子中看到这一点。



# 使用字典对象

在 Python 中，容器是可以容纳任意数量的任意对象的对象。它们提供了一种方法来访问子对象并遍历它们。字典、元组、列表和集合是 Python 中的容器对象。`collections`模块提供更多容器类型。让我们在这一节中详细看看 dictionary 对象。



## 准备就绪

让我们看一个示例 Python 脚本来理解字典是如何操作的。因此，对于一个文本，这个脚本试图获得字数，即每个单词在给定文本中出现了多少次。



## 怎么做……

让我们继续演示如何在 Python 中操作字典。让我们用一个简单的句子来演示字典的用法。接下来，我们将创建一个实际的词典:

```py
# 1.Load a variable with sentences
sentence = "Peter Piper picked a peck of pickled peppers A peck of pickled \
peppers Peter Piper picked If Peter Piper picked a peck of pickled \
peppers Wheres the peck of pickled peppers Peter Piper picked"

# 2.Initialize a dictionary object
word_dict = {}

# 3.Perform the word count
for word in sentence.split():
    if word not in word_dict:
        word_dict[word] =1
    else:  
        word_dict[word]+=1
# 4.print the outputprint (word_dict)
```



## 它是如何工作的……

前面的代码建立一个词频表；每个单词和它的频率都被计算出来。最终的 print 语句产生以下输出:

```py
{'a': 2, 'A': 1, 'Peter': 4, 'of': 4, 'Piper': 4, 'pickled': 4, 'picked': 4, 'peppers': 4, 'the': 1, 'peck': 4, 'Wheres': 1, 'If': 1}
```

前面的输出是一个键值对。对于每个单词(键)，我们都有一个频率(值)。字典数据结构是一个哈希表，其中的值是根据一个键存储的。在前面的例子中，我们使用了一个字符串作为键；但是，任何其他不可变的数据类型也可以用作键。

有关 Python 中可变和不可变异议的详细讨论，请参考以下 URL:

[https://docs.python.org/2/reference/datamodel.html](https://docs.python.org/2/reference/datamodel.html)

类似地，值可以是任何数据类型，包括自定义类。

在第 2 步中，我们初始化了字典。初始化时它是空的。当一个新键被添加到字典中时，通过新键访问字典将抛出`KeyError`。在前面步骤 3 的例子中，我们在 for 循环中包含了一个 if 语句来处理这种情况。但是，我们也可以使用以下内容:

```py
word_dict.setdefault(word,0)
```

对于每个访问字典的键，如果我们在循环中向字典添加元素，就必须重复这个语句，因为在循环中，我们不知道新的键。使用`setdefault`重写步骤 3，如下所示:

```py
for word in sentence.split():
word_dict.setdefault(word,0)
word_dict[word]+=1
```



## 还有更多……

Python 2.5 及以上有一个名为`defaultdict`的类；在`collections`模块里。这就搞定了`setdefault`行动。如下调用一个`defaultdict`类:

```py
from collections import defaultdict

sentence = "Peter Piper picked a peck of pickled peppers  A peck of pickled \
            peppers Peter Piper picked If Peter Piper picked a peck of pickled \
            peppers Wheres the peck of pickled peppers Peter Piper picked"

word_dict = defaultdict(int)

for word in sentence.split():
    word_dict[word]+=1print word_dict   
```

正如您已经注意到的,我们在代码中包含了`collections.defaultdict`,并初始化了我们的字典。注意，`int`参数`defaultdict`将一个函数作为参数。在这种情况下，我们传递了`int()`函数，因此，当字典遇到一个以前没有见过的键时，它用`int()`函数返回的值初始化这个键，在这种情况下是零。我们将在本书后面使用`defaultdict`。

### 注意

典型的字典不记得键被插入的顺序。在其 collections 模块中，Python 提供了一个名为`OrderedDict`的容器，它可以记住键的插入顺序。更多的细节参见下面的Python 文档:

[https://docs . python . org/2/library/collections . html # collections。OrderedDict](https://docs.python.org/2/library/collections.html#collections.OrderedDict)

在字典中循环是非常容易的；使用字典中提供的 keys()函数，我们可以循环访问键，使用 values()，我们可以循环访问值，或者使用 items()，我们可以循环访问键和值。请看下面的例子:

```py
For key, value in word_dict.items():
print key,value
```

在这个例子中，使用`dict.items()`，我们可以遍历字典中的键和值。

用于字典的 Python 文档非常详尽，是使用字典时的便利伴侣:

[https://docs . python . org/2/tutorial/data structures . html # dictionary](https://docs.python.org/2/tutorial/datastructures.html#dictionaries)

字典作为一种中间数据结构非常有用。如果您的程序使用 JSON 作为在模块间移动信息的方式，dictionary 是适合这项工作的数据类型。从 JSON 文件加载字典非常方便，同样地，将字典作为 JSON 字符串转储也非常方便。

Python 为我们提供了非常有效地处理 JSON 的库:

[https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)

Counter 是一个字典子类，用于计算可散列对象的数量。我们的单词计数的例子可以很容易地用 counter 来完成。

请看下面的例子:

```py
from collections import Counter

sentence = "Peter Piper picked a peck of pickled peppers  A peck of pickled \
            peppers Peter Piper picked If Peter Piper picked a peck of pickled \
            peppers Wheres the peck of pickled peppers Peter Piper picked"

words = sentence.split()

word_count = Counter(words)

print word_count['Peter']print word_dict   
```

输出如下,您可以用之前的输出来验证这个输出:

```py
Counter({'Peter': 4, 'of': 4, 'Piper': 4, 'pickled': 4, 'picked': 4, 'peppers': 4, 'peck': 4, 'a': 2, 'A': 1, 'the': 1, 'Wheres': 1, 'If': 1})
```

您可以通过以下链接了解更多关于计数器的信息:

[https://docs . python . org/2/library/collections . html # collections。计数器](https://docs.python.org/2/library/collections.html#collections.Counter)



## 参见

*   *使用字典中的字典*第一章中的菜谱[，*使用 Python 进行数据科学*](part0015_split_000.html#E9OE1-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 1. Python for Data Science")



# 使用字典中的字典

正如我们前面提到的，这些数据结构的真正力量在于你如何创造性地使用它们来完成你的任务。让我们看一个例子来了解如何在字典中使用字典。



## 准备就绪

请看下表:

![Getting ready](img/00004.jpeg)

在第一列中，我们有三个用户，其余的列是电影。单元格值是用户对电影给出的评级。假设我们想在内存中表示它，这样一个更大的代码库的其他部分就可以很容易地访问这些信息。我们将使用字典中的字典来实现这个目标。



## 怎么做……

我们将使用匿名函数来创建`user_movie_rating`字典，以演示字典的字典的概念。

我们将用数据来填充它，以显示字典对字典的有效使用:

```py
from collections import defaultdict

user_movie_rating = defaultdict(lambda :defaultdict(int))

# Initialize ratings for Alice
user_movie_rating["Alice"]["LOR1"] =  4
user_movie_rating["Alice"]["LOR2"] =  5
user_movie_rating["Alice"]["LOR3"] =  3
user_movie_rating["Alice"]["SW1"]  =  5
user_movie_rating["Alice"]["SW2"]  =  3
print user_movie_rating
```



## 它是如何工作的……

`user_movie_rating`是字典中的字典。正如上一节所解释的，`defaultdict`接受一个函数作为自变量；在这个例子中，我们传递了一个内置的匿名函数，`lambda`，它返回一个字典。所以，每次一个新的键被传递给`user_movie_rating`，就会为这个键创建一个新的字典。我们将在接下来的章节中看到更多关于`lambda`函数的内容。

这样，我们可以非常快速地访问任何用户电影组合的评级。类似地，在很多用例中，字典中的字典非常方便。

作为字典的结束语，我想提一下，对字典数据结构的良好掌握将有助于减轻您的许多数据科学编程任务。正如我们将在后面看到的，字典经常被用来存储机器学习中的特征和标签。Python NLTK 库广泛使用字典来存储文本挖掘中的特性:

[http://www.nltk.org/book/ch05.html](http://www.nltk.org/book/ch05.html)

标题为*使用 Python 字典将单词映射到属性*的部分是理解如何有效使用字典的好读物。



## 参见

*   *创建匿名函数*方法[第一章](part0015_split_000.html#E9OE1-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 1. Python for Data Science")，*使用 Python 进行数据科学*



# 使用元组

tuple 是一种类型的容器对象，在 Python 中称为序列类型。元组是不可变的，并且可以具有由逗号分隔并括在括号中的异构元素序列。它们支持以下操作:

*   `in`和`not in`
*   比较、连接、切片和索引
*   `min()`和`max()`



## 准备就绪

我们将把元组视为碎片代码，而不是像字典那样拥有一个完整的程序，在这里我们将专注于创建和操作活动。



## 怎么做……

让我们来看一些演示元组的创建和操作的脚本:

```py
# 1.Ways of creating a tuple
a_tuple = (1,2,'a')
b_tuple =1,2,'c'

# 2.Accessing elements of a tuple through index
print b_tuple[0]
print b_tuple[-1]

# 3.It is not possible to change the value of an item in a tuple,
# for example the next statement will result in an error.
try:
    b_tuple[0] = 20
except:
    print "Cannot change value of tuple by index"    

# 4.Though tuples are immutable
# But elements of a tuple can be mutable objects,
# for instance a list, as in the following line of code
c_tuple =(1,2,[10,20,30])
c_tuple[2][0] = 100

# 5.Tuples once created cannot be extended like list, 
# however two tuples can be concatenated.

print a_tuple + b_tuple

# 6 Slicing of uples
a =(1,2,3,4,5,6,7,8,9,10)
print a[1:]
print a[1:3]
print a[1:6:2]
print a[:-1]

# 7.Tuple min max
print min(a),max(a)

# 8.in and not in
if 1 in a:
    print "Element 1 is available in tuple a"
else:
print "Element 1 is available in tuple a"
```



## 它是如何工作的……

在步骤 1 中，我们创建了一个元组。虽然严格来说，括号是不需要的，但为了更好的可读性，它仍然是一个选项。如您所见，我们创建了一个包含数值和字符串值的异构元组。步骤 2 详细说明了如何通过索引访问元组的元素。索引从零开始。负数可以用来反向访问元组。print 语句的输出如下:

```py
>>> print b_tuple[0]
1
>>> print b_tuple[-1]
c
>>> 
```

Python 元组索引从 0 开始。元组是不可变的。

在第 3 步中，我们将看看元组中最重要的属性——不变性。无法更改元组中项的值；步骤 3 将导致解释器抛出一个错误:

```py
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

这可能看起来有限制性；然而，从数据科学的角度来看，不可变特性具有巨大的价值。

### Tip

当构建用于机器学习的程序时，特别是在从原始数据生成特征期间，创建特征元组确保了值不会被下游程序改变。

因为这些特性存在于一个元组中，所以下游程序不会意外地改变特性值。

然而，我们想指出一个元组可以有一个可变对象作为它的成员，例如，一个列表。如果我们有一个如步骤 4 所示的元组，元组的第三个元素是一个列表。现在，让我们尝试更改列表中的一个元素:

```py
c_tuple[2][0] = 100
```

我们将打印元组，如下所示:

```py
print  c_tuple
```

我们将获得以下输出:

```py
(1, 2, [100, 20, 30])
```

如您所见，列表中第一个元素的值被更改为`100`。

在步骤 5 中，我们连接了两个元组。使用元组的另一个有趣的方式是当不同的模块为机器学习程序创建不同的特征时。

### Tip

例如，假设您有一个模块正在创建单词袋类型的特征，而另一个模块正在为典型的文本分类程序创建数字特征。这些模型可以输出元组，并且最终模块可以连接这些元组以获得完整的特征向量。

由于其不可变的属性，与列表不同，元组在创建后不能被扩展。它不支持`append`功能。这种不可变属性的另一个优点是元组可以用作字典中的键。

### Tip

通常，在创建键时，我们可能需要使用自定义分隔符连接不同的字符串值来创建唯一的键。相反，可以创建一个包含这些字符串值的元组来用作键。

这提高了程序输出的可读性，也避免了手动组合按键时出现的错误。

在第 6 步中，我们将详细描述元组中的切片操作。通常，为切片提供了三个数字，并用冒号分隔。第一个数字决定从哪个索引开始切片，第二个数字决定结束索引，最后一个数字用于步骤。步骤 6 中的示例将阐明这一点:

```py
print a[1:]
```

它输出如下:

```py
(2, 3, 4, 5, 6, 7, 8, 9, 10)
```

在本例中，我们只指定了起始索引号`1`。(记住指数从零开始。)我们从索引`1`开始得到了元组的一个切片。让我们看另一个例子:

```py
print a[1:3]
```

它输出如下:

```py
(2, 3)
```

这里，我们指定起始索引为`1`，结束索引为`3`。

### 注意

切片操作是右端的。

虽然我们将结束索引指定为`3`，但是输出将返回到索引`2`之前，即之前的一个索引。因此，我们将`2`和`3`作为输出片的一部分。最后，让我们提供所有三个参数以及开始和结束索引，后跟步长大小:

```py
print a[1:6:2]
```

它显示的输出如下:

```py
(2, 4, 6)
```

这里，我们的步长是`2`。除了起始和结束索引，我们还指定了步长。因此，它每次跳转两个索引，并产生如前所示的输出。

让我们来看看负指数:

```py
print a[:-1]
```

这里，我们使用了负指数。输出如下所示:

```py
(1, 2, 3, 4, 5, 6, 7, 8, 9)
```

除了最后一个元素之外，所有内容都在切片中返回:

```py
print a[::-1]
```

值得思考的是，前面语句的输出如下——好奇的读者应该能够理解我们是如何得到下面的输出的:

```py
(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
```

在第 7 步中，我们将展示我们可以在一个元组上使用`min()`和`max()`函数来获取元组的最小值和最大值:

```py
>>> print min(a), max(a)
1 10
>>>
```

在第 8 步中，我们将展示 In 和 not 中的条件运算符；这可以有效地用于确定一个元素是否是元组的一部分:

```py
if 1 in a:
    print "Element 1 is available in tuple a"
else:
    print "Element 1 is available in tuple a"
```



## 还有更多……

正如我们在上一节中看到的，我们通过索引来访问元组的元素。为了更好地提高程序的可读性，假设我们希望为元组中的每个元素指定一个名称，并通过名称来访问元素。这就是"命名夫妇"来拯救我们的地方。下面的 URL 给出了 namedtuple 的一个很好的文档:

[https://docs . python . org/2/library/collections . html # collections . named tuple](https://docs.python.org/2/library/collections.html#collections.namedtuple)

让我们看一个简单的例子来说明命名元组的用法:

```py
from collections import namedtuple

vector = namedtuple("Dimension",'x y z')
vec_1 = vector(1,1,1)
vec_2 = vector(1,0,1)

manhattan_distance = abs(vec_1.x - vec_2.x) + abs(vec_1.y - vec_2.y) \
                            + abs(vec_1.z - vec_2.z)

print "Manhattan distance between vectors = %d"%(manhattan_distance)
```

您可以看到，我们使用对象符号、`vec_1.x`、`vec_1.y`等访问了`vec_1`和`vec_2`的元素。我们现在有了一个可读性更好的程序，而不是使用他们的索引。`Vec_1.x`相当于`vec_1[0]`。



## 参见

*   *数据分析——探索和争论[第三章](part0043_split_000.html#190861-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 3. Data Analysis – Explore and Wrangle")、*中的*配方——分析数据——探索&争论*将文本表示为一个单词包。



# 使用集合

集合与列表数据结构非常相似，除了它们不允许重复。它是同质元素的无序集合。通常，集合用于从列表中删除重复的元素。但是，集合支持交集、并集、差集和对称差集等运算。这些操作在很多用例中非常方便。



## 准备就绪

在本节中，我们将编写一个小程序来理解集合数据结构的各种用途。在我们的例子中，我们将使用 Jaccard 的系数计算两个句子之间的相似性得分。我们将在后面的章节中详细了解 Jaccard 系数和类似的其他度量。下面是对这一措施的简要介绍。Jaccard 的系数是一个介于 0 和 1 之间的数字，其中 1 表示高度相似。它是根据两个集合中有多少元素是相同的来计算的。



## 怎么做……

让我们看看一些用于集合创建和操作的 Python 脚本:

```py
# 1.Initialize two sentences.
st_1 = "dogs chase cats"
st_2 = "dogs hate cats"

# 2.Create set of words from strings
st_1_wrds = set(st_1.split())
st_2_wrds = set(st_2.split())

# 3.Find out the number of unique words in each set, vocabulary size.
no_wrds_st_1 = len(st_1_wrds)
no_wrds_st_2 = len(st_2_wrds)

# 4.Find out the list of common words between the two sets.
# Also find out the count of common words.
cmn_wrds = st_1_wrds.intersection(st_2_wrds)
no_cmn_wrds = len(st_1_wrds.intersection(st_2_wrds))

# 5.Get a list of unique words between the two sets.
# Also find out the count of unique words.
unq_wrds = st_1_wrds.union(st_2_wrds)
no_unq_wrds = len(st_1_wrds.union(st_2_wrds))

# 6.Calculate Jaccard similarity 
similarity = no_cmn_wrds / (1.0 * no_unq_wrds)

# 7.Let us now print to grasp our output.
print "No words in sent_1 = %d"%(no_wrds_st_1)
print "Sentence 1 words =", st_1_wrds
print "No words in sent_2 = %d"%(no_wrds_st_2)
print "Sentence 2 words =", st_2_wrds
print "No words in common = %d"%(no_cmn_wrds)
print "Common words =", cmn_wrds
print "Total unique words = %d"%(no_unq_wrds)
print "Unique words=",unq_wrds
print "Similarity = No words in common/No unique words, %d/%d = %.2f"%(no_cmn_wrds,no_unq_wrds,similarity)
```



## 它是如何工作的……

在步骤 1 和 2 中，我们取了两个句子，将它们拆分成单词，并使用`set()`函数创建了两个集合。函数可以用来将一个列表或元组转换成一个集合。请看下面的代码片段:

```py
>>> a =(1,2,1)
>>> set(a)
set([1, 2])
>>> b =[1,2,1]
>>> set(b)
set([1, 2]
```

在这个例子中，`a`是一个元组，`b`是一个列表。通过`set()`函数，重复项被删除，并返回一个集合对象。`st_1.split()`和`st_2.split()`方法返回一个列表，我们将把它传递给一个 set 函数来获取 set 对象。

现在让我们使用 Jaccard 的系数来计算两个句子之间的相似度得分。我们将在下一章的相似性度量小节中详细讨论 Jaccard 系数和其他相似的度量。我们将利用集合中可用的`union()`和`intersection()`函数来计算相似性得分。

在步骤 4 中，我们将执行两个操作。首先，使用`intersection()`函数，我们将尝试找出集合之间有哪些共同的单词。两句之间常用的词是`'cats'`和`'dogs'`。紧接着就是这个，我们会找出常用词的计数，是两个。下一步，我们将使用`union()`函数找出两个集合之间的唯一单词列表。这两句话之间唯一的词是`'cats'`、`'hate'`、`'dogs'`、`'chase'`。这有时被称为自然语言处理中的词汇。最后，我们将在步骤 6 中计算 Jaccard 的系数，这是两个集合之间的常用词计数与两个集合之间的独特词计数的比率。

该程序的输出如下所示:

```py
No words in sent_1 = 3
Sentence 1 words = set(['cats', 'dogs', 'chase'])
No words in sent_2 = 3
Sentence 2 words = set(['cats', 'hate', 'dogs'])
No words in common = 2
Common words = set(['cats', 'dogs'])
Total unique words = 4
Unique words= set(['cats', 'hate', 'dogs', 'chase'])
Similarity = No words in common/No unique words, 2/4 = 0.50
```



## 还有更多……

我们给出了前面的例子来说明集合函数的用法。但是，您可以使用 scikit-learn 等库中的内置函数。今后，我们将尽可能多地利用库中的这些函数，而不是手工编写这些实用函数:

```py
# Load libraries
from sklearn.metrics import jaccard_similarity_score

# 1.Initialize two sentences.
st_1 = "dogs chase cats"
st_2 = "dogs hate cats"

# 2.Create set of words from strings
st_1_wrds = set(st_1.split())
st_2_wrds = set(st_2.split())

unq_wrds = st_1_wrds.union(st_2_wrds)

a  =[ 1 if w in st_1_wrds else 0 for w in unq_wrds ]
b  =[ 1 if w in st_2_wrds else 0 for w in unq_wrds]

print a
print b
print jaccard_similarity_score(a,b)
```

输出如下所示:

```py
[1, 0, 1, 1]
[1, 1, 1, 0]
0.5
```



# 写清单

列表是一个容器对象和序列类型。它们类似于元组，除了它们是同质的和可变的。列表允许追加操作。它们也可以用作栈或队列。与元组不同，列表是可扩展的；创建列表后，可以使用 append 函数向列表中添加元素。



## 准备就绪

类似于我们看到的元组，我们将把列表看作是片断的代码，我们将集中精力于创建和操作活动，而不是像字典那样有一个完整的程序。



## 怎么做……

让我们看一些演示列表创建和操作活动的 Python 脚本:

```py
# 1.Let us look at a quick example of list creation. 
a = range(1,10)
print a
b = ["a","b","c"]
print b

# 2.List can be accessed through indexing. Indexing starts at 0.
print a[0]

# 3.With negative indexing the elements of a list are accessed from backwards.
a[-1]

# 4.Slicing is accessing a subset of list by providing two indices.
print a[1:3]  # prints [2, 3]
print a[1:]   # prints [2, 3, 4, 5, 6, 7, 8, 9]
print a[-1:]  # prints [9]
print a[:-1]  # prints [1, 2, 3, 4, 5, 6, 7, 8]

#5.List concatenation
a = [1,2]
b = [3,4]
print a + b # prints [1, 2, 3, 4]

# 6.	List  min max
print min(a),max(a)

# 7.	in and not in
if 1 in a:
    print "Element 1 is available in list a"
else:
    print "Element 1 is available in tuple a"

# 8\. Appending and extending list
a = range(1,10)
print a
a.append(10)
print a

# 9.List as a stack
a_stack = []

a_stack.append(1)
a_stack.append(2)
a_stack.append(3)

print a_stack.pop()
print a_stack.pop()
print a_stack.pop()

# 10.List as queue
a_queue = []

a_queue.append(1)
a_queue.append(2)
a_queue.append(3)

print a_queue.pop(0)
print a_queue.pop(0)
print a_queue.pop(0)

# 11.	List sort and reverse
from random import shuffle
a = range(1,20)
shuffle(a)
print a
a.sort()
print a

a.reverse()
print a
```



## 它是如何工作的……

在步骤 1 中，我们看到了创建列表的不同方法。请注意，我们只有同质元素。与集合不同，可以有重复项。步骤 2、3、4、5、6 和 7 类似于元组步骤。我们将不详细说明这些步骤。它们涵盖了类似于元组的索引、切片、连接、最小最大值、in 和 not in 操作。

步骤 8 展示了附加和扩展操作。这就是列表与元组不同的地方。(当然，我们知道这些列表是同质的。)让我们来看看第一部分代码的输出:

```py
>>> a = range(1,10)
>>> print a

[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a.append(10)
>>> print a
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>>
```

我们可以看到 10 被添加到了`a`列表中。

以下输出是显示 extend 的第二部分的输出:

```py
>>> b=range(11,15)
>>> a.extend(b)
>>> print a
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
>>>
```

我们用另一个列表`b`扩展了原来的`a`列表。

在第 9 步中，我们将展示如何使用一个列表作为栈。`pop()`函数有助于检索追加到列表中的最后一个元素。输出如下所示:

```py
3
2
1
```

要追加的最后一个元素是要取出的第一个元素**后进先出** ( **后进先出**)风格如同在栈中一样。

在第 10 步中，我们将使用一个列表实现一个队列。以零为参数的`pop()`函数表示要检索的元素的索引已经被传递。输出如下所示:

```py
1
2
3
```

输出遵循队列的 LIFO 风格。然而，这不是一个非常有效的方法。由于列表的实现方式，弹出第一个元素并不是最佳选择。执行这个操作的一个有效方法是使用下一节中解释的 deque 数据结构。

最后一步详述了列表中的排序和反向操作。列表有一个内置的函数`sort()`，用来对列表中的元素进行排序。默认情况下，它按升序排序。排序将在本章的后面部分详细解释。函数将反转列表中的元素。

我们将首先创建一个元素从 1 到 19 的列表:

```py
a = range(1,20)
```

我们将使用随机模块中的`shuffle()`函数来洗牌。这将打乱元素，以便我们可以演示排序操作。混洗后的输出如下:

```py
[19, 14, 11, 12, 4, 13, 17, 5, 2, 3, 1, 16, 8, 15, 18, 6, 7, 9, 10]
```

现在，`a.sort()`进行就地排序，当我们打印 a 时，我们将得到以下输出:

```py
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```

`a.reverse()`也是一个产生以下输出的就地操作:

```py
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```



## 还有更多……

dequee代表双端队列。与只能单向追加和弹出的栈和队列不同，追加和弹出操作可以在两端用 deque 完成:

[https://docs . python . org/2/library/collections . html # collections . deque](https://docs.python.org/2/library/collections.html#collections.deque)



# 从另一个列表创建一个列表-列表理解

理解是一种从另一个序列创建一个序列的方法。例如，我们可以从另一个列表或元组创建一个列表。我们来看一个列表理解。典型地，列表理解包括以下特征:

*   一个序列，比如一个我们感兴趣的元素列表
*   代表序列元素的变量
*   一种输出表达式，负责使用输入序列的元素生成输出序列
*   可选的谓词表达式



## 准备就绪

让我们定义一个简单的问题，以便理解理解中涉及的所有不同要素。对于一个包含正数和负数的输入列表，我们需要一个输出列表，它是所有负数元素的平方。



## 怎么做……

在下面的脚本中，我们将展示一个简单的列表理解示例:

```py
# 1.	Let us define a simple list with some positive and negative numbers.
a = [1,2,-1,-2,3,4,-3,-4]

# 2.	Now let us write our list comprehension.
# pow() a power function takes two input and
# its output is the first variable raised to the power of the second.
b = [pow(x,2) for x in a if x < 0]

# 3.	Finally let us see the output, i.e. the newly created list b.
print b
```



## 它是如何工作的……

这个例子是用来解释理解的各个组成部分的。让我们看看第 2 步:

```py
b = [pow(x,2) for x in a if x < 0]
```

该代码解释如下:

*   我们的输入列表是`a`，输出列表是`b`
*   我们将使用一个变量`x`来表示列表中的每个元素
*   `pow(x,2)`是输出表达式，它使用输入中的元素来产生输出列表
*   最后，`if` `x < 0`是谓词表达式，它控制输入列表的哪些元素用于产生输出列表



## 还有更多……

理解语法和字典完全一样。一个简单的例子将说明以下内容:

```py
a = {'a':1,'b':2,'c':3}
b = {x:pow(y,2) for x,y in a.items()}
print b
```

在前面的示例中，我们从输入字典 a 中创建了一个新字典 b。输出如下:

```py
{'a': 1, 'c': 9, 'b': 4}
```

你可以看到我们保留了`a`字典的关键字，但是现在新的值是 A 中原始值的平方。需要注意的一点是在理解过程中使用了卷曲的手镯而不是括号。

我们可以用一个小技巧来理解元组。请参见以下示例:

```py
def process(x):
    if isinstance(x,str):
        return x.lower()
    elif isinstance(x,int):
        return x*x
    else:
        return -9

a = (1,2,-1,-2,'D',3,4,-3,'A')
b = tuple(process(x) for x in a )

print b
```

我们使用了一个新的过程函数，而不是`pow()`函数。我将把它作为一个练习留给你来解释过程函数是做什么的。注意，对于理解列表，我们遵循相同的语法；然而，我们使用了大括号而不是方括号。该程序的输出如下:

```py
<generator object <genexpr> at 0x05E87D00>
```

哎呀！我们想要一个 tuple，但最终得到了一个生成器(在后面的章节中会有更多关于生成器的内容)。正确的做法如下:

```py
b = tuple(process(x) for x in a )
```

现在，print b 语句将产生以下输出:

```py
(1, 4, 1, 4, 'd', 9, 16, 9, 'a')
```

Python 的理解基于集合构建器符号:

[http://en.wikipedia.org/wiki/Set-builder_notation](http://en.wikipedia.org/wiki/Set-builder_notation)

Itertools.dropwhile:

[https://docs . python . org/2/library/ITER tools . html # ITER tools . drop while](https://docs.python.org/2/library/itertools.html#itertools.dropwhile)

有了谓词和序列，dropwhile 将只返回序列中满足谓词的那些项目。



# 使用迭代器

数据科学项目的关键输入是数据，这是显而易见的。数据的大小可能会有所不同，有些可能适合内存，有些则不适合。记录访问机制可以从一种数据格式变化到另一种数据格式。有趣的是，不同的算法可能需要处理不同长度的块。例如，假设您正在编写一个随机梯度下降算法，您希望在每个时期传递 5000 条记录的块，拥有一个能够处理数据访问、理解数据格式、遍历数据并向调用者提供所需数据的抽象将非常好。这将产生一个干净的代码。大多数时候，有趣的部分在于我们如何处理数据，而不是我们如何访问数据。Python 以迭代器的形式为我们提供了一种优雅的方式来处理所有这些需求。



## 准备就绪

Python 中的迭代器实现了迭代器模式。它允许我们一个接一个地检查一个序列，而不用具体化整个序列！



## 怎么做……

让我们创建一个名为简单计数器的简单迭代器，并为它提供一些关于如何有效使用迭代器的代码:

```py
# 1.	Let us write a simple iterator.
class SimpleCounter(object):
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        'Returns itself as an iterator object'
        return self

    def next(self):
        'Returns the next value till current is lower than end'
        if self.current > self.end:

            raise StopIteration
        else:
            self.current += 1
            return self.current - 1

# 2.	Now let us try to access the iterator
c = SimpleCounter(1,3)
print c.next()
print c.next()
print c.next()
print c.next()

# 3.	Another way to access
for entry in iter(c):
    print entry     
```



## 它是如何工作的……

在第一步中，我们用`SimpleCounter`的名字定义了一个类。`__init__`构造函数有两个参数，`start`和`end,`定义了序列的开始和结束。注意这两种方法，`__iter__`和`next`。Python 中任何作为迭代器对象的对象都应该支持这两个函数。`__iter__`将完整的类对象作为迭代器对象返回。`next`方法返回迭代器中的下一个值。

如步骤 2 所示，我们可以使用`next()`函数访问迭代器中的连续元素。Python 还为我们提供了一个方便的函数`iter()`，可以在一个循环中使用它来按顺序访问元素，如步骤 3 所示。`iter()`在内部使用`next()`功能。

需要注意的一点是迭代器对象只能使用一次。运行上述代码后，我们将尝试访问迭代器，如下所示:

```py
print next(c)
```

它将抛出stop iteration 异常。序列用尽后调用`c.next()`将导致 StopIteration 异常:

```py
    raise StopIteration
StopIteration
>>>
```

`iter()`函数处理这个异常，并在数据用尽时退出循环。



## 还有更多……

让我们看另一个迭代器的例子。假设我们需要在程序中访问一个非常大的文件；但是，在我们的程序中，我们将一次只处理一行:

```py
f = open(some_file_of_interest)
for l in iter(f):
print l
f.close()
```

在 Python 中，文件对象是迭代器；它支持`iter()`和`next()`功能。因此，我们可以一次处理一行，而不是将整个文件加载到内存中。

迭代器赋予您编写定制代码的能力，以便以应用程序要求的方式访问数据源。

以下链接提供了关于如何在 Python 中以各种方式使用迭代器的更多信息:

itertools 中的无限迭代器、`count()`、`cycle()`和`repeat()`:

[https://docs . python . org/2/library/ITER tools . html # ITER tools . cycle](https://docs.python.org/2/library/itertools.html#itertools.cycle)



# 生成迭代器和生成器

我们在前面的食谱中看到了什么是迭代器；现在在这个例子中，让我们看看如何生成一个迭代器。



## 准备就绪

生成器提供了一种简洁的语法来遍历一系列值，从而消除了使用 __iter__ 和 next()这两个函数的需要。我们不需要写一个类。需要注意的一点是，生成器和 iterables 都产生迭代器。



## 它是如何做到的…

让我们看一下下面的例子:如果你理解了上一节的内容，这应该很容易理解。在这种情况下，我们有一个发电机的理解。如果您还记得，我们尝试以这种方式进行元组理解，并获得了一个生成器对象:

```py
SimpleCounter  = (x**2 for x in range(1,10))

tot = 0
for val in SimpleCounter:
    tot+=val

print tot    
```



## 它是如何工作的……

应该清楚的是，前面的代码片段将找到给定范围的平方和；在这种情况下，范围是 1 到 9。(Python 中的 range 函数是右端的。)使用生成器，我们创建了一个名为`SimpleCounter`的迭代器，并在一个`for`循环中使用它，以便顺序访问底层数据。注意，我们在这里没有使用`iter()`函数。注意这段代码有多干净。我们以一种非常优雅的方式成功地重新创建了我们的旧`SimpleCounter`类。



## 还有更多……

让我们看看如何使用 yield 语句创建一个生成器:

```py
def my_gen(low,high):
    for x in range(low,high):
        yield x**2

tot = 0     

for val in my_gen(1,10):
    tot+=val
print tot    
```

在前面的例子中，`my_gen()`函数是一个生成器；我们使用 yield 语句按顺序返回输出。

在前面的部分，我们提到了生成器和 iterables 都产生迭代器。让我们通过使用`iter`函数调用生成器来验证这一点:

```py
gen = (x**2 for x in range(1,10))

for val in iter(gen):
    print val
```

在我们继续下一个配方中的迭代之前，需要注意生成器的一个关键点是，一旦我们完成了序列，我们就完成了——没有更多的数据。

### 注意

使用一个生成器对象，我们可以只检查一次序列。



# 使用可重复项

iterable 和 generator 类似，除了一个关键的区别，我们可以继续使用 iterable，也就是说，一旦我们用完了序列中的所有元素，我们可以像 generator 一样从头开始访问它。

它们是基于对象的生成器，不包含任何状态。任何带有产生数据的`iter`方法的类都可以用作无状态对象生成器。



## 准备就绪

让我们用一个简单的例子来理解 iterables。如果你已经理解了前面关于生成器和迭代器的方法，这个方法应该很容易理解。



## 怎么做……

让我们创建一个名为 simple iterable 的简单 iterable，并展示一些操纵它的脚本:

```py
# 1.	Let us define a simple class with __iter__ method.
class SimpleIterable(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        for x in range(self.start,self.end):
            yield x**2

#  Now let us invoke this class and iterate over its values two times.
c = SimpleIterable(1,10)

# First iteration
tot = 0
for val in iter(c):
    tot+=val

print tot

# Second iteration
tot =0
for val in iter(c):
    tot+=val

print tot
```



## 它是如何工作的..

在步骤 1 中，我们创建了一个简单的类，它是我们的 iterable。init 构造函数有两个参数，start 和 end，类似于我们前面的例子。我们定义了一个名为 iter 的函数，它将给出我们需要的序列。在给定的数字范围内，将返回这些数字的平方。

接下来，我们有两个循环。在第一个循环中，我们遍历了从 1 到 10 的数字范围。当我们运行第二个 for 循环时，您会注意到它再次遍历序列，并且没有引发任何异常。



## 参见

*   *使用迭代器*[第一章](part0015_split_000.html#E9OE1-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 1. Python for Data Science")*使用 Python 进行数据科学*
*   *生成迭代器-生成器*[第一章](part0015_split_000.html#E9OE1-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 1. Python for Data Science")，*使用 Python 进行数据科学*



# 将函数作为变量传递

除了命令式范例之外，Python 还支持函数式编程。在前面的小节中，我们已经看到了一些没有明确解释的函数式编程结构。让我们在这部分复习一下。函数是 Python 中的一等公民。它们有属性，可以被引用并赋给变量。



## 准备就绪

在这一节中，让我们看看在 Python 中将函数作为变量传递的范例。



## 怎么做……

让我们定义一个简单函数，看看它如何作为变量使用:

```py
# 1.Let us define a simple function.
def square_input(x):
    return x*x
# We will follow it by assigning that function to a variable
square_me = square_input

# And finally invoke the variable
print square_me(5)    
```



## 它是如何工作的……

我们在步骤 1 中定义了一个简单的函数；对于输入，该函数返回输入的平方。我们将这个函数分配给一个`square_me`变量。最后，我们能够通过使用有效参数调用`square_me`来调用该函数。这演示了如何在 Python 中将函数视为变量。这是一个非常重要的函数式编程结构。



# 在另一个函数中嵌入函数

这个配方将解释另一个函数式编程结构；在另一个函数中定义函数。



## 准备就绪

让我们举一个简单的例子，写一个函数，它将返回给定输入列表的平方和。



## 怎么做……

让我们编写一个简单的函数来演示另一个函数中的一个函数:

```py
# 1.	Let us define a function of function to find the sum of squares of the given input
def sum_square(x):
    def square_input(x):
        return x*x
    return sum([square_input(x1) for x1 in x])

# Print the output to check for correctness
print sum_square([2,4,5])    
```



## 它是如何工作的……

在步骤 1 中，您可以看到我们在`sum_square()`函数中定义了一个`square_input()`函数。父函数用它来执行平方和运算。在下一步中，我们调用该函数并打印其输出。

产生的输出如下:

```py
[4, 9, 16]
```



# 将函数作为参数传递

Python 支持高阶函数，即可以接受其他函数作为参数的函数。



## 准备就绪

让我们利用前面示例中定义的函数，编写一段代码来演示函数如何作为参数传递。



## 怎么做……

现在让我们演示如何将函数作为参数传递:

```py
from math import log

def square_input(x):
    return x*x

# 1.	Define a generic function, which will take another function as input
# and will apply it on the given input sequence.
def apply_func(func_x,input_x):
    return map(func_x,input_x)

# Let us try to use the apply_func() and verify the results  
a = [2,3,4]

print apply_func(square_input,a)
print apply_func(log,a)    
```



## 它是如何工作的……

在步骤 1 中，我们用两个变量定义了一个函数。第一个变量是函数，第二个变量是序列。正如您所看到的，我们使用了 map 函数(在后面的菜谱中会有更多关于这个函数的内容)来将给定的函数应用到序列的所有元素上。

接下来，我们调用列表 a 上的`apply_func`;首先是`square_input`函数，然后是`log`函数。输出如下所示:

```py
[4, 9, 16]
```

如你所见，a 的元素都是平方的。该映射将 square_input 函数应用于序列中的所有元素:

```py
[0.69314718055994529, 1.0986122886681098, 1.3862943611198906]
```

类似地，log 应用于序列中的所有元素。



# 返回一个函数

在这个部分，让我们看看将返回另一个函数的函数。



## 准备就绪

我们举一个高中的例子，试着解释一下函数返回函数的用法。

我们的问题是给定一个半径为 r 的圆柱体，我们想知道它在不同高度的体积:

[http://www.mathopenref.com/cylindervolume.html](http://www.mathopenref.com/cylindervolume.html)

```py
Volume = area * height = pi * r^2 * h
```

前面的公式给出了填满一个钢瓶的准确的立方单位。



## 怎么做……

让我们写一个简单的函数来演示函数返回函数的概念。此外，我们将编写一小段代码来展示用法:

```py
# 1.	Let us define a function which will explain our
#  concept of function returning a function.
def cylinder_vol(r):
    pi = 3.141
    def get_vol(h):
        return pi * r**2 * h
    return get_vol

# 2.	Let us define a radius and find get a volume function,
#  which can now find out the volume for the given radius and any height.
radius = 10
find_volume = cylinder_vol(radius)

# 3.	Let us try to find out the volume for different heights
height = 10
print "Volume of cylinder of radius %d and height %d = %.2f  cubic units" \
                %(radius,height,find_volume(height))        

height = 20
print "Volume of cylinder of radius %d and height %d = %.2f  cubic units" \
                %(radius,height,find_volume(height))        
```



## 它是如何工作的……

在步骤 1 中，我们定义了一个名为`cylinder_vol()`的函数；它只有一个参数，`r`，半径。在这个函数中，我们定义了另一个函数，`get_vol()`。`get_vol()`函数可以访问 r 和 pi，以高度作为参数。对于给定的半径 r，它是`cylinder_vol()`的参数，不同的高度作为参数传递给`get_vol()`。

在步骤 2 中，我们定义了一个半径；在这种情况下，作为 ten，并用它调用`cylinder_vol()`函数。它返回`get_vol()`函数，我们将它存储在一个名为`find_volume`的变量中。

在第 3 步中，我们调用了不同高度的`find_volume`，10 和 20。注意我们没有给出半径。

产生的输出如下:

```py
Volume of cylinder of radius 10 and height 10 = 3141.00  cubic units
Volume of cylinder of radius 10 and height 20 = 6282.00  cubic units
```



## 还有更多……

Functools 是高阶函数的模块:

[https://docs.python.org/2/library/functools.html](https://docs.python.org/2/library/functools.html)



# 用装饰者改变功能行为

装饰者包装一个函数并改变他们的行为。通过一些工作示例可以更好地理解它们。让我们看看这个食谱中动作中的一些装饰者。



## 准备就绪

还记得我们解释一个函数作为另一个函数的参数，函数作为变量，函数返回函数的那一节吗？最重要的是，你还记得圆柱体的例子吗？如果你跟着它，装饰应该是小菜一碟。在本练习中，我们将对给定的字符串执行管道清理活动。有了一个混合大小写和标点符号的字符串，我们将使用 decorators 来编写一个清理例程，它可以非常容易地扩展。



## 怎么做……

让我们为文本操作编写一个简单的装饰器:

```py
from string import punctuation

def pipeline_wrapper(func):

    def to_lower(x):
        return x.lower()

    def remove_punc(x):
        for p in punctuation:
            x = x.replace(p,'')
        return x

    def wrapper(*args,**kwargs):
        x = to_lower(*args,**kwargs)
        x = remove_punc(x)
        return func(x)
    return wrapper

@pipeline_wrapper        
def tokenize_whitespace(inText):
    return inText.split()

s = "string. With. Punctuation?"    
print tokenize_whitespace(s)
```



## 它是如何工作的……

让我们从最后两行开始:

```py
s = "string. With. Punctuation?" 
print tokenize_whitespace(s)
```

我们声明是一个字符串变量。我们想清理绳子。在我们的例子中，我们需要以下特性:

*   我们希望字符串是小写的
*   我们想去掉标点符号
*   我们想返回一个单词列表

您可以看到，我们调用了`tokenize_whitespace`函数，并将字符串 s 作为参数。我们来看一下`tokenize_whitespace`函数:

```py
@pipeline_wrapper 
def tokenize_whitespace(inText):
return inText.split()
```

我们看到这是一个非常简单的函数，对于一个字符串输入，该函数用一个空格将其拆分，并返回一个单词列表。我们将使用装饰器来改变这个函数的行为。你可以看到我们将为这个函数使用的装饰器是`@pipeline_wrapper`。这是调用以下内容的一种更简单的方法:

`tokenize_whitespace` = `pipeline_wrapper (clean_tokens)`

现在，让我们看看装饰器函数:

```py
def pipeline_wrapper(func):

def to_lower(x):
return x.lower()
def remove_punc(x):
for p in punctuation:
x = x.replace(p,'')
return x
def wrapper(*args,**kwargs):
x = to_lower(*args,**kwargs)
x = remove_punc(x)
return func(x)
return wrapper
```

可以看到`pipeline_wrapper`返回了 `wrapper` 函数。在 `wrapper` 函数中，你可以看到最终返回语句返回 `func`；这是我们传递给包装器的原始函数。`wrapper`修改了我们原来的`tokenize_whitespace`函数的行为。`tokenize_whitespace`的输入首先由`to_lower()`函数修改，将输入字符串改为小写，然后由`remove_punc()`函数删除标点符号。最终输出如下:

```py
['string', 'with', 'punctuation']
```

这正是我们想要的——去掉标点符号，将字符串转换成小写，最后得到一个单词列表。



# 用 lambda 创建匿名函数

匿名的函数是使用 Python 中的 lambda 语句创建的。未绑定到名称的函数称为匿名函数。



## 准备就绪

如果您遵循了关于将函数作为参数传递的小节，那么本节中的示例与此非常相似。我们在那个部分传递了一个预定义的函数；这里我们将传递一个 lambda 函数。



## 怎么做……

我们将看到一个简单的例子，用一个玩具数据集来解释 Python 中的匿名函数:

```py
# 1.	Create a simple list and a function similar to the
# one in functions as parameter section.
a =[10,20,30]

def do_list(a_list,func):
    total = 0
    for element in a_list:
        total+=func(element)
    return total

print do_list(a,lambda x:x**2)   
print do_list(a,lambda x:x**3)   

b =[lambda x: x%3 ==0  for x in a  ]
```



## 它是如何工作的……

在步骤 1 中，我们有一个名为`do_list`的函数，它接受另一个函数作为参数。使用列表和函数，`do_list`对给定列表的元素应用输入函数，对转换后的值求和，并返回结果。

接下来，我们将调用 do-list 函数，第一个参数是我们的输入列表 a，第二个参数是我们的 lambda 函数。让我们解码我们的 lambda 函数:

```py
lambda x:x**2
```

使用关键字 lambda 声明匿名函数；接下来为函数定义一个参数。在这种情况下，x 是传递给这个匿名函数的参数名。冒号运算符后面的表达式是返回值。使用表达式计算输入参数，并将其作为输出返回。在此输入中，输入的平方作为输出返回。在下一个 print 语句中，我们有一个 lambda 函数，它返回给定输入的立方。



# 使用地图功能

Map 是一个内置的 Python 函数。它需要一个函数和一个 iterable 作为参数:

```py
map(aFunction, iterable)
```

该函数应用于 iterable 的所有元素，结果以列表形式返回。当函数被传递给 map 时，lambda 通常与 map 一起使用。



## 准备就绪

让我们看一个使用 map 函数的非常简单的例子。



## 怎么做……

让我们看一个如何使用地图功能的例子:

```py
#First let us declare a list.
a =[10,20,30]
# Let us now call the map function in our Print statement.
print map(lambda x:x**2,a)   
```



## 它是如何工作的……

这与前一个配方中的代码非常相似。映射函数有两个参数。第一个是函数，第二个是序列。在我们的示例代码中，我们使用了匿名函数:

```py
lambda x:x**2
```

该函数对给定输入求平方。我们还向 map 传递了一个列表。

Map 应用一个函数，对给定列表中的所有元素求平方，并将结果作为列表返回。

输出如下所示:

```py
[100,400,900]
```



## 还有更多……

类似地，任何其他函数都可以应用于列表:

```py
print map(lambda x:x**3,a)
```

使用 map，我们可以用一行代码替换前面配方中的代码片段:

```py
print sum(map(lambda x:x**2,a))
print sum(map(lambda x:x**3,a))
```

如果我们有 N 个序列，Map 需要一个 N 参数函数。让我们看一个例子来理解这一点:

```py
a =[10,20,30]
b = [1,2,3]

print map(pow,a,b) 
```

我们将两个序列 a 和 b 传递给我们的 map 函数。注意，传递的函数是幂函数。这需要两个参数。让我们看看前面代码片段的结果:

```py
[10, 400, 27000]
>>>
```

如你所见，list `a`的元素在 list b 中的相同位置被提升到 value 的幂。需要注意的一点是，两个列表的大小应该相同；如果没有，Python 将用 None 填充较小的列表。尽管我们的例子是在一个列表上操作的，但是任何 iterable 都可以传递给一个 map 函数。



# 使用过滤器

顾名思义，filter 根据给定的函数从序列中过滤元素。有了负数和正数的序列，我们可以使用一个过滤函数来过滤掉所有的负数。过滤器是一个内置的 Python 函数。它需要一个函数和一个 iterable 作为参数:

```py
Filter(aFunction, iterable)
```

作为参数传递的函数基于测试作为布尔值返回。

该函数应用于 iterable 的所有元素，当对其应用该函数时，所有返回 true 的项都作为列表返回。匿名函数 lambda 通常与 filter 一起使用。



## 准备就绪

让我们来看一个简单的代码，看看过滤函数是如何工作的。



## 怎么做……

让我们看一个如何使用过滤函数的例子:

```py
# Let us declare a list.
a = [10,20,30,40,50]
# Let us apply Filter function on all the elements of the list.
print filter(lambda x:x>10,a)
```



## 它是如何工作的……

我们这里使用的 lambda 函数非常简单；如果给定值大于 10，则返回 true，否则返回 false。我们的打印语句给出了以下结果:

```py
[20, 30, 40, 50]

```

如您所见，只返回大于 10 的元素。



# 使用 zip 和 izip

Zip 获取两个长度相等的集合，并将它们成对合并在一起。Zip 是一个内置的 Python 函数。



## 准备就绪

让我们用一个非常简单的例子来演示 zip。



## 怎么做……

让我们将两个序列传递给一个 zip 函数并打印输出:

```py
print zip(range(1,5),range(1,5))
```



## 它是如何工作的……

我们的 zip 函数的两个参数是两个列表，它们的值范围都是从`1`到`5`。

范围函数有三个参数。列表的起始值、列表的结束值和步长值。默认步长值为 1。在我们的例子中，我们传递 1 和 5 作为列表的开始和结束值。记住 Python 是右闭的，所以 range ( `1`，`5`)将返回如下列表:

```py
[1,2,3,4]
```

我们将这两个序列传递给 zip 函数，结果如下:

```py
[(1, 1), (2, 2), (3, 3), (4, 4)]
```

请记住，两个集合的大小应该相同；否则，输出将被截断为最短集合的大小。



## 还有更多……

现在，看看下面的代码:

```py
x,y = zip(*out)
print x,y
```

你能猜出输出是什么吗？

让我们看看*操作符是做什么的。一个`*`操作符在它们的位置参数中解包一个集合:

```py
a =(2,3)
print pow(*a)
```

幂运算需要两个参数。现在 a 是一个元组；如您所见，*操作符将元组分成两个独立的参数。*运算符解包 2 和 3 中的元组。它们作为参数传递，`pow(2,3)`，我们得到输出，8。

`**`操作符可以用来解包一个字典。请看下面的片段:

```py
a_dict = {"x":10,"y":10,"z":10,"x1":10,"y1":10,"z1":10} 
```

操作符将字典解包为一组命名参数。在这种情况下，当我们将`**`操作符应用于字典时，我们将得到输出 6。看看下面的函数，它有六个参数:

```py
def dist(x,y,z,x1,y1,z1):
return abs((x-x1)+(y-y1)+(z-z1))

print dist(**a_dict) 
```

print 语句的输出为零。

有了这两个操作符，我们就可以编写一个函数，而对它可以接收的变量数量没有任何限制:

```py
def any_sum(*args):
tot = 0
for arg in args:
tot+=arg
return tot

print any_sum(1,2)
print any_sum(1,2,3)
```

如您所见，在前面的代码片段中，`any_sum`函数现在可以处理任意数量的变量。好奇的读者可能会评论为什么不使用列表作为`any_sum`函数的参数，在这里我们可以传递一个值列表。很好，在这种情况下是的，但是我们很快会遇到这样的情况，我们真的不知道会通过什么样的论点。

回到 zip 实用程序。zip 的一个缺点是它可以一次计算所有的列表。当我们有两个非常大的列表时，这可能是一个问题。在这种情况下,`izip`会出手相救。他们仅在被请求时计算元素。`izip`是`itertools`的一部分。更多细节请参考 itertools 配方。



## 参见

*   *使用 Itertools* 配方[第 1 章](part0015_split_000.html#E9OE1-6b04b7c0b98f44a0b8f82924fef317ec "Chapter 1. Python for Data Science") , *使用 Python 进行数据科学*



# 从表格数据中处理数组

任何数据科学应用的核心都是为给定的问题找到合适的数据处理例程。在机器学习的情况下，它是监督或无监督的方法来预测或分类数据。甚至在这一步之前，在数据转换和使数据适合这些方法方面已经花费了大量的时间。

通常，数据科学程序可以通过多种方式获得数据。数据科学程序员面临的挑战是使用 Python 数据结构访问数据，并使其可用于代码的后续部分。当编写数据科学程序时，掌握通过 Python 访问数据的方法将非常方便，因为它将允许您非常快速地跳到问题的实质。

通常情况下，数据是一个文本文件，由逗号或制表符分隔。在这种情况下，可以使用 Python 内置的文件对象实用程序。正如我们前面看到的，文件对象实现了`__iter__()`和`next()`方法。这允许我们通过一次只读取一小部分文件来处理不适合内存的非常大的文件。

scikit-learn 等 Python 机器学习库在 NumPy 库上工作。在这一节中，我们将看到有效读取外部数据并将其转换为 numPy 数组以便进行下游数据处理的方法。



## 准备就绪

NumPy 为我们提供了一个名为`genfromtext`的函数，用于从表格数据创建 NumPy 数组。一旦数据以 NumPy 数组的形式出现，下游系统处理这些数据就容易多了。让我们看看如何利用`genfromtext`。以下代码是使用 NumPy 版本 1.8.0 编写的。



## 怎么做……

让我们从导入必要的库开始。我们将继续定义一个样本输入。最后，我们将演示如何处理表格数据。

```py
# 1.	Let us simulate a small tablular input using StringIO
import numpy as np
from StringIO import StringIO
in_data = StringIO("10,20,30\n56,89,90\n33,46,89")

# 2.Read the input using numpyâ€™s genfromtext to create a nummpy array.
data = np.genfromtxt(in_data,dtype=int,delimiter=",")

# cases where we may not need to use some columns.
in_data = StringIO("10,20,30\n56,89,90\n33,46,89")
data = np.genfromtxt(in_data,dtype=int,delimiter=",",usecols=(0,1))

# providing column names
in_data = StringIO("10,20,30\n56,89,90\n33,46,89")
data = np.genfromtxt(in_data,dtype=int,delimiter=",",names="a,b,c")

# using column names from data
in_data = StringIO("a,b,c\n10,20,30\n56,89,90\n33,46,89")
data = np.genfromtxt(in_data,dtype=int,delimiter=",",names=True)
```



## 它是如何工作的……

在步骤 1 中，我们使用`StringIO`实用程序模拟了一个列表数据。我们有三行三列。行是新的行分隔符，列是逗号分隔的。

在第 2 步中，我们使用 NumPy 中的`genfromtxt`将数据作为 NumPy 数组接收。

genfromtxt 的第一个参数是文件的来源和文件名；在我们的例子中，它是 StringIO 对象。输入以逗号分隔；delimiter 参数允许我们指定相同的内容。运行上述代码后，数据值如下:

```py
>>> data
array([[10, 20, 30],
       [56, 89, 90],
       [33, 46, 89]])
```

如您所见，我们成功地从 NumPy 数组中的字符串加载了数据。



## 还有更多……

此处显示了`genfromtxt`功能的各种参数和默认值:

```py
genfromtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True)
```

唯一必需的参数是数据源的名称。在我们的例子中，我们使用了 StringIO 对象。它可以是对应于文件名的字符串，也可以是具有读取方法的类似于文件的对象。它也可以是远程文件的 URL。

第一步是将给定的行拆分成列。一旦文件被打开读取，genfromtxt 将非空行分割成一系列字符串。空行被忽略，注释行也是如此。注释选项帮助 gentext 决定哪些是注释行。字符串根据由 delimiter 选项指定的分隔符拆分成列。在我们的示例中，我们使用了一个`,`分隔符。一个`/t`也是一个非常流行的分隔符。默认情况下，gentext 中的分隔符是`None`,这意味着它假设该行通过空格分割成列。

通常，当将行更改为字符串序列并随后提取列时，不会删除各个列的前导或尾随空白。在代码的后面部分，需要处理这个问题，特别是当一些变量被用作字典中的键时。例如，如果前导或尾随空白没有得到一致的处理，这可能会导致代码中的错误/错误。设置`autostrip=True`有助于避免这个问题。

很多时候，我们想要跳过，比如说，在读一个文件的时候，上面的 n 行或者下面的 n 行。这可能是由于页眉或页脚的存在。读取时，`skip_header = n`将跳过前 n 行，同样，`skip_footer = n`将跳过后 n 行。

与不需要的行类似，我们可能会遇到许多不需要使用某些列的情况。`usecols`参数用于指定我们感兴趣的列的列表:

```py
in_data = StringIO("10,20,30\n56,89,90\n33,46,89")

data = np.genfromtxt(in_data,dtype=int,delimiter=",",usecols=(0,1))
```

正如您在前面的示例中看到的，我们只选择了两列，列 0 和列 1。数据对象如下所示:

```py
>>> data
array([[10, 20],
       [56, 89],
       [33, 46]])
```

可以使用`names`参数提供定制的列名。具有逗号分隔的列名的字符串参数如下所示:

```py
in_data = StringIO("10,20,30\n56,89,90\n33,46,89")
data = np.genfromtxt(in_data,dtype=int,delimiter=",",names="a,b,c")

>>> data
array([(10, 20, 30), (56, 89, 90), (33, 46, 89)], 
      dtype=[('a', '<i4'), ('b', '<i4'), ('c', '<i4')])
```

通过将`names`设为 true，输入数据中的第一行被用作列标题:

```py
in_data = StringIO("a,b,c\n10,20,30\n56,89,90\n33,46,89")
data = np.genfromtxt(in_data,dtype=int,delimiter=",",names=True)

>>> data
array([(10, 20, 30), (56, 89, 90), (33, 46, 89)], 
      dtype=[('a', '<i4'), ('b', '<i4'), ('c', '<i4')])
```

NumPy 的另一个简单的从文本输入创建 NumPy 数组的方法是`loadtxt`:

[http://docs . scipy . org/doc/numpy/reference/generated/numpy . load txt . html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)

这没有 genfromtxt 复杂；如果您需要一个没有任何复杂的数据处理机制(比如处理缺失值)的简单阅读器，您可以选择 loadtxt。

但是，如果我们对以 NumPy 数组的形式加载数据不感兴趣，而是想以列表的形式加载，Python 为我们提供了一个默认的 csv 库:

[https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html)

前面 csv 库中一个有趣的方法是`csv.Sniffer.sniff()`。如果我们有一个非常大的 csv 文件，并且我们想了解它的结构，我们可以使用`sniff()`。这将返回一个方言子类，它具有 csv 文件的大部分属性。



# 预处理列

通常我们得到的数据并不是我们可以消费的格式。必须应用机器学习术语中称为数据预处理步骤的大量数据处理。克服这一障碍的一种方法是将所有输入作为字符串接收，并在后面的阶段继续进行所需的数据转换。另一种方法是在源代码中执行这些更改。`genfromtext`为我们提供了一些功能，以便在从源读取时执行数据转换。



## 准备就绪

考虑以下文本行:

```py
30kg,inr2000,31.11,56.33,1
52kg,inr8000.35,12,16.7,2
```

这是我们在现实生活中获取数据的一个典型例子。前两列有一个字符串 kg 和 inr，连接到实际值的前面和后面。

让我们尝试在 NumPy 数组中接收这些数据，如下所示:

```py
in_data = StringIO("30kg,inr2000,31.11,56.33,1\n52kg,inr8000.35,12,16.7,2")
data = np.genfromtxt(in_data,delimiter=",")
```

这将导致以下结果:

```py
>>> data
array([[   nan,    nan,  31.11,  56.33,   1\.  ],
       [   nan,    nan,  12\.  ,  16.7 ,   2\.  ]])
```

如您所见，前两列未被读取。



## 怎么做……

让我们从导入必要的库开始。我们将继续定义一个样本输入。最后，我们将演示数据预处理。

```py
import numpy as np
from StringIO import StringIO

# Define a data set
in_data = StringIO("30kg,inr2000,31.11,56.33,1\n52kg,inr8000.35,12,16.7,2")

# 1.Let us define two data pre-processing using lambda functions,
strip_func_1 = lambda x : float(x.rstrip("kg"))
strip_func_2 = lambda x : float(x.lstrip("inr"))

# 2.Let us now create a dictionary of these functions,
convert_funcs = {0:strip_func_1,1:strip_func_2}

# 3.Now provide this dictionary of functions to genfromtxt.
data = np.genfromtxt(in_data,delimiter=",", converters=convert_funcs)

# Using a lambda function to handle conversions
in_data = StringIO("10,20,30\n56,,90\n33,46,89")
mss_func = lambda x : float(x.strip() or -999)
data = np.genfromtxt(in_data,delimiter=",", converters={1:mss_func})
```



## 它是如何工作的……

在步骤 1 中，我们定义了两个 lambda 函数，一个用于第 1 列，我们需要从第 2 列的右侧去除字符串“kg ”,另一个用于从第 2 列的左侧去除字符串“inr”。

在第 2 步中，我们将继续定义一个字典，其中键是要应用函数的列名，值是函数。这个字典作为参数传递，在`genfromtext`中带有`converters`名称。

现在输出如下:

```py
>>> data
array([[  3.00000000e+01,   2.00000000e+03,   3.11100000e+01,
          5.63300000e+01,   1.00000000e+00],
       [  5.20000000e+01,   8.00035000e+03,   1.20000000e+01,
          1.67000000e+01,   2.00000000e+00]])
```

请注意，Nan 已经消失，取而代之的是来自输入的实际值。



## 还有更多……

转换器也可用于通过 lambda 函数处理输入记录中的缺失值:

```py
in_data = StringIO("10,20,30\n56,,90\n33,46,89")
mss_func = lambda x : float(x.strip() or -999)
data = np.genfromtxt(in_data,delimiter=",", converters={1:mss_func})
```

lambda 函数为缺失值返回-999。在我们的输入中，第二行的第二列是空的，应该替换为-999。最终输出如下所示:

```py
>>> data
array([[  10.,   20.,   30.],
       [  56., -999.,   90.],
       [  33.,   46.,   89.]])
```

更多详情请参考此处给出的 SciPy 文档:

[http://docs . scipy . org/doc/numpy/reference/generated/numpy . load txt . html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)

[http://docs . scipy . org/doc/numpy/reference/generated/numpy . genfromtxt . html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html)



# 排序列表

我们将从排序一个列表开始，然后继续排序其他的可重复项。



## 准备就绪

有两种方法可以进行排序。第一种方法是使用列表中内置的排序函数，另一种方法是使用排序函数。让我们通过一个例子来解决它。



## 怎么做……

让我们看看如何利用排序和已排序函数:

```py
# Let us look at a very small code snippet, which does sorting of a given list.
a = [8, 0, 3, 4, 5, 2, 9, 6, 7, 1]
b = [8, 0, 3, 4, 5, 2, 9, 6, 7, 1]

print a
a.sort()
print a

print b
b_s = sorted(b)
print b_s
```



## 它是如何工作的……

我们用相同的元素声明了两个列表，a 和 b。为了方便验证输出，我们将打印列表`a`:

```py
[8, 0, 3, 4, 5, 2, 9, 6, 7, 1]
```

我们使用列表数据类型`a.sort()`可用的排序函数来执行就地排序。以下 print 语句显示列表现在已经排序:

```py
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

现在，我们将使用排序函数。这个函数对列表进行排序，并返回一个新的排序列表。您可以看到，我们将其作为`sorted(b)`调用，并将输出存储在`b_s`中。针对`b_s`的打印语句产生一个排序后的输出:

```py
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```



## 还有更多……

`sort`函数仅适用于列表数据类型。默认情况下，排序是按升序进行的；这可以通过排序函数的反向参数来控制。默认情况下，反向设置为`False`:

```py
>>> a = [8, 0, 3, 4, 5, 2, 9, 6, 7, 1]
>>> print a
[8, 0, 3, 4, 5, 2, 9, 6, 7, 1]
>>> a.sort(reverse=True)
>>> print a
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
>>>
Now, we have a descending order sorting.
For other iterables, we have to fall back on the sorted function. Let's look at a tuple example:
>>> a = (8, 0, 3, 4, 5, 2, 9, 6, 7, 1)
>>> sorted(a)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
```



# 用键排序

到目前为止，我们已经看到了列表或序列按元素排序的所有例子。现在让我们来看看是否可以用键来排序。在前面的例子中，元素是键。在现实世界中，有更复杂的记录，其中一个记录包含多个列，我们希望使用一个或多个列进行排序。我们将通过一个元组列表来实现我们的示例，这同样适用于其他序列对象。



## 准备就绪

在我们的例子中，一个元组表示一个人的记录，包括他的姓名、ID 和年龄。让我们写一个排序，以便对各个字段进行排序。



## 怎么做……

让我们使用列表和元组定义一个类似记录的结构。我们将使用这些数据来演示带有一个键的数据排序:

```py
#1.The first step is to create a list of tuples, which we will use to test our sorting.

employee_records = [ ('joe',1,53),('beck',2,26), \
                     ('ele',6,32),('neo',3,45),  \
                    ('christ',5,33),('trinity',4,29), \
                    ]

# 2.Let us now sort it by employee name
print sorted(employee_records,key=lambda emp : emp[0])
"""
It prints as follows
[('beck', 2, 26), ('christ', 5, 33), ('ele', 6, 32), ('joe', 1, 53), ('neo', 3, 45), ('trinity', 4, 29)]
"""
# 3.Let us now sort it by employee id
print sorted(employee_records,key=lambda emp : emp[1])
"""
It prints as follows
[('joe', 1, 53), ('beck', 2, 26), ('neo', 3, 45), ('trinity', 4, 29), ('christ', 5, 33), ('ele', 6, 32)]
"""
# 4.Finally we sort it with employee age
print sorted(employee_records,key=lambda emp : emp[2])
"""
Its prints as follows
[('beck', 2, 26), ('trinity', 4, 29), ('ele', 6, 32), ('christ', 5, 33), ('neo', 3, 45), ('joe', 1, 53)]
"""
```



## 它是如何工作的……

在我们的例子中，每个记录有三个字段:姓名、身份和年龄。我们使用 lambda 函数来传递一个键，我们需要根据这个键对给定的记录进行排序。在步骤 2 中，我们将名称作为键进行排序。类似地，在步骤 2 和 3 中，我们将 ID 和年龄作为键传递。我们可以看到不同步骤的输出；输出按我们希望的特定键排序。



## 还有更多……

由于按键排序的重要性，Python 提供了一个方便的函数来访问键，而不是编写 lambdas。操作员模块具有`itemgetter`、`attrgetter`和`methodcaller`功能。我们看到的排序示例可以使用`itemgetter`编写如下:

```py
from operator import itemgetter
employee_records = [ ('joe',1,53),('beck',2,26), \
                     ('ele',6,32),('neo',3,45),  \
                     ('christ',5,33),('trinity',4,29), \
                     ]
print sorted(employee_records,key=itemgetter(0))
"""
[('beck', 2, 26), ('christ', 5, 33), ('ele', 6, 32), ('joe', 1, 53), ('neo', 3, 45), ('trinity', 4, 29)]
"""
print sorted(employee_records,key=itemgetter(1))
"""
[('joe', 1, 53), ('beck', 2, 26), ('neo', 3, 45), ('trinity', 4, 29), ('christ', 5, 33), ('ele', 6, 32)]
"""
print sorted(employee_records,key=itemgetter(2))
"""
[('beck', 2, 26), ('trinity', 4, 29), ('ele', 6, 32), ('christ', 5, 33), ('neo', 3, 45), ('joe', 1, 53)]
"""
```

注意，我们没有使用 lambda 函数，而是使用`itemgetter`来指定我们需要排序的键。当需要多级排序时，可以给`itemgetter`多个字段作为输入；例如，假设我们需要先按姓名排序，然后按年龄排序，我们的代码如下:

```py
>>> sorted(employee_records,key=itemgetter(0,1))
[('beck', 2, 26), ('christ', 5, 33), ('ele', 6, 32), ('joe', 1, 53), ('neo', 3, 45), ('trinity', 4, 29)]
```

当我们的 iterable 的元素是类对象时，`attrgetter`和`methodcaller`就派上了用场。请看下面的例子:

```py
# Let us now enclose the employee records as class objects,
class employee(object):
    def __init__(self,name,id,age):
        self.name = name
        self.id = id
        self.age = age
    def pretty_print(self):
       print self.name,self.id,self.age

# Now let us populate a list with these class objects.
employee_records = []
emp1 = employee('joe',1,53)
emp2 = employee('beck',2,26)
emp3 = employee('ele',6,32)

employee_records.append(emp1)
employee_records.append(emp2)
employee_records.append(emp3)

# Print the records
for emp in employee_records:
    emp.pretty_print()

from operator import attrgetter
employee_records_sorted = sorted(employee_records,key=attrgetter('age'))
# Now let us print the sorted list,
for emp in employee_records_sorted:
    emp.pretty_print()
```

构造函数用三个变量初始化这个类:姓名、年龄和 ID。我们还有`pretty_print`方法来打印类对象`.`的值

接下来，让我们用这些类对象填充一个列表:

```py
employee_records = []
emp1 = employee('joe',1,53)
emp2 = employee('beck',2,26)
emp3 = employee('ele',6,32)

employee_records.append(emp1)
employee_records.append(emp2)
employee_records.append(emp3)
```

现在，我们有了一个雇员对象的列表。每个对象中有三个变量:姓名、ID 和年龄。让我们打印列表以查看订单:

```py
joe 1 53
beck 2 26
ele 6 32
```

如您所见，插入的顺序被保留了下来。现在，让我们使用`attrgetter`对带有年龄字段的列表进行排序:

```py
employee_records_sorted = sorted(employee_records,key=attrgetter('age'))
```

让我们打印排序后的列表。

输出如下所示:

```py
beck 2 26
ele 6 32
joe 1 53
```

你可以看到记录现在是按年龄排序的。

当我们想要使用类中的方法来决定排序时，可以使用`methodcaller`进行排序。出于演示目的，让我们添加一个随机方法，该方法将年龄除以 ID:

```py
class employee(object):
    def __init__(self,name,id,age):
        self.name = name
        self.id = id
        self.age = age

    def pretty_print(self):
       print self.name,self.id,self.age

    def random_method(self):
       return self.age / self.id 

# Populate data
employee_records = []
emp1 = employee('joe',1,53)
emp2 = employee('beck',2,26)
emp3 = employee('ele',6,32)

employee_records.append(emp1)
employee_records.append(emp2)
employee_records.append(emp3)

from operator import methodcaller
employee_records_sorted = sorted(employee_records,key=methodcaller('random_method'))
for emp in employee_records_sorted:
    emp.pretty_print() 
```

我们现在可以通过调用这个方法对列表进行排序:

```py
sorted(employee_records,key=methodcaller('random_method'))
```

现在让我们按排序顺序打印列表，并查看输出:

```py
ele 6 32
beck 2 26
joe 1 53
```



# 使用 itertools

Itertools 包括函数来处理 iterables 它受到函数式编程语言(如 Haskell)的启发。它们保证内存高效且速度非常快。



## 准备就绪

Itertools 中有很多可用的函数；我们将通过例子来解决其中的一些问题。提供了一个完整的函数列表链接。



## 怎么做……

让我们来看一组用于演示 itertools 用法的 Python 脚本:

```py
# Load libraries
from itertools import chain,compress,combinations,count,izip,islice

# 1.Chain example, where different iterables can be combined together.
a = [1,2,3]
b = ['a','b','c']
print list(chain(a,b)) # prints [1, 2, 3, 'a', 'b', 'c']

# 2.Compress example, a data selector, where the data in the first iterator
#  is selected based on the second iterator.
a = [1,2,3]
b = [1,0,1]
print list(compress(a,b)) # prints [1, 3]

# 3.From a given list, return n length sub sequences.
a = [1,2,3,4]
print list(combinations(a,2)) # prints [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]

# 4.A counter which produces infinite consequent integers, given a start integer,
a = range(5)
b = izip(count(1),a)
for element in b:
    print element

# 5.	Extract an iterator from another iterator, 
# let us say we want an iterator which only returns every 
# alternate elements from the input iterator
a = range(100)
b = islice(a,0,100,2)
print list(b)
```



## 它是如何工作的……

第一步非常简单，使用`chain()`将两个可重复项组合起来。需要注意的一点是，`chain()`直到被实际调用时才被实现。检查以下命令行:

```py
>>> chain(a,b)
<itertools.chain object at 0x060DD0D0>
```

调用 chain(a，b)返回链对象。但是，当我们运行以下命令时，会产生实际输出:

```py
>>> list(chain(a,b))
[1, 2, 3, 'a', 'b', 'c']
```

步骤 2 描述了`compress`。在此示例中，a 的元素是基于 b 中的元素选择的。您可以看到，在 b 中，第二个值是零，因此，a 中的第二个值也没有被选择。

步骤 3 做简单的数学组合。我们有一个输入列表 a，并希望 a 的元素是两个元素的组合。

步骤 4 解释了一个计数器对象，它可以作为一个序列号的无限资源，给定一个起始号。运行代码，我们将得到以下输出:

```py
(1, 0)
(2, 1)
(3, 2)
(4, 3)
(5, 4)
```

您可以看到我们在这里使用了 izip。(Zip 和 izip 已经在前面的章节中介绍过了。)我们的输出是一个元组，其中第一个元素由计数器提供，第二个元素由输入列表 a 提供。

步骤 5 详述了 islice 操作；islice 与 slice 相同，我们在上一节中讨论过，只是 islice 是内存高效的，除非被调用，否则不会实现完整的输出。

关于 itertools 的完整列表，请参考[https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)。