        

# 十三、使用Poetry和 PyTest 打包和测试

到目前为止，我们所有的代码都保存在笔记本或 Python 文件中。虽然这完全没问题，但随着我们代码的数量和复杂性的增长，为我们最常用的代码创建一个或多个查找源，以及为我们不想冒险添加错误的复杂代码创建源，越来越成为一个好主意。

在这一章中，我们将学习如何使用`poetry`包来构建我们自己的包，以便在多个项目中使用或者与他人共享。一个包可以作为一个可交付的东西——你可以把它传递给你的客户或者与他分享！构建和测试包是一项至关重要的技能，它可以提高您的生产率，并通过使您能够一次又一次地重用相同的经过适当测试的代码体来节省时间和减少压力。

构建包也可能提高你的整体编码技能，因为包要求代码是抽象的和灵活的，并允许你花时间在有效的实现上。

本章将涵盖以下主题:

*   拥有定制软件包的好处
*   开发包的几种方法
*   用Poetry定义依赖和资源
*   可编辑包安装的工作流
*   用 PyTest 测试您的代码
*   sphinx 文档
*   用 CI 测试

        

# 技术要求

对于本章，我们将需要以下包(一如既往，它们包含在我们的基本环境中):

*   `poetry`
*   `pytest`
*   `sphinx`

由于我们正在创建一个独立的包，所有代码都存储在 GitHub 上的[https://GitHub . com/packt publishing/Learn-Python-by-Building-Data-Science-Applications](https://github.com/PacktPublishing/Learn-Python-by-Building-Data-Science-Applications)。

        

# 构建包

到目前为止，在本书中，我们要么使用第三方包，如`requests`和`pandas`，要么编写原始代码作为`.py`脚本或笔记本。虽然直接使用 Python 文件对于某些项目来说绝对没问题，但这使得代码难以重用和构建；对于可以反复使用的复杂算法和工具来说，这是不可持续的。这样的代码也很难共享，因为它没有整体结构，往往会随着时间的推移而衰减，并且没有一个健壮的依赖系统；该代码可能无法在安装了其他软件包(或软件包的其他版本)的其他系统上运行。最后但同样重要的是，这种实践会影响我们代码的质量，因为我们倾向于将代码作为一次性的解决方案来编写和使用。减轻所有这些问题的最好方法是将您的代码打包。

但是什么是包呢？在 Python 中，包被定义为在系统中注册的特定代码体(通过系统路径),因此可以在任何特定的代码库中导入和使用。软件包存储在专用的系统路径上，不能手动更改或部署。相反，最好使用专用工具，比如内置的`setuptool`包或包管理器(例如，`pip`或`conda`)。我们将在接下来的章节中详细了解这些。

        

# 自带包裹

到目前为止，我们看到的大多数包都非常通用——例如，`requests`在客户端使用 HTTP，而`pandas`则专注于数据分析。为什么你要写你自己的包，在头脑中有一个非常具体的任务，这个任务不一定有用或者适用于另一个人的用例？简而言之，因为你将是第一个受益者！

包解决的主要目标是创建一个可交付的产品；新机器上的任何新用户都可以立即安装该软件包，以及它正常工作所需的所有软件包。作为副产品，包与您每天编写的代码保持隔离。这种隔离是一件好事——作为一个包设计者，它让你构建你的...

        

# 使用软件包管理器–pip 和 conda

到目前为止，我们介绍的所有包都可以通过两个包管理器之一公开访问，这两个包管理器是`pip`和`conda`。软件包管理器的作用是提供一个统一的界面，以便在系统中安全地安装、升级和卸载软件包。由于大多数软件包依赖于其他软件包(通常是特定的版本)，解决这些依赖关系也是软件包管理器的工作——也就是说，为所有依赖它们的已安装软件包安装符合版本标准的软件包。

`pip`和`conda`是目前为止 Python 最流行的两个包管理器。第一个是由 Python 软件基金会官方支持的。它是主要的 Python 包管理，句号。

那么，我们为什么要使用`conda`呢？历史上，`pip`和 PyPI(一个相应的在线服务)不支持二进制文件作为包的一部分。必须为每个操作系统单独编译二进制文件，而且它们(显然)是用 Python 本身以外的语言编写的。因此，提供对二进制文件的支持被认为要求过高。

然而，事实证明，这正是快速数字运算所需要的——正如我们之前提到的，`numpy`、`pandas`和`sklearn`都运行 C 甚至 Fortran。很长一段时间，缺乏支持意味着每个人每次安装新的包时都必须在本地编译二进制文件。因此，Python 领导层提出构建一个支持二进制文件的包管理器——于是`conda`诞生了。另外，`conda`还可以创建单独的虚拟环境，因此您可以从一个共享的`.yaml`文件中安全地复制一个完整的 Python 环境，或者同时拥有多个版本的 Python 和包。

不幸的是，与`pip`相比，`conda`需要更多的努力。对我们来说最关键的是，它不支持从 Git 库(甚至是私有库)安装包，而`pip`支持。`pip`的另一个特性是它允许在可编辑模式下安装软件包——也就是说，代码存储在非系统路径上，随时可以编辑。在这一章中，我们将构建一个针对`pip`的包。

        

# 创建包脚手架

那么，我们如何开始？首先，我们需要创建一个脚手架——一个默认的包结构，包含所有必需的文件夹、带有元数据和配置的文件等等。我们的代码将存储在 GitHub 上，所以让我们从创建一个新的存储库开始:

1.  这一步很容易。前往[https://github.com/](https://github.com/)，登录，点击新建按钮，填写所有信息。在我们的例子中，我们将存储库命名为与包相同的名称— `wikiwwii`。我们还将添加一个标准的 Python `.gitignore`文件和一个`README.MD`文件。您还可以为您的存储库添加您选择的许可证。
2.  接下来，我们创建存储库并将路径复制到剪贴板。有了它，我们就可以打开终端，进入硬盘上的正确位置，然后...

        

# 构建包的几种方法

Python 包的结构由几个规范(【https://packaging.python.org/specifications/】[和 **PEPs** (简称 **Python 增强提案**，如 pep 517—](https://packaging.python.org/specifications/)[https://www.python.org/dev/peps/pep-0517/](https://www.python.org/dev/peps/pep-0517/)，pep 518—[https://www.python.org/dev/peps/pep-0518/](https://www.python.org/dev/peps/pep-0518/)，pep 427—[https://www.python.org/dev/peps/pep-0427/](https://www.python.org/dev/peps/pep-0427/))定义，整体定义来自 **Python 打包权威** ( **PyPA** )。本质上，除了实际的代码之外，一个包需要有一个特殊的元数据文件，包括包名、描述版本、标签、Python 版本支持细节、作者和依赖项。这个文件可以是 Python `setup.py`文件——这是很长时间以来的标准解决方案——或者是`pyproject.toml`文件。后者是一种新的、更安全的方法，但是没有设计良好的规范。

手动构建包是完全可能的。它只需要一个小小的结构和一个包含元数据的文件。然而，这是一项单调乏味的任务，因此有相当多的软件包被设计来帮助打包。一个标准捆绑包是`distutuls`。还有`setuptools`。他们两人都期待一份`setup.py`文件。

包构建的挑战之一是管理包之间的依赖关系。一个包可能依赖于另一个包，而另一个包又可能依赖于几个包——所以如果您的包需要安装几十个其他的包，不要感到惊讶。甚至很有可能这些包中的一些会依赖于同一个包的不同版本，所以*某人*将不得不找出一种方法来安装满足所有需求的版本，或者以某种方式安装同一个包的两个版本。这是上一代包构建者没有完全解决的挑战。

最近，出现了一些新工具——即`flit`和`poetry`——它们都支持`pyptoject.toml`文件，并能很好地解决依赖性。在本章中，我们将使用`poetry`来构建我们的包。这个软件包有一个光滑和富有表现力的界面，并支持`.toml`格式。它还为开发人员构建了一个专用的虚拟环境，并具有两个级别的依赖关系描述:一个是用户所需的灵活的包列表，另一个是开发人员所需的明确而精确的包，其中包含安装在开发人员机器上的所有依赖关系包的精确版本列表。它还具有用于依赖性诊断和包发布的工具。

        

# 用Poetry尝试代码

像`flit`一样，Poetry是最近的旨在帮助 Python 包开发的包之一。它的特性包括编写一个`pyproject.toml`文件的能力，这比使用`setup.py`的老方法更加安全和容易，以及为一个项目创建一个专用的虚拟环境的能力，所有的依赖关系都是固定的。更重要的是，它有一个彻底的依赖关系解析引擎，可以确保所有的依赖关系版本相互匹配，还有一个界面可以监控和碰撞你的依赖关系树。

但是首先，我们将从创建一个项目模板开始。首先，键入以下内容:

```
poetry new --name=wikiwwii my-package
```

这将生成一个新文件夹`my-package`，其中包含默认文件和文件夹...

        

# 添加实际代码

既然包结构已经就绪，我们可以开始添加实际的代码了。首先，我们从[第 7 章](232fe2da-7fa8-4d76-b5fc-d4bf80535e86.xhtml)、*用美汤 4* 从 Web 抓取数据中复制并粘贴代码，用于`wiki.py`包。因为我们希望在同一个包中包含收集和清理的代码，所以创建两个子文件夹— `collect`和`parse`听起来很聪明。[第七章](232fe2da-7fa8-4d76-b5fc-d4bf80535e86.xhtml)、*用美汤 4* 从 Web 上抓取数据的代码，会到后一个。现在，我们将在`parse`文件夹中创建两个文件——`battles.py`和`fronts.py`。在 Python 中，在导入时，它们将被映射到一个路径，比如`wikiwwii.parse.battles`，从而能够访问其中的所有函数和变量。

接下来，我们以类似的方式添加清理代码。但是，这里的大部分清理代码都存储在`1_data_cleaning.ipynb`笔记本里。当然，我们可以运行 Jupyter 服务器，将所有文件复制并粘贴到 **Visual Studio** ( **VS** )代码中，但是还有一个更好的选择。而是打开命令调板(默认为*Shift*+command/*Ctrl*+*P*)，选择 Python: Import Jupyter Notebook，勾选我们的笔记本。正如您将看到的，VS 代码会将文件转换成普通的脚本，用注释标记单元格。

VS 代码实际上甚至允许一步一步地交互运行转换后的单元格。此外，它支持将该文件转换回笔记本。当你需要从 VS 代码内部调整笔记本中的某些东西时，这是很有用的。

这是我们移动实际代码后的文件夹树:

```
wikiwwii
├── README.md
├── pyproject.toml
├── tests
│ ├── __init__.py
│ └── test_wikiwwii.py
└── wikiwwii
 ├── __init__.py
 ├── collect
 │ ├── __init__.py
 │ ├── battles.py
 │ └── fronts.py
 └── parse
 ├── __init__.py
 ├── bellengerets.py
 ├── casualties.py
 ├── dates.py
 ├── geocode.py
 └── qa.py
```

包中的代码通常不打算在导入时直接运行；因此，它(通常)只由函数、变量和对象组成。除非明确需要，否则直接在包中执行代码是一种不好的做法——每次有人从这个文件导入时，它都会被执行。同样，在可能的情况下，尽量不要导入您不需要的包，或者生成大的结构，直到您真正需要它们。一个好的做法是只在必要的地方导入依赖包，这样即使包丢失了，一些代码仍然是可执行的。

        

# 定义依赖关系

现在，正如你可能已经注意到的，我们来自《T4》第七章、*的代码用美汤 4* 从网络上抓取数据，依靠两个库——`requests`和`BeautifulSoup4`——来工作。解析需要另一个包，`pandas`。对于我们假想的用户来说，最好安装那些包，甚至更好的是，确保我们安装的版本支持我们需要的。这是`poetry`茁壮成长的地方。在您的终端中，键入以下内容:

```
poetry add requests beautifulsoup4 pandas
```

Poetry将扫描我们当前的环境，检测我们使用的那些包的版本，并将它们的特征添加到`pyproject.tamp`和一个新文件`poetry.lock`中。前者是一个(最近增加的)标准规范——它将在...

        

# 非代码资源

如果您的包需要包含除 Python 文件之外的内容—例如，一个小数据集或一个查询模板—您需要在`pyproject.toml`中将它显式添加为包的一部分，如下所示:

```
[tool.poetry]
include = ["*.sql"]
```

在某些情况下，您可能不希望在实际的包中包含一些 Python 脚本(例如，一些支持脚本)。为此，您需要在同一部分添加一个类似的`exclude`行:

```
[tool.poetry]
include = ["*.sql"]
exclude = ["wikiwwii/uploader.py"]
```

我们在构建的包中没有添加或排除任何文件——至少现在没有——所以我们不会在`.toml`文件中包含这个部分。

        

# 发布包

现在，假设一切正常，我们可以尝试用`poetry install`安装依赖项。这不会(尽管这个名字有些误导)在您当前的环境中安装这个包——相反，`poetry`创建自己的虚拟环境用于测试目的。

一旦完成，我们就可以构建并发布我们的包到 PyPI(使用`poetry build`和`poetry publish`)，这样每个人都可以使用它。让我们不要着急——我们的包还在襁褓中，还没有经过测试和保护。

而是让我们把 GitHub 作为一个分享平台。一旦你的当前版本被推送到存储库，这个包就可以直接从 GitHub 安装了——`pip`也支持这个功能:

```
pip install git+https://github.com/Casyfill/wikiwwii.git ...
```

        

# 开发工作流程

现在，权力越大，责任越大。目前，我们提交到主分支，这是安装的默认分支，所以我们可能不想在那里添加一些不可靠的代码。因此，让我们坚持下面这个相当简单的实践——我们永远不应该将代码直接推送到主分支。相反，我们应该在一个单独的开发分支上工作，将其推送到 GitHub，然后——一旦我们对结果满意——将分支合并到主分支中。为此，GitHub 甚至支持代码审查和讨论。现在让我们切换到开发分支:

```
git checkout -b tests
```

您可能会注意到，VS 代码会在窗口的左下角标记当前分支。事实上，您可以点击它并切换到不同的分支，甚至手动创建一个新的分支。接下来是测试代码并检查它是如何工作的。

        

# 测试目前为止的代码

不管怎样，我们怎么知道代码是好的呢？唯一的好方法是严格测试你的代码。虽然这听起来像是许多有些不必要的工作，但这是一种将在未来多次回报您的实践——一旦您确定您的代码如预期那样运行，添加新功能并确保它们不会破坏任何现有功能就容易多了。此外，您可以升级依赖项或比较不同的实现，确保您的代码行为符合预期。

至于其他许多东西，Python 有一个用于测试的标准库— `unittest`。然而，与大多数标准库相比，`unittest`相当不受欢迎。相反，另一个图书馆，`pytest`，被认为是...

        

# 使用 PyTest 进行测试

事实上，`poetry`甚至为我们生成了一个测试函数，尽管它并不测试我们的代码；相反，它会检查版本。看看这里的代码:

```
from wikiwwii import __version__

def test_version():
    assert __version__ == '0.1.0'
```

这里，有两件事值得讨论。首先，如您所见，该测试只是一个名称中带有“test”一词的函数。拥有这个单词是必要的——这是`pytest`找到所有测试的方法。第二，每个测试产生一个或几个`assert`语句。为了通过测试，`assert`不应该提出任何问题。这就是测试开发的所有基础。

现在让我们运行这个现有的测试；一般来说，我们所需要的就是在命令行中键入`pytest tests`。然而，对于`poetry`，我们有一个隐藏的虚拟开发环境，所以我们应该在那里运行我们的测试；为此，键入`poetry run pytest tests`。如果一切正常，`pytest`应该打印出一个包含 Python 版本、`pytest`、包和测试描述的小报告，如下所示:

```
>>> poetry run pytest tests
========================= test session starts =========================================
platform darwin -- Python 3.7.1, pytest-3.10.1, py-1.8.0, pluggy-0.12.0
rootdir: /Users/philippk/Dropbox/personal_projects/wikiwwii, inifile:
collected 1 item 

tests/test_wikiwwii.py .                                                             [100%]

============================ 1 passed in 0.02 seconds =====================================
```

耶！这个测试通过了。

        

# 编写我们自己的测试

不过说真的，现在我们自己写个测试吧。首先，让我们从一些相对基础的东西开始，比如找出我们的函数如何从给定的页面及其元素中提取数据。

测试`requests`库从网上收集网页的能力没有太大的价值——假设它有，它有自己的测试。因此，我们将所有解析代码从`parse_battle_page`函数转移到了`private _parse_page`函数中。这样，我们可以专注于测试解析，而不是互联网。

首先，我们将在`tests/data/pages`文件夹中存储一些战斗的 HTML 页面。现在我们将创建一个名为`test_collect_battles.py`的文件——这里我们将存储这个特定模块的所有测试。...

        

# 利用 CI 服务实现流程自动化

现在，您可能还记得，我们正在开发我们的存储库的一个`tests`分支。如果你去 GitHub，它可能会提供创建一个 pull 请求——一个将你的分支合并到主分支或任何其他分支的过程，如下图黄色部分所示。即使界面不提供这种功能(如果几分钟前已经有一个拉请求，就不会提供)，您也可以通过新的拉请求按钮自己创建一个拉请求。见以下截图:

![](img/92c644bc-1d96-4bfe-8dbd-df1abdad604b.png)

使用 GitHub，您可以请求其他人查看您的更改，对其进行评论，等等；GitHub 还会确认合并是否可行，或者你是否需要先解决冲突。

虽然在我们的例子中，我们确实在本地运行了我们的测试，并且我们知道合并是安全的，但是对于其他人来说，没有办法轻松地进行检查。为了使每个人的生活更简单，并为您节省一些时间(对于大型项目，适当的测试可能需要一段时间)，使用了**持续集成** ( **CI** )服务。大多数情况下，CI 服务所做的只是触发新的提交，将代码拉至虚拟机，运行您的测试，然后报告测试成功确定的任何内容。由于 CI 服务的自动化特性，即使在不同环境下的多台机器上运行也很容易——比方说，一个服务可以在 Python 3 上测试您的代码，一个可以在 Python 2 上测试您的代码。

请注意，CI 服务可以做得更多。例如，他们可以从存储库中自动重新生成文档并发布它，将您的包推送到注册中心，并将任何其他工件对象上传到其他地方。探索这些选项！

一般来说，CI 服务是要花钱的。不过，其中大多数都有免费的开源项目层。因为我们的包是开源的，对任何人开放，所以让我们利用 CI 服务的免费层。周围有很多很棒的服务，它们都或多或少是一样的。我们将使用 Azure 管道，但如果您愿意，也可以选择其他管道。

开始之前，我们需要完成几个简单的步骤:

1.  首先，我们需要去 Azure DevOps 网站([https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/))注册。我们将允许它访问我们的 GitHub 帐户，并为`wikiwwii`库创建一个构建管道。一会儿，Azure 将为您提供几个场景，从 Python 开始——这是我们需要的。
2.  接下来，它将显示一个简单的管道作为 YAML 文件。默认情况下，它将提供使用不同 Python 版本运行多个实例。除了 3.7 我们都可以放弃。
3.  由于我们正在使用`poetry`，我们可以根据 per 的安装指南，用`poetry`安装命令替换`pip install`行。在下一行，安装了`pytest-azurepipelines`包。我们不能使用它，因为我们需要通过`poetry`安装它，所以我们必须将它添加到`poetry`开发依赖列表中。同时，在本地拥有这个包是没有意义的，所以我们可以把它标记为额外的:

```
poetry add --dev --extras azure pytest-azurepipelines
```

4.  这是我们管道的第一步:

```

script: |
          curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python
          source $HOME/.poetry/env
          poetry --version
          poetry install -E azure
          displayName: 'Install dependencies'

```

5.  现在，第二步很简单——只需在Poetry中运行`pytest`:

```
- script: |
           poetry run pytest --cov=wikiwwii tests
           displayName: 'pytest'
```

6.  最后但同样重要的是，默认管道对主分支上的任何活动都有效。相反，让我们在向主设备发出拉请求时触发它。为此，只需在 YAML 中将触发器替换为`pr`:

```
pr:
- master
```

我们完事了。现在允许 Azure 向主分支提交代码；不要忘记提交添加了`pytest-azurepipelines`的包的新版本。让我们尝试一个拉请求。

如果一切正常，GitHub 会在 pull request 部分的列表中的最后一次提交附近显示一个黄色的小圆圈。如果您将鼠标悬停在它上面，它将显示当前配置项状态，即排队或正在运行。一旦管道运行，圆圈将根据结果变成绿色或红色。以下截图显示了这一点:

![](img/4f851b13-1c19-4e23-9cc2-92f39dd254fd.png)

现在我们完成了 CI。所有其他 CI 系统都非常相似；他们中的大多数使用 YAML 作为流程的声明，因此如果需要，可以很容易地在不同的 CI 系统之间切换。

接下来，让我们为我们最喜欢的项目生成一些文档。

        

# 用 sphinx 生成文档

当涉及到支持你的代码的消费者和说服新来者购买和使用你的包是有意义的时候，文档是王道。对于大多数人来说，文档网站是他们了解软件包的第一个地方。根据定义，它被认为是当前版本代码的唯一真实来源。

文件的作用通常有三方面:

*   解释如何安装您的包以及一般要求是什么(例如，支持哪些 Python 版本)
*   展示如何使用这个包(最好有一个快速的例子来展示它的即时价值)
*   表达包装的总体思想和理念

文档网站有...

        

# 在可编辑模式下安装软件包

正如我们提到的，你可以从 GitHub 安装一个包，它的行为和其他任何已安装的包一样——它可以被升级或卸载。

然而，通常你会想在开发的时候使用一个包。在正常的安装程序中很难做到这两点；每次你做了任何开发上的改变，你都必须更新或者重新安装这个包，仅仅是为了反映那些改变。为了解决这个问题，有一个很好的特性保持了两个世界的优点——您的代码被视为一个包，但可以很容易地就地修改。该功能称为可编辑模式。本质上，这意味着文件系统上的文件夹被注册为一个包，因此导入的包将总是反映您所做的所有更改。

为了获得这些好处，您必须在本地机器上拥有一个有问题的包的存储库。显然我们有自己的包，但是通过`git clone my/package/url`提取原始代码也很容易。接下来，您打开终端，在`package`文件夹的上一步，您键入以下内容:

```
pip install -e wikiwwii
```

嘣！您有一个可编辑的包。你可以在你的 Jupyter 笔记本上测试一下:

```
>>> import wikiwwii  
```

看到了吗？它的行为就像是一个正确安装的包，但是您可以对您的代码进行更改，这些更改将在您下次导入时立即应用。

在写这本书的时候，基于 TOML 的包不支持可编辑模式。这应该很快就会改变。

本节帮助您在可编辑模式下安装软件包，所以现在我们应该可以尝试一些新的代码文件了！

        

# 摘要

在这一章中，我们回顾了打包代码的所有过程。特别是，我们创建了一个 GitHub 存储库，通过`poetry`生成了一个模板，并添加了所有的依赖项，这意味着现在每个人都可以使用`pip`从 GitHub 安装这个包。然后，我们更进一步，添加了一些测试来确保我们的包在未来的开发过程中能够如预期的那样工作。为了简化流程并使其透明，我们集成了一个 CI 服务 Azure pipelines 来对每个 pull 请求运行测试，以防止我们将失败的代码合并到产品中。

在下一章中，我们将回顾另一个案例，使用`luigi`构建一个健壮、安全、生产就绪的数据管道。

        

# 问题

1.  打包代码有什么好处？
2.  `conda`和`pip`作为包经理的主要区别是什么？
3.  什么是依赖解析，为什么很难？
4.  `poetry`比标准`setuptools`有什么好处？
5.  为什么我们需要测试？
6.  CI 的目的是什么？

        

# 进一步阅读

*   *Python 包入门*(【https://hub.packtpub.com/getting-started-python-packages/】T2)
*   *用 Python 写包*(【https://hub.packtpub.com/writing-package-python/】T2)
*   *Python 中的测试工具和技术*([https://hub . packtpub . com/Testing-Tools-and-Techniques-Python/](https://hub.packtpub.com/testing-tools-and-techniques-python/))