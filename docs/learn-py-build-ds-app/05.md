        

# 四、数据结构

在前面的章节中，我们使用了单变量。不难看出这种方法的局限性——许多任务涉及重复的过程和丰富的数据结构。事实上，值的实际数量经常会变化，所以我们的代码应该能够批量处理值。当然，Python 有一些内置的数据结构来满足这些需求！

在这一章中，我们将讨论最流行的数据结构以及它们各自的 API、优点和缺点。数据结构对于编程技能是必不可少的，因为它们是大多数任务及其行为所必需的。每种特定结构类型的优点和缺点都深深植根于它们的基本机制中，这些机制会显著影响...

        

# 技术要求

本章不需要任何额外的包；所有代码都可以在 GitHub 资源库的`Chapter04`文件夹中获得([https://GitHub . com/packt publishing/Learn-Python-by-Building-Data-Science-Applications](https://github.com/PacktPublishing/Learn-Python-by-Building-Data-Science-Applications))。

        

# 什么是数据结构？

我们所说的数据结构到底是什么意思？一般来说，它们是能够以系统的方式存储和检索任意数量的任何类型的值的对象。换句话说，数据结构类似于基本数据类型:它们可以通过变量存储、删除、更改等等。

内置数据结构提供了一种标准的、高性能的方法来处理大量数据。然而，根本不存在什么灵丹妙药或放之四海而皆准的数据结构。每一种的优点和缺点都是固有的，与总体设计密不可分。让我们浏览一下主要的数据结构，并讨论每种结构的优缺点。下面几节将介绍中的主要数据结构...

        

# 列表

列表可能是 Python 中最常用的数据结构类型。列表是一个简单有序的 1D 元素数组。每个元素都有自己的索引号，从 0 开始，所以最后一个元素的索引总是为 *L* -1，其中 *L* 是列表中元素的个数。列表可以存储任何混合的数据类型。它们也可以存储任何其他数据结构。例如，矩阵(2D 阵列)可以表示为列表的列表，或者 3D 矩阵可以表示为列表的列表的列表。列表是动态的，这意味着您可以添加或删除任意数量的项目，甚至可以改变它们的顺序，而无需从头开始重建列表。

您可以使用`list()`函数创建一个新列表，或者使用方括号，用逗号分隔元素:

```jl
fruits = ['banana', 'apple', 'plum']
```

如果需要，您也可以创建一个空列表:

```jl
basket  = []
another_basket = list()
```

与字符串一样，我们可以使用内置的`len`函数来检查列表的长度:

```jl
>>> len(fruits)
3

>>> len(basket)
0
```

我们总是可以通过`.append`方法将新的元素添加到列表的末尾:

```jl
>>> fruits.append('pineapple')
>>> fruits
['banana', 'apple', 'plum', 'pineapple']
```

或者，我们可以将它们插入特定的位置:

```jl
>>> fruits.insert(2, 'orange')
>>> fruits
['banana', 'apple', 'orange', 'plum', 'pineapple']
```

我们还可以使用`.extend`将它们与另一个列表合并:

```jl
>>> fruits.extend(['melon', 'watermelon'])
```

在某些情况下，您可能希望检索一个元素并将其从列表中删除。一个这样的例子是如果你需要一个接一个地处理元素。为此，`.pop()`方法是理想的，因为它将从列表的末尾返回元素，同时将它从列表中移除。在下面的例子中，我们从列表中删除最后一个值。之后，不出所料，列表的长度减少了一个:

```jl
>>> len(fruits)
7

>>>fruits.pop()
'watermelon'len(fruits)
>>> 6
```

最后，可以使用`in`语句检查列表是否包含某个元素。这也适用于任何其他可重复项:

```jl
>>> 'melon' in fruits
True
```

现在，让我们来谈谈列表、字符串和许多其他数据结构的一个重要属性:切片。

        

# 限幅

与字符串一样，为了从列表中获取单个值，您需要在值后面的方括号中使用它的索引，如下面的代码片段所示:

```jl
>>> fruits[0]'banana'
```

还可以通过使用切片来获得列表值的子集:由两个数字定义并由冒号分隔的索引间隔。数字代表开始和结束索引；前一个数字是包含的，后一个数字不是。如果缺少一个或两个数字，Python 会认为它们是列表的结尾。这里有一个例子:

```jl
>>> fruits[0:2]['banana', 'apple']>>> fruits[:2]['banana', 'apple']
```

在这两种情况下，我们都在提取前两个元素。在这种情况下，我们是否包含`0`并不重要。

这正是...

        

# 元组

元组经常处于列表的阴影下。从表面上看，它们非常相似:它们也是 1D 数组，可以混合不同的类型，使用相同的索引，并且可以切片。与列表类似，可以使用`tuple()`函数或仅使用括号来创建元组:

```jl
breakfast = ('oatmill', 'scrambled eggs', 'orange juice')
```

有一个主要的区别使得元组在一些任务中工作得更好，但在另一些任务中就不那么好了。正如我们之前提到的，列表是动态的，可以被修改。元组不是；一旦构建完成，元组就保持静态，不能更改(因此，它们没有 append 和 extend 方法)。这种性质被称为不变性。

        

# 不变

不可变对象不能就地改变；如果不创建新变量，就必须创建一个新对象。就其本身而言，这是不方便的，但这也意味着任何内部值都不能改变，这意味着——根据定义——元组不能包含列表或任何其他动态对象。

它们是故意被做成这样的，这有很大的好处。首先，列表的动态特性是有代价的:为了保持动态和高性能，它们保留了比所需更多的内存。相比之下，元组使用的内存要少两倍！其次，这是最重要的部分，因为元组被保证是静态的，它们*可以*被用作其他数据结构的不可变部分，比如集合...

        

# 字典

字典是一种不同类型的结构。它们不是有序数组，而是键值存储类型。字典本身没有任何顺序。相反，它们将所有内容存储为键值对。作为物理键，字典的键必须是惟一的和明确静态的。换句话说，不可改变。因此，不能有两个值相同的键，列表不能用作键，但元组可以。然而，键通常是字符串，因为它们允许我们向结构中添加某种语义:

```jl
person = {'name': 'Jim',
 'surname': 'Hawkins',
 'age':17
}
```

如您所见，字典由大括号定义，键值对由冒号分隔，由逗号分隔。一旦分配了字典，就可以使用方括号来检索值。这与列表和元组相同，但它使用键而不是索引:

```jl
>>> person['age']
17
```

请注意，字典不支持切片。不能一次按两个键，或者倒字典，因为没有顺序可言。

类似地，您可以向字典中添加键值对，如下所示:

```jl
person['hair'] = 'red'
```

由于不能有两个值相同的键，所以另一个赋值将覆盖前一个值，并且不发出警告:

```jl
person['hair'] = 'ginger'
```

与列表一样，您可以合并两个词典。一种方法是通过`.update`方法:

```jl
additional_info = {
    'gender': 'male',
    'nationality': 'british',
    'age': 16
}

person.update(additional_info)
```

类似于列表，字典有一个`.pop()`方法。但是在这种情况下，`.pop()`方法需要一个特定的键，其值将被检索和删除:

```jl
>>> person.pop('age')
16
```

除了上述方法之外，字典还有一些方便的方法。首先，您可以通过分别使用`.keys()`或`.values()`获得类似列表结构的键或值。有时，获取键值对的可迭代项很方便。这可以通过使用`.items()`方法来实现:

```jl
>>> print({'name':'Jim', 'surname': 'Hawkins'}.items())
dict_items([('name', 'Jim'), ('surname', 'Hawkins')])
```

当您试图通过提交一个不在字典中的键来获取值时，会引发`KeyError`。如果您不想要这种行为，请使用`.get()`方法。它有两个值:第一个值是键，第二个值是默认值。默认值是字典中没有数据时`.get()`返回的值:

```jl
>>> person.get('eye color', 'brown')
'brown'
```

最后，字典可以表现为可迭代的，因为你可以循环遍历它们(在第五章、*循环和其他复合语句*中有更多的内容)或者检查一个元素是否在其中。但是，这两种情况都适用于键，而不适用于值:

```jl
>>> 'name' in person
True

>>> 'Jim' in person
False
```

        

# 设置

在某种程度上，集合是没有值的字典。首先，它们使用相同的花括号，其次，它们的成员不能重复，这两者都类似于字典键。正因为如此，它们可以方便地用于重复数据删除或成员测试。最重要的是，集合具有内置的数学运算、并、交、差和对称差:

```jl
>>> names = set(['Sam', 'John', 'James', 'Sam'])>>> names{'James', 'John', 'Sam'}>>> other_names = {'James', 'Nikolai', 'Iliah'}>>> names.difference(other_names){'John', 'Sam'}>>> names.symmetric_difference(other_names){'Iliah', 'John', 'Nikolai', 'Sam'}
```

集合没有顺序，与字典相比，不能保证表示的顺序...

        

# 更多数据结构

列表、元组、字典和集合是 Python 中最流行和最广泛的数据结构。然而，它们不是唯一的，甚至在准系统 Python 发行版中，还有更多。由于这些数据结构更加特殊，我们将对它们进行简单的概述。您可以在 Python 文档中找到更多信息([https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html))。

        

# frozenset

`frozenset`生活在 Python 本身，所以不需要导入任何东西。它们与序数集合 100%相似，除了它们是不可变的。就像元组一样，您不能更改它们，它们可以用作字典键，还有其他相似之处:

```jl
>>> frozenset('Hello')frozenset({'e', 'H', 'l', 'o'})
```

        

# defaultdict(预设字典)

`defaultdict`住在内置的`collections`模块里。它在创建时设置了一个默认值，如果传递了一个丢失的键，它将返回这个默认值，而不是引发`KeyError`。虽然这种行为可以通过普通字典的`get`方法实现，但是`defaultdict`的执行速度是那些有缺失值的字典的两倍。在下面的代码片段中，我们定义了一个字典，如果缺少键值，它将返回一个空字符串:

```jl
from collections import defaultdict
d = defaultdict(str) # returns empty string as default value

d['name'] = 'John'
```

现在，让我们得出这些值:

```jl
>>> d['name']
John

>>>d['surname']
>>> ''
```

如您所见，如果键丢失，`defaultdict`不会引发`KeyError`。相反，它传递一个缺省值，这个缺省值是由我们在初始化时添加的函数定义的(在我们的例子中，`str`)。

        

# 计数器

来自`collections`模块的`Counter`结构被设计用来计算数值。您可以从 iterable 创建它。在这种情况下，它将计算所有值的频率。或者，您可以给它一个字典，其中的值都是整数，它会将键视为要计数的元素，将值视为相应的频率。一个接一个地增加或减少`Counter`结构是很容易的。你也可以给它们提供更多的可迭代内容，用`dict`或另一个`Counter`实例更新它们:

```jl
>>> from collections import Counter>>> Counter('Hello')Counter({'l': 2, 'H': 1, 'e': 1, 'o': 1})>>> c1 = Counter({'banana': 2, 'apple': 1})>>> c1['apple'] += 1>>> c1Counter({'banana': 2, 'apple': 2})
```

如果被视为可迭代的计数器...

        

# 长队

`Queue`模块提供了一组队列结构，在添加和释放值方面很有效。一个经典的`Queue`对象，也被称为**先进先出** ( **先进先出**)，提供了一种方便的方式来管理诸如任务之类的事情。您不需要担心实例的顺序，因为首先提交的任务将首先被检索，以此类推。

队列有一个`maxsize` 参数，如果您试图添加比`maxsize`值更多的元素，就会引发异常。他们还有`.task_done()`方法，你可以从你的代码中运行它，表明任务已经完成，并允许`Queue`安全地丢弃它，从而减少队列中的任务数量。

由于队列的设计考虑到了多线程(多个任务同时运行)，队列还支持等待队列中的*空位*、等待`put` 和`get`方法，最大等待时间可以由超时参数定义，默认情况下是无限的。

让我们看看下面的例子。首先，我们创建一个队列，并向其中添加两个*任务*。我们可以通过使用`qsize`方法来查看任务的数量:

```jl
>>> from queue import Queue
>>> Q = Queue(maxsize=2)

>>> Q.put('wash dishes')
>>> Q.put('water flowers')

>>> Q.qsize()
2
```

由于我们的`Queue`的最大大小为`2`，它现在已经满了，如果我们试图再添加一个任务，它将等待(在我们的例子中，永远)现有的任务被删除。然而，如果我们愿意，我们可以通过用`put_nowait`方法添加另一个任务来覆盖它。现在，让我们从队列中取出任务。第一个任务将是`wash dishes`，因为它是第一个进入队列的任务:

```jl
>>> Q.get()
'wash dishes'
```

一旦我们提取了任务，我们可以假装它已经完成，并告诉队列。我们可以通过以下命令进一步检查需要完成的任务数量:

```jl
>>> Q.task_done()
>>> Q.qsize()
1
```

由于数量现在小于最大值，我们可以推送新任务，而无需等待任务从`Queue`中移除:

```jl
>>> Q.put('check mail')
>>> Q.qsize()
2
```

一个**后进先出** ( **LIFO** ) **队列**，也称为**堆栈**，工作方式相同，除了它首先释放最后提交的任务，以便最后检索第一个提交的任务。一个**优先级队列**根据相应的优先级值管理任务的顺序。

从 Python 3.7 开始，`Queue`模块也有`SimpleQueue`，这是一个更简单的 FIFO 数据结构，它不能跟踪任务，因此没有`.task_done()`方法。

        

# 双端队列

另一个类似的数据结构`deque`也位于`collections`模块中，它类似于队列，但是有一个细微差别。因为它们是**双端队列**，顾名思义，它们可以从两端有效地添加和释放值，而不是从一端。

让我们看看下面的代码:

```jl
from collections import dequeD = deque(['wash dishes', 'water flowers', 'check mail'])
```

正如我们提到的，`deque`可以有效地从队列的左端和右端删除值。在下面的代码中，`pop`代表最右端，而`popleft`从左侧拉取值:

```jl
>>> D.pop()'check mail'>>> D.popleft()'wash dishes'
```

类似于`.pop_left()` , `deque`有`.append_left()`和`.extend_left()`方法。...

        

# 命名元组

`namedtuple`集合便于以富有表现力的方式存储数据。您可以将它们看作元组和字典的混合体，因为它们从前者获得了较小的内存占用和不变性，从后者获得了关键字访问。如果您处理没有绑定逻辑的相同结构的多个数据点，例如 eShop 中的用户或商品，那么它们将非常有效。在实际创建实例之前，我们必须指定未来记录的属性(不变性，还记得吗？).在下面的代码片段中，我们为用户创建了一个包含`name`、`surname`和`age`属性的数据结构。一旦定义了命名元组，就无法对其进行更改:

```jl
from collections import namedtuple
user = namedtuple('User', 'name, surname, age')
```

现在，我们可以添加基于先前定义的元组的实例:

```jl
peter = user(name='Peter', surname='Pan', age=13) 
wendy = user(name='Wendy', surname='Darling', age=13)
```

`namedtuple`高效的原因之一是它的参数结构只存储一次，而不是每次都存储。一旦有了实例，就可以通过使用索引、切片或属性名来检索它们的属性:

```jl
>>> peter[0]
Peter

>>> peter[:2]
('Peter', 'Pan')

>>> wendy.surname
'Darling'
```

如果出于某种原因，我们需要以字符串值的形式通过属性名称来检索属性，或者测试这样的参数是否存在，我们可以使用 Python 的内置`getattr`和`hasattr`函数:

```jl
>>> hasattr(wendy, 'age')
True

>>> getattr(wendy, 'age')
13
```

一个`namedtuple`集合是一个从元组继承的类；元组的结果实例是 100%正常的类实例。您可以通过传递一个`verbose=True`参数来查看代码。也就是说，Python 3.7 引入了数据类，这是纯 Python 类，可以解决一些类似的问题。虽然它们比早期的数据类占用更多的内存，但它们更具描述性和灵活性。

        

# 列举

枚举是 Python 中不太流行的数据结构。它们非常类似于命名元组，因为它们是不可变的，并且它们的属性是命名的。枚举还有一个有趣的特性:它们总是单例的。换句话说，一个`Enum`类不能同时有多个实例。因此，枚举作为一组特定值的语义层(别名)工作得很好；例如，对于类别，我们可以在调色板中定义颜色，别名的具体实现。singleton 属性意味着该值在整个代码中总是完全相同的。

在下面的例子中，我们为颜色主题定义了一个`Enum`类。我们的`Enum`对象支持三种颜色:`MAIN`，

        

# 使用发电机

生成器不完全是数据结构——它们是函数。然而，当*普通的*函数计算它们的结果并立即返回时，生成器可以动态地停止和恢复，导致类似 iterable 的行为。换句话说，您可以对生成器进行循环，一次检索一个值。然而，与经典的可迭代程序不同，生成器是懒惰的。一旦我们需要它们，它们就会计算价值，但不是在我们计算之前。因此，与 iterables 相比，它们的行为有一些显著的不同:

*   首先，生成器使用固定数量的内存。即使你让一个人计算无数的值，每次你请求的时候，生成器只会产生并存储一个值，这太棒了！事实上，生成器可以产生无限多的值，而不会有内存问题。
*   第二，由于生成器不存储值，因此无法通过索引来检索值。为了得到第三个元素，你需要先计算前两个。同样，也没有办法让*回到*前一个元素。如果你没有存储它，这个值就丢失了。此外，除了计算所有值之外，没有其他方法可以估计生成器的长度，但是，生成器可以是无限的。

对于作为生成器工作的函数，它需要发出多个`yield`语句，而不是`return`语句。一旦函数被调用，您可以像对待一个列表或元组一样对其进行循环，或者使用 Python 的内置`next()`函数一次检索一个值:

```jl
def my_generator(N, power=2):

 # for loop, which we'll cover in depth in the next chapter.
 # note that loops require another level of indentation
 for el in range(N):
 yield el**power

N = my_generator(4, power=2)

next(N)
>>> 0

for el in N:
 print(el)
>>> 1   # zero was computed already
>>> 4
>>> 9
```

在前面的例子中，我们使用了`range()` 函数，它接受一到三个整数参数，只有`1`是必需的。如果提供了`1`，`range`将返回一个从`0`到该数字的数字生成器，不包括它。如果提供了`2`，前者将成为启动器，而后者(在发电机的末端)将再次被排除。如果提供了`3`，它将被用作一个步骤。Python 中有很多其他函数返回**生成器**。如果您需要一个列表或元组，不要担心——只需转换它们:

```jl
list(range(5))
>>> [0, 1, 2, 3, 4] 
```

`range`对象有一些*语法糖*功能。例如，它*可以*检查包含，而不需要实际计算值(这是一件非常容易的事情，如果你仔细考虑的话):

```jl
20346 in range(0, 100_000_000, 2)  # even numbers
>>> True
```

        

# 与数据结构一起使用的有用函数

有一些函数和接口对处理数据很有用，从简单的如`sum`、`max`和`min`，到复杂的如`zip`、`map`、`filter`和`reduce`。

        

# sum、max 和 min 函数

这些函数基本上是不言自明的:它们将试图对可重复项中的值进行汇总或比较。请记住，对于字典，将使用它的键，而不是值:

```jl
sum({1:'A', 2:'B'})
>>> 3
```

注意`min`和`max` 不要求元素是整数或浮点数:

```jl
max({'A':1, 'B':2})
>>> 'B'
```

        

# 所有和任何功能

`all`和`any`也是不言自明的。简单地说，它们是扩展的`and`和`or`运算符，一次处理多个值:

```jl
all([False, True, True])>>> Falseany([False, True, False])>>> True 
```

        

# 压缩功能

当你有 *M* 个元素的 *N* 个列表，你需要转置它们，从而得到 *N* 个元素的 *M* 个列表时`zip`是有用的。类似于`range`，它将返回一个生成器对象:

```jl
data1, data2 = (1, 2, 3, 4, 5), ('A', 'B', 'C', 'D', 'E')

result = list(zip(data1, data2))

result
>>> [(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D'), (5, 'E')]
```

`zip`也可以反过来使用`result`变量作为`args`:

```jl
list(zip(*result))
>>> [(1, 2, 3, 4, 5), ('A', 'B', 'C', 'D', 'E')]
```

`zip`也可以用来创建数据结构:

```jl
dict(zip(data1, data2))
>>> {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}
```

        

# 映射、过滤和减少功能

您可能会发现对数据结构有用的其他函数有`map`、`filter`和`reduce`。这些在与其他函数(如 lambdas)结合使用时非常有用。

对 iterable 的每个元素运行给定的函数，返回一个生成器:

```jl
>>> data1, data2 = (1, 2, 3, 4, 5), ('A', 'B', 'C', 'D', 'E')>>> list(map(lambda x: x**2, data1))  # converting to list in order to seE results[1, 4, 9, 16, 25]>>> list(map(lambda x: x.lower(), data2))['a', 'b', 'c', 'd', 'e']
```

类似地，`filter`返回元素的子数组，函数为这些元素返回 true 或 truthy 值:

```jl
list(filter(lambda x: x > 3, data1))>>> [4, 5]
```

最后，`reduce`——在 Python 3 中被移到了`itertools`包中——运行给定的函数...

        

# （听力或阅读）理解测试

理解是处理数据结构的一种很好的表达方式。让我们从一个简单的例子开始:

```jl
{el**2 for el in range(3)}
>>> {0, 1, 4}
```

这里，花括号定义了我们的结果。我们使用`range`来创建初始的 iterable，然后循环遍历它的值，计算每个值的平方值。不过，这不是一个真正的循环。列表理解实际上比循环甚至是`map`更快，因为没有 lambdas，因此没有额外的栈查找成本:

```jl
>>> %%timeit
... s = set()
... for el in range(10):
...     s.add(el**2)
3.35 µs ± 134 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

>>> %timeit set(map(lambda x: x**2, range(10)))
3.72 µs ± 207 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

>>> %timeit {el**2 for el in range(10)}
3.11 µs ± 309 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```

最重要的是，理解可以嵌套，使用`if`语句(因此，取代了`filter`函数)，并在不同的数据结构上操作。在下面的例子中，我们使用一个理解来浏览字典列表，并创建一个包含角色名称的新列表，但只针对年龄在 15 岁以下的角色(只有他们可以去*梦幻岛*，你知道):

```jl
>>> characters = [
 {'name': 'Peter Pan', 'age': 13, 'type': 'boy'},
 {'name': 'Wendy Darling', 'age': 14, 'type': 'girl'},
    {'name': 'Captain Cook', 'age': 45, 'type': 'pirate'}
     # just guessing
]

>>> [el['name'] for el in characters if el['age'] < 15]
['Peter Pan', 'Wendy Darling']
```

我们甚至可以用理解来交换字典的键和值。在下面的代码中，我们使用现有字典的值作为键，并使用键作为值来创建一个新字典:

```jl
D = {'A':1, 'B':2 }

{v:k for k, v in D.items()}
>>> {1:'A', 2:'B'}
```

这就结束了我们对数据结构的介绍。在接下来的章节中，我们将更广泛地使用我们刚刚学到的一切。

        

# 摘要

在本章中，我们学习了 Python 中基本的和更高级的数据结构。我们讲述了如何创建、交互和操作这些结构。除了结构之外，我们还讨论了生成器和理解，生成器是将 T2 伪装成可迭代结构的函数，而理解是一种创建和使用数据结构的简洁而快速的方法。我们还简要地谈到了循环和`if`语句，并了解了它们是如何工作的。

在下一章，我们将讨论不同类型的循环和语句，这将允许我们动态地操作数据集并将逻辑嵌入到我们的代码中。

        

# 问题

1.  我们如何从列表中获取一个元素？我们如何在不显式计算长度的情况下检索列表的最后一个元素？
2.  我们如何以相反的顺序得到列表中的所有元素——除了第一个和最后一个？
3.  我们如何合并两个字典，如果两个字典中的一些关键字相同，会发生什么情况？
4.  检查成员资格的最佳数据结构是什么？
5.  我们能得到发生器的最后一个元素而不得到所有其他的吗？
6.  我们如何将来自 *N* 个三元组的元素一一组合成三个 *N* 的数组？
7.  如果每个字典的某个其他属性在集合中，生成特定字典属性列表(从字典列表中检索)的最短方法是什么？

        

# 进一步阅读

*Python 数据结构和算法*([https://www . packtpub . com/application-development/Python-Data-Structures-and-Algorithms](https://www.packtpub.com/application-development/python-data-structures-and-algorithms))